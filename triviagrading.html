<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Evil Trivia Grading</title>
  <!-- Minimal styling just for clarity -->
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .section {
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ddd;
    }
    .section h2 {
      margin-top: 0;
    }
    table, th, td {
      border: 1px solid #aaa;
      border-collapse: collapse;
      padding: 6px;
    }
    .hidden { display: none; }
    .flex-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .flex-row label {
      margin-right: 4px;
    }
    .notice {
      color: #999;
      font-size: 0.9em;
    }
  </style>
</head>

<body>
<div>
  <h1>Evil Trivia Grading</h1>

  <!-- Section A: Team Setup -->
  <div id="teamSetupSection" class="section">
    <h2>Team Setup</h2>
    <div class="flex-row">
      <label for="dateSelect">Select Date:</label>
      <select id="dateSelect"></select>
    </div>
    <br>

    <div class="flex-row">
      <label for="teamName">Team Name:</label>
      <input type="text" id="teamName" placeholder="Enter team name" />
      
      <label for="numPeople"># People:</label>
      <input type="number" id="numPeople" min="1" />
    </div>
    <br>
    <button id="addTeamBtn">Add Another Team</button>
    <button id="proceedBtn">Proceed to Grading</button>
  </div>

  <!-- Section B: Grading UI -->
  <div id="gradingSection" class="section hidden">
    <h2>Grading</h2>
    <div class="flex-row">
      <label>Date:</label>
      <span id="gradingDateSpan"></span>
    </div>
    <br>
    
    <div class="flex-row">
      <label for="gradingTeamName">Team Name:</label>
      <input type="text" id="gradingTeamName" placeholder="Edit team name" />
      
      <label for="gradingNumPeople"># People:</label>
      <input type="number" id="gradingNumPeople" min="1" />
    </div>
    <p class="notice">(Changing the team name will rename the record in the database.)</p>

    <div id="questionsContainer"></div>
    
    <br>
    <button id="saveScoresBtn">Save Scores</button>
    <button id="pickAnotherTeamBtn">Switch / Add Team</button>
    <button id="showRubricBtn">Show Rubric</button>
  </div>

  <!-- Section C: Rubric Display -->
  <div id="rubricSection" class="section hidden">
    <h2>Rubric</h2>
    <div class="flex-row">
      <button id="closeRubricBtn">Close Rubric</button>
    </div>
    <div id="rubricContent"></div>
  </div>
</div>

<!-- Firebase + JS Logic -->
<script type="module">
  /***************************************************
   * 1) Import Firebase + Initialize
   ***************************************************/
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
  import { 
    getDatabase, ref, child, get, set, update, remove 
  } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";

  // Your Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyBy8ExrgvBDto-BcNhlvrcC6ZB9G7HNaWE",
    authDomain: "eviltriviagrading.firebaseapp.com",
    databaseURL: "https://eviltriviagrading-default-rtdb.firebaseio.com",
    projectId: "eviltriviagrading",
    storageBucket: "eviltriviagrading.firebasestorage.app",
    messagingSenderId: "738486013114",
    appId: "1:738486013114:web:fe0f480cc3f66f42d6c683",
    measurementId: "G-R84N89NTJZ"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  /***************************************************
   * 2) DOM Elements
   ***************************************************/
  const dateSelect = document.getElementById("dateSelect");
  const teamNameInput = document.getElementById("teamName");
  const numPeopleInput = document.getElementById("numPeople");

  const teamSetupSection = document.getElementById("teamSetupSection");
  const gradingSection = document.getElementById("gradingSection");
  const rubricSection = document.getElementById("rubricSection");

  const pickAnotherTeamBtn = document.getElementById("pickAnotherTeamBtn");
  const showRubricBtn = document.getElementById("showRubricBtn");
  const closeRubricBtn = document.getElementById("closeRubricBtn");

  const questionsContainer = document.getElementById("questionsContainer");
  const addTeamBtn = document.getElementById("addTeamBtn");
  const proceedBtn = document.getElementById("proceedBtn");
  const saveScoresBtn = document.getElementById("saveScoresBtn");
  const rubricContent = document.getElementById("rubricContent");

  // Grading UI "Team Name" and "# People"
  const gradingTeamNameInput = document.getElementById("gradingTeamName");
  const gradingNumPeopleInput = document.getElementById("gradingNumPeople");
  const gradingDateSpan = document.getElementById("gradingDateSpan");

  /***************************************************
   * 3) Local State
   ***************************************************/
  // We'll store multiple teams in an array
  // teams[] => { teamName, date, numPeople }
  let teams = [];
  // Currently grading
  let currentTeam = null; // { teamName, date, numPeople }
  
  // We'll cache question data in memory
  // triviaData[date] => { [roundNum]: { [roundType]: { [qId]: {...} } } }
  let triviaData = {};

  // We'll also temporarily store the team's existing scores
  // so we can pre-fill the grading UI
  // existingScores[qId] = number
  let existingScores = {};

  /***************************************************
   * 4) On Load: Fetch available dates from /trivia
   ***************************************************/
  window.addEventListener("DOMContentLoaded", async () => {
    await loadDates();
  });

  async function loadDates() {
    // Read the top-level keys under "trivia" to find available dates
    const snapshot = await get(child(ref(db), "trivia"));
    if (snapshot.exists()) {
      const data = snapshot.val();
      const dateKeys = Object.keys(data).sort().reverse(); // newest first
      dateSelect.innerHTML = "";
      dateKeys.forEach(d => {
        const opt = document.createElement("option");
        opt.value = d;
        opt.textContent = d;
        dateSelect.appendChild(opt);
      });
    } else {
      dateSelect.innerHTML = "<option>No Trivia Data Found</option>";
    }
  }

  /***************************************************
   * 5) Team Setup
   ***************************************************/
  addTeamBtn.addEventListener("click", () => {
    addTeam();
    teamNameInput.value = "";
    numPeopleInput.value = "";
  });

  proceedBtn.addEventListener("click", async () => {
    addTeam(); // Add the current input as well
    if (!teams.length) {
      alert("No teams added!");
      return;
    }
    // Move to grading UI with the first team
    await doProceedToGrading(teams[0]);
  });

  function addTeam() {
    const tName = teamNameInput.value.trim();
    const tPeople = Number(numPeopleInput.value.trim() || "0");
    if (!tName) return;
    if (tPeople < 1) return;

    const dateSelected = dateSelect.value;
    // Check if we already have that team
    const existing = teams.find(t => t.teamName === tName && t.date === dateSelected);
    if (existing) {
      existing.numPeople = tPeople;
    } else {
      teams.push({ teamName: tName, date: dateSelected, numPeople: tPeople });
    }
  }

  async function doProceedToGrading(teamObj) {
    // Load the date's trivia data if not already loaded
    await loadTriviaData(teamObj.date);
    showGradingUI(teamObj);
  }

  /***************************************************
   * 6) Load Trivia Data for a date
   ***************************************************/
  async function loadTriviaData(date) {
    if (triviaData[date]) return; // already loaded
    const snap = await get(child(ref(db), `trivia/${date}`));
    if (snap.exists()) {
      triviaData[date] = snap.val();
    } else {
      triviaData[date] = {};
    }
  }

  /***************************************************
   * 7) Show Grading UI
   ***************************************************/
  function showGradingUI(teamObj) {
    currentTeam = { ...teamObj };
    gradingDateSpan.textContent = currentTeam.date;
    gradingTeamNameInput.value = currentTeam.teamName;
    gradingNumPeopleInput.value = currentTeam.numPeople.toString();

    // Hide setup, show grading
    teamSetupSection.classList.add("hidden");
    gradingSection.classList.remove("hidden");
    rubricSection.classList.add("hidden");

    // Load existing scores for this team
    loadExistingScores(currentTeam.date, currentTeam.teamName)
      .then(scores => {
        existingScores = scores;
        renderQuestions(currentTeam.date);
      })
      .catch(err => {
        console.error(err);
        existingScores = {};
        renderQuestions(currentTeam.date);
      });
  }

  /***************************************************
   * 8) Load existing scores for a team
   * /scores/{date}/{teamName}/scores/{roundNum}/{roundType}/{qid}
   ***************************************************/
  async function loadExistingScores(date, teamName) {
    const snap = await get(child(ref(db), `scores/${date}/${teamName}/scores`));
    if (!snap.exists()) return {};
    // This object is nested by roundNum -> roundType -> qid = score
    const data = snap.val();
    // Flatten for easy lookup: existingScores[qid] = score
    const flatScores = {};
    Object.keys(data).forEach(rNum => {
      Object.keys(data[rNum]).forEach(rType => {
        Object.keys(data[rNum][rType]).forEach(qid => {
          flatScores[`${rNum}-${rType}-${qid}`] = data[rNum][rType][qid];
        });
      });
    });
    return flatScores;
  }

  /***************************************************
   * 9) Render Questions in sorted order
   ***************************************************/
  function renderQuestions(date) {
    questionsContainer.innerHTML = "";
    const dataForDate = triviaData[date] || {};

    // We want to sort round numbers ascending
    const roundNums = Object.keys(dataForDate)
      .map(r => Number(r))
      .sort((a,b) => a - b);

    // We'll order round types in a specific order
    const roundOrder = ["Written", "Puzzle", "Visual", "Fill-In", "Music"];

    roundNums.forEach(rNum => {
      const roundBlock = document.createElement("div");
      roundBlock.style.border = "1px solid #ccc";
      roundBlock.style.margin = "10px 0";
      roundBlock.style.padding = "10px";

      const roundHeader = document.createElement("h3");
      roundHeader.textContent = `Round ${rNum}`;
      roundBlock.appendChild(roundHeader);

      const rTypes = dataForDate[rNum];
      if (!rTypes) return;

      roundOrder.forEach(rt => {
        if (rTypes[rt]) {
          const subHeader = document.createElement("h4");
          subHeader.textContent = rt;
          roundBlock.appendChild(subHeader);

          const table = document.createElement("table");
          table.innerHTML = `
            <thead>
              <tr>
                <th>Question</th>
                <th>Answer</th>
                <th>Total Pts</th>
                <th>Score</th>
              </tr>
            </thead>
          `;
          const tbody = document.createElement("tbody");

          const qIds = Object.keys(rTypes[rt]);
          qIds.forEach(qid => {
            const qData = rTypes[rt][qid];
            const row = document.createElement("tr");

            // question
            const tdQ = document.createElement("td");
            tdQ.textContent = qData.question || "";
            row.appendChild(tdQ);

            // answer
            const tdA = document.createElement("td");
            tdA.textContent = qData.answer || "";
            row.appendChild(tdA);

            // total points
            const tdT = document.createElement("td");
            tdT.textContent = qData.total_possible_points || 0;
            row.appendChild(tdT);

            // user-entered score
            const tdS = document.createElement("td");
            const inp = document.createElement("input");
            inp.type = "number";
            inp.min = 0;
            inp.max = qData.total_possible_points || 99;
            inp.value = 0;

            // If we have an existing score, fill it in
            const scoreKey = `${rNum}-${rt}-${qid}`;
            if (existingScores[scoreKey] !== undefined) {
              inp.value = existingScores[scoreKey];
            }

            // We'll store data attributes for saving
            inp.setAttribute("data-roundnum", rNum);
            inp.setAttribute("data-roundtype", rt);
            inp.setAttribute("data-qid", qid);

            tdS.appendChild(inp);
            row.appendChild(tdS);

            tbody.appendChild(row);
          });

          table.appendChild(tbody);
          roundBlock.appendChild(table);
        }
      });

      questionsContainer.appendChild(roundBlock);
    });
  }

  /***************************************************
   * 10) Save Scores (and rename team if changed)
   ***************************************************/
  saveScoresBtn.addEventListener("click", async () => {
    if (!currentTeam) return;
    const oldTeamName = currentTeam.teamName;
    const oldDate = currentTeam.date;

    // Check if user changed the team name or # people
    const newTeamName = gradingTeamNameInput.value.trim();
    const newNumPeople = Number(gradingNumPeopleInput.value.trim() || "0");
    if (!newTeamName) {
      alert("Team name cannot be empty!");
      return;
    }
    if (newNumPeople < 1) {
      alert("Number of people must be at least 1!");
      return;
    }

    // Gather all score inputs
    const inputs = questionsContainer.querySelectorAll("input[type='number']");
    let updates = {};

    inputs.forEach(inp => {
      const score = Number(inp.value || 0);
      const rNum = inp.getAttribute("data-roundnum");
      const rType = inp.getAttribute("data-roundtype");
      const qid = inp.getAttribute("data-qid");

      // We'll store at: /scores/date/newTeamName/scores/rNum/rType/qid
      const dbPath = `scores/${oldDate}/${newTeamName}/scores/${rNum}/${rType}/${qid}`;
      updates[dbPath] = score;
    });

    // number_of_people
    const dbPeoplePath = `scores/${oldDate}/${newTeamName}/number_of_people`;
    updates[dbPeoplePath] = newNumPeople;

    try {
      // 1) If the user changed the team name, we rename the node
      //    => copy existing data to new node, remove old node
      if (newTeamName !== oldTeamName) {
        // Copy existing data to new node
        // We'll do that by applying "updates" first, then removing old node
        // This preserves the old team's scores in the new name
        await update(ref(db), updates);
        // Remove old node
        await remove(child(ref(db), `scores/${oldDate}/${oldTeamName}`));
        alert("Team name updated & scores saved!");
      } else {
        // If name didn't change, we just do "update"
        await update(ref(db), updates);
        alert("Scores saved successfully!");
      }

      // Update local 'currentTeam'
      currentTeam.teamName = newTeamName;
      currentTeam.numPeople = newNumPeople;
    } catch (err) {
      console.error(err);
      alert("Error saving scores: " + err);
    }
  });

  /***************************************************
   * 11) Switch/Add Team
   ***************************************************/
  pickAnotherTeamBtn.addEventListener("click", () => {
    // Go back to the Team Setup
    teamSetupSection.classList.remove("hidden");
    gradingSection.classList.add("hidden");
    rubricSection.classList.add("hidden");
  });

  /***************************************************
   * 12) Rubric
   * Show all teams for the selected date, total score
   * Add "Edit" button next to each team
   ***************************************************/
  showRubricBtn.addEventListener("click", showRubric);
  closeRubricBtn.addEventListener("click", () => {
    rubricSection.classList.add("hidden");
  });

  async function showRubric() {
    if (!currentTeam) return;
    const date = currentTeam.date;
    rubricSection.classList.remove("hidden");
    rubricContent.innerHTML = "Loading...";

    const snap = await get(child(ref(db), `scores/${date}`));
    if (!snap.exists()) {
      rubricContent.innerHTML = "<p>No scores found for this date</p>";
      return;
    }

    const dateScores = snap.val();
    // dateScores = {
    //   [teamName]: {
    //     number_of_people: x,
    //     scores: {
    //       [roundNum]: {
    //         [roundType]: {
    //           [qid]: number
    //         }
    //       }
    //     }
    //   }
    // }

    let html = `
      <table>
        <thead>
          <tr>
            <th>Team</th>
            <th># People</th>
            <th>Total Score</th>
            <th>Edit</th>
          </tr>
        </thead>
        <tbody>
    `;

    const teamNames = Object.keys(dateScores).sort();
    teamNames.forEach(tName => {
      const tObj = dateScores[tName];
      const numPeople = tObj.number_of_people || 0;
      let totalScore = 0;

      if (tObj.scores) {
        Object.keys(tObj.scores).forEach(rN => {
          Object.keys(tObj.scores[rN]).forEach(rType => {
            Object.keys(tObj.scores[rN][rType]).forEach(qid => {
              totalScore += Number(tObj.scores[rN][rType][qid] || 0);
            });
          });
        });
      }

      html += `
        <tr>
          <td>${tName}</td>
          <td>${numPeople}</td>
          <td>${totalScore}</td>
          <td>
            <button 
              class="editTeamBtn" 
              data-teamname="${tName}"
            >
              Edit
            </button>
          </td>
        </tr>
      `;
    });

    html += `</tbody></table>`;
    rubricContent.innerHTML = html;

    // Attach click listeners for Edit
    const editBtns = rubricContent.querySelectorAll(".editTeamBtn");
    editBtns.forEach(btn => {
      btn.addEventListener("click", async (e) => {
        const tName = e.target.getAttribute("data-teamname");
        // We need to find number_of_people from dateScores
        const tObj = dateScores[tName];
        const tPeople = tObj.number_of_people || 1;
        // Switch to grading UI for that team
        const teamObj = { teamName: tName, date, numPeople: tPeople };
        
        // Hide Rubric, show Grading UI
        rubricSection.classList.add("hidden");
        await doProceedToGrading(teamObj);
      });
    });
  }
</script>
</body>
</html>
