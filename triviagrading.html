<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Trivia Grading App</title>
  <!-- Minimal styling for clarity -->
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .screen {
      display: none; /* All screens hidden by default */
      margin-bottom: 30px;
    }
    .screen.active {
      display: block; /* The currently active screen */
    }
    .section {
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 10px;
    }
    h2, h3 {
      margin: 0.2em 0;
    }
    select, input[type="text"], input[type="number"] {
      margin-right: 8px;
    }
    table {
      border-collapse: collapse;
      margin-top: 10px;
      width: 100%;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 6px;
      text-align: center;
      vertical-align: middle;
    }
    .button-row {
      margin-top: 16px;
    }
    .button-row button {
      margin-right: 8px;
    }
    .slider-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .round-col {
      width: 70px;
    }
  </style>
</head>
<body>

<h1>Trivia Grading App</h1>

<!-- SCREEN A: Date Selection -->
<div id="screenDateSelect" class="screen active">
  <h2>1. Select Date</h2>
  <p>Select a trivia date from the database:</p>
  <select id="dateSelect"></select>
  <div class="button-row">
    <button id="btnCheckGrading">Continue</button>
  </div>
</div>

<!-- SCREEN B: Team Setup -->
<div id="screenTeamSetup" class="screen">
  <h2>2. Enter Teams</h2>
  <p>It seems there's no existing grading data for this date. Please add your teams:</p>
  
  <div>
    <input type="text" id="teamNameInput" placeholder="Team Name" />
    <input type="number" id="teamSizeInput" placeholder="Team Size" min="1" />
    <button id="btnAddTeam">Add Team</button>
  </div>

  <div class="section">
    <h3>Teams Added (local)</h3>
    <ul id="teamList"></ul>
  </div>

  <div class="button-row">
    <button id="btnProceedToRounds">Proceed to Round Selection</button>
  </div>
</div>

<!-- SCREEN C: Rubric (Team & Round Overview) -->
<div id="screenRubric" class="screen">
  <h2>Rubric / Summary</h2>
  <p>Teams for this date, showing round scores & bonuses. Sorted highest final score first.</p>
  <button id="btnAddMoreTeams">Add / Edit Teams</button>
  <button id="btnSelectRoundFromRubric">Select a Round to Grade</button>
  <div id="rubricContent" class="section">
    <!-- Dynamic table with columns for each round + bonuses + penalty + total -->
  </div>
</div>

<!-- SCREEN D: Select Round -->
<div id="screenRoundSelect" class="screen">
  <h2>3. Select Round to Grade</h2>
  <p>Choose from the rounds found under <em>trivia/[date]</em> in the DB.</p>
  <select id="roundSelect"></select>
  <div class="button-row">
    <button id="btnOpenGrading">Grade This Round</button>
    <button id="btnBackToRubric">Back to Rubric</button>
  </div>
</div>

<!-- SCREEN E: Grading for One Round -->
<div id="screenGrading" class="screen">
  <h2>4. Grade Round</h2>
  <div class="section">
    <label for="teamSelect">Team:</label>
    <select id="teamSelect"></select>
  </div>

  <div class="section">
    <table id="questionTable">
      <thead>
        <tr>
          <th>Question</th>
          <th>Answer</th>
          <th>Points</th>
          <th>Score (%)</th>
          <th>Calculated</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows appended by JS -->
      </tbody>
    </table>
  </div>
  
  <div class="button-row">
    <button id="btnSaveScores">Save Scores</button>
    <button id="btnSwitchTeam">Switch Team</button>
    <button id="btnDoneRound">Done / Back to Rubric</button>
  </div>
</div>


<!-- Firebase + JS Logic -->
<script type="module">
  /***************************************************
   * 1) Import Firebase + Initialize
   ***************************************************/
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
  import { 
    getDatabase, ref, child, get, set, update 
  } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";

  // TODO: Replace with your Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyBy8ExrgvBDto-BcNhlvrcC6ZB9G7HNaWE",
    authDomain: "eviltriviagrading.firebaseapp.com",
    databaseURL: "https://eviltriviagrading-default-rtdb.firebaseio.com",
    projectId: "eviltriviagrading",
    storageBucket: "eviltriviagrading.firebasestorage.app",
    messagingSenderId: "738486013114",
    appId: "1:738486013114:web:fe0f480cc3f66f42d6c683",
    measurementId: "G-R84N89NTJZ"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  /***************************************************
   * 2) DOM Elements
   ***************************************************/
  const screenDateSelect    = document.getElementById('screenDateSelect');
  const screenTeamSetup     = document.getElementById('screenTeamSetup');
  const screenRubric        = document.getElementById('screenRubric');
  const screenRoundSelect   = document.getElementById('screenRoundSelect');
  const screenGrading       = document.getElementById('screenGrading');

  const dateSelect          = document.getElementById('dateSelect');
  const btnCheckGrading     = document.getElementById('btnCheckGrading');

  const teamNameInput       = document.getElementById('teamNameInput');
  const teamSizeInput       = document.getElementById('teamSizeInput');
  const btnAddTeam          = document.getElementById('btnAddTeam');
  const teamList            = document.getElementById('teamList');
  const btnProceedToRounds  = document.getElementById('btnProceedToRounds');

  const rubricContent       = document.getElementById('rubricContent');
  const btnAddMoreTeams     = document.getElementById('btnAddMoreTeams');
  const btnSelectRoundFromRubric = document.getElementById('btnSelectRoundFromRubric');

  const roundSelect         = document.getElementById('roundSelect');
  const btnOpenGrading      = document.getElementById('btnOpenGrading');
  const btnBackToRubric     = document.getElementById('btnBackToRubric');

  const teamSelect          = document.getElementById('teamSelect');
  const questionTable       = document.getElementById('questionTable').querySelector('tbody');
  const btnSaveScores       = document.getElementById('btnSaveScores');
  const btnSwitchTeam       = document.getElementById('btnSwitchTeam');
  const btnDoneRound        = document.getElementById('btnDoneRound');

  /***************************************************
   * 3) App State Variables
   ***************************************************/
  let currentDate = null;

  // We'll store teams locally as an array of objects:
  // { teamId: string, teamName: string, teamSize: number }
  let allTeams = [];
  
  let currentRound = null; // e.g. "1", "2"
  let currentRoundData = {}; // Flattened question data for the chosen round
  let cachedTriviaData = {}; // { date: { [roundNum]: { Written: {...}, Puzzle: {...}... } } }

  // We'll keep an array for the round order:
  const roundTypeOrder = ['Written','Puzzle','Visual','Fill-In','Music'];

  // For the grading screen slider:
  // We'll map the slider 0..6 to these percentages
  const PERCENTAGE_MAP = [0.0, 0.25, 0.33, 0.50, 0.66, 0.75, 1.0];
  const DEFAULT_SLIDER_VALUE = 6; // i.e. 100%

  /***************************************************
   * 4) Screen Navigation Helpers
   ***************************************************/
  function showScreen(screenElem) {
    [screenDateSelect, screenTeamSetup, screenRubric, screenRoundSelect, screenGrading]
      .forEach(s => s.classList.remove('active'));
    screenElem.classList.add('active');
  }

  /***************************************************
   * 5) On Page Load: Populate the date dropdown
   ***************************************************/
  window.addEventListener('DOMContentLoaded', async () => {
    await loadDates();
  });

  async function loadDates() {
    dateSelect.innerHTML = "";
    const snapshot = await get(child(ref(db), "trivia"));
    if (snapshot.exists()) {
      const data = snapshot.val();
      const dateKeys = Object.keys(data).sort().reverse();
      dateKeys.forEach(d => {
        const opt = document.createElement("option");
        opt.value = d;
        opt.textContent = d;
        dateSelect.appendChild(opt);
      });
    } else {
      // No trivia data
      const opt = document.createElement("option");
      opt.textContent = "No Trivia Data Found";
      opt.disabled = true;
      dateSelect.appendChild(opt);
    }
  }

  /***************************************************
   * 6) Date Selected -> Check if there's existing grading
   ***************************************************/
  btnCheckGrading.addEventListener('click', async () => {
    currentDate = dateSelect.value;
    if (!currentDate) {
      alert("Please select a date.");
      return;
    }
    // Check if scores/date exist
    const snap = await get(child(ref(db), `scores/${currentDate}`));
    if (snap.exists()) {
      // We have existing grading => Go to Rubric
      showRubric();
    } else {
      // No existing grading => go to Team Setup
      allTeams = [];
      teamList.innerHTML = "";
      showScreen(screenTeamSetup);
    }
  });

  /***************************************************
   * 7) Team Setup Screen
   ***************************************************/

  // Generate a random unique ID (simple approach)
  // Check if "scores/[currentDate]/TEAM-xxxxx" exists; if yes, regenerate.
  async function generateTeamId() {
    // We'll do a loop up to 10 tries
    for (let i = 0; i < 10; i++) {
      const r = Math.floor(Math.random() * 1000000);
      const tid = `TEAM-${r}`;
      const snap = await get(child(ref(db), `scores/${currentDate}/${tid}`));
      if (!snap.exists()) {
        return tid; // good to use
      }
    }
    // fallback if extremely unlucky
    return `TEAM-${Date.now()}`;
  }

  btnAddTeam.addEventListener('click', async () => {
    const name = teamNameInput.value.trim();
    const size = Number(teamSizeInput.value.trim() || 0);
    if (!name) {
      alert("Enter a team name.");
      return;
    }
    if (size < 1) {
      alert("Enter a valid team size.");
      return;
    }

    // Check if we already have a local team with that name
    let found = allTeams.find(t => t.teamName === name);
    if (found) {
      // just update the size in local
      found.teamSize = size;
    } else {
      // Need a new teamId
      const newId = await generateTeamId();
      // Create local object
      found = { teamId: newId, teamName: name, teamSize: size };
      allTeams.push(found);
    }
    refreshTeamList();
    teamNameInput.value = "";
    teamSizeInput.value = "";
  });

  function refreshTeamList() {
    teamList.innerHTML = "";
    allTeams.forEach(t => {
      const li = document.createElement('li');
      li.textContent = `${t.teamName} (id: ${t.teamId}, size: ${t.teamSize})`;
      teamList.appendChild(li);
    });
  }

  btnProceedToRounds.addEventListener('click', async () => {
    if (!allTeams.length) {
      alert("Please add at least one team first.");
      return;
    }
    // Save these teams into the DB under scores/[date]/teamId
    for (let t of allTeams) {
      const path = `scores/${currentDate}/${t.teamId}`;
      await update(ref(db, path), {
        team_name: t.teamName,
        number_of_people: t.teamSize
      });
    }
    // Now go to Round Select
    await loadRoundOptions();
    showScreen(screenRoundSelect);
  });

  /***************************************************
   * 8) Rubric Screen
   ***************************************************/
  btnAddMoreTeams.addEventListener('click', async () => {
    // Re-fetch teams from DB, show in Team Setup
    allTeams = await fetchTeamsForDate(currentDate);
    refreshTeamList();
    showScreen(screenTeamSetup);
  });

  btnSelectRoundFromRubric.addEventListener('click', async () => {
    await loadRoundOptions();
    showScreen(screenRoundSelect);
  });

  async function showRubric() {
    showScreen(screenRubric);
    rubricContent.innerHTML = "Loading...";

    // 1) Load all round numbers from /trivia/[currentDate] for building columns
    if (!cachedTriviaData[currentDate]) {
      const snap = await get(child(ref(db), `trivia/${currentDate}`));
      cachedTriviaData[currentDate] = snap.exists() ? snap.val() : {};
    }
    const allRounds = Object.keys(cachedTriviaData[currentDate])
      .sort((a,b)=> Number(a)-Number(b));

    // 2) Load team data from /scores/[date]
    const snap = await get(child(ref(db), `scores/${currentDate}`));
    if (!snap.exists()) {
      rubricContent.innerHTML = "<p>No scores found for this date.</p>";
      return;
    }
    const dateScores = snap.val(); 
    // dateScores => { [teamId]: { team_name, number_of_people, bonus, instagram_challenge, final_challenge, scores: {...} } }

    // We'll build an array of row data, then sort by final desc
    let rowsData = [];

    Object.keys(dateScores).forEach(teamId => {
      const tObj = dateScores[teamId];
      const tName = tObj.team_name || "Unknown";
      const tSize = Number(tObj.number_of_people || 0);
      const bonus = Number(tObj.bonus || 0);
      const insta = Number(tObj.instagram_challenge || 0);
      const finalCh = Number(tObj.final_challenge || 0);
      let sumOfRounds = 0;
      let roundScoresMap = {}; // roundNum -> total

      // If there's round scores
      if (tObj.scores) {
        Object.keys(tObj.scores).forEach(rNum => {
          let roundTotal = 0;
          const qScoreObj = tObj.scores[rNum];
          if (qScoreObj) {
            Object.keys(qScoreObj).forEach(k => {
              roundTotal += Number(qScoreObj[k] || 0);
            });
          }
          roundScoresMap[rNum] = roundTotal;
          sumOfRounds += roundTotal;
        });
      }
      // Penalty
      const penalty = getTeamSizePenalty(tSize);
      const finalScore = sumOfRounds + bonus + insta + finalCh + penalty;
      
      rowsData.push({
        teamId, tName, tSize,
        bonus, insta, finalCh,
        sumOfRounds,
        roundScoresMap,
        penalty,
        finalScore
      });
    });

    // Sort rows descending by finalScore
    rowsData.sort((a,b) => b.finalScore - a.finalScore);

    // 3) Build table header
    let html = `<table>
      <thead>
        <tr>
          <th>Team</th>
          <th>Size</th>`;
    allRounds.forEach(r => {
      html += `<th class="round-col">R${r}</th>`;
    });
    html += `
          <th class="round-col">Bonus</th>
          <th class="round-col">Instagram</th>
          <th class="round-col">Final Ch.</th>
          <th class="round-col">Penalty</th>
          <th class="round-col">Final</th>
        </tr>
      </thead>
      <tbody>
    `;

    // 4) Build each row
    rowsData.forEach(rowObj => {
      const {teamId, tName, tSize, bonus, insta, finalCh, roundScoresMap, penalty, finalScore} = rowObj;

      html += `<tr data-teamid="${teamId}">
        <td>${tName}</td>
        <td>${tSize}</td>
      `;
      // Each round's total
      allRounds.forEach(r => {
        const val = roundScoresMap[r] || 0;
        html += `<td>${roundToTenth(val)}</td>`;
      });

      // Bonus fields (editable)
      html += `
        <td><input type="number" class="bonusInput" value="${bonus}" style="width:60px"></td>
        <td><input type="number" class="instaInput" value="${insta}" style="width:60px"></td>
        <td><input type="number" class="finalChInput" value="${finalCh}" style="width:60px"></td>
        <td>${roundToTenth(penalty)}</td>
        <td>${roundToTenth(finalScore)}</td>
      </tr>`;
    });

    html += `</tbody></table>`;
    rubricContent.innerHTML = html;

    // Attach listeners
    const rows = rubricContent.querySelectorAll('tr[data-teamid]');
    rows.forEach(row => {
      const teamId = row.getAttribute('data-teamid');
      const bonusInput = row.querySelector('.bonusInput');
      const instaInput = row.querySelector('.instaInput');
      const finalChInput = row.querySelector('.finalChInput');

      function handleChange() {
        const b = Number(bonusInput.value || 0);
        const i = Number(instaInput.value || 0);
        const f = Number(finalChInput.value || 0);
        // update in DB
        const path = `scores/${currentDate}/${teamId}`;
        update(ref(db, path), {
          bonus: b,
          instagram_challenge: i,
          final_challenge: f
        }).then(() => {
          // re-calc row
          recalcRow(row);
        }).catch(err => {
          console.error("Error saving bonus:", err);
        });
      }

      bonusInput.addEventListener('change', handleChange);
      instaInput.addEventListener('change', handleChange);
      finalChInput.addEventListener('change', handleChange);
    });
  }

  // Recompute final score for a single row (no resort)
  function recalcRow(row) {
    // We do not re-sort the entire table on each edit.
    // Just recalc the final in place.
    const tSize = Number(row.children[1].textContent || 0);
    // find how many round columns
    let colIndex = 2;
    let sumOfRounds = 0;
    while (true) {
      const cell = row.children[colIndex];
      if (!cell) break;
      // If there's an input, we've reached bonus col
      if (cell.querySelector('input')) {
        break;
      }
      const val = parseFloat(cell.textContent || "0");
      sumOfRounds += val;
      colIndex++;
    }
    // bonus, insta, finalCh inputs
    const bonus = Number(row.querySelector('.bonusInput').value || 0);
    const insta = Number(row.querySelector('.instaInput').value || 0);
    const finalCh = Number(row.querySelector('.finalChInput').value || 0);
    const penaltyCell = row.children[row.children.length - 2];
    const finalCell   = row.lastElementChild;
    
    const penalty = getTeamSizePenalty(tSize);
    penaltyCell.textContent = roundToTenth(penalty);
    const finalScore = sumOfRounds + bonus + insta + finalCh + penalty;
    finalCell.textContent = roundToTenth(finalScore);
  }

  function roundToTenth(num) {
    // Return as a string with 1 decimal place
    return (Math.round(num * 10) / 10).toFixed(1);
  }

  // Team size penalty: 6 or under => 0, 7 => -4, 8 => -6, 9 => -8, etc.
  function getTeamSizePenalty(size) {
    if (size <= 6) return 0;
    const diff = size - 6;
    // 7 => -4, 8 => -6, 9 => -8
    return -2 * diff - 2;
  }

  /***************************************************
   * 9) Round Selection Screen
   ***************************************************/
  btnOpenGrading.addEventListener('click', () => {
    currentRound = roundSelect.value; 
    if (!currentRound) {
      alert("No round selected.");
      return;
    }
    // Go to grading screen for that round
    showGradingScreen();
  });

  btnBackToRubric.addEventListener('click', () => {
    showRubric();
  });

  async function loadRoundOptions() {
    if (!cachedTriviaData[currentDate]) {
      const snap = await get(child(ref(db), `trivia/${currentDate}`));
      cachedTriviaData[currentDate] = snap.exists() ? snap.val() : {};
    }
    const data = cachedTriviaData[currentDate];
    const roundKeys = Object.keys(data).sort((a,b) => Number(a) - Number(b));
    roundSelect.innerHTML = "";
    roundKeys.forEach(rNum => {
      const opt = document.createElement("option");
      opt.value = rNum;
      opt.textContent = `Round ${rNum}`;
      roundSelect.appendChild(opt);
    });
    if (!roundKeys.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "No Rounds Found";
      roundSelect.appendChild(opt);
    }
  }

  /***************************************************
   * 10) Grading Screen
   ***************************************************/
  async function showGradingScreen() {
    showScreen(screenGrading);
    // 1) Load teams from DB (to get up-to-date list)
    allTeams = await fetchTeamsForDate(currentDate);
    // 2) Populate the <select>
    teamSelect.innerHTML = "";
    allTeams.forEach(t => {
      const opt = document.createElement("option");
      opt.value = t.teamId; // store the ID
      opt.textContent = t.teamName;
      teamSelect.appendChild(opt);
    });
    // If at least one team
    if (allTeams.length > 0) {
      // 3) Load question data
      loadQuestionDataForRound(currentRound);
      // 4) By default, show the first team's data
      loadTeamScoresIntoTable(teamSelect.value);
    } else {
      questionTable.innerHTML = "<tr><td colspan='5'>No teams found.</td></tr>";
    }
  }

  teamSelect.addEventListener('change', () => {
    loadTeamScoresIntoTable(teamSelect.value);
  });

  function loadQuestionDataForRound(rNum) {
    const dataForDate = cachedTriviaData[currentDate] || {};
    const roundObj = dataForDate[rNum] || {};
    // Flatten them in fixed order
    currentRoundData = {};
    roundTypeOrder.forEach(rType => {
      if (roundObj[rType]) {
        const questionsOfType = roundObj[rType];
        Object.keys(questionsOfType).forEach(qId => {
          const q = questionsOfType[qId];
          const uniqueQID = `${rType}-${qId}`;
          currentRoundData[uniqueQID] = {
            roundType: rType,
            question: q.question || "",
            answer: q.answer || "",
            totalPoints: Number(q.total_possible_points) || 0
          };
        });
      }
    });
  }

  async function loadTeamScoresIntoTable(teamId) {
    if (!teamId) return;
    // load this team's existing scores for currentRound
    const path = `scores/${currentDate}/${teamId}/scores/${currentRound}`;
    const snap = await get(child(ref(db), path));
    let teamRoundScores = snap.exists() ? snap.val() : {};

    questionTable.innerHTML = "";
    const uniqueQIDs = Object.keys(currentRoundData);

    uniqueQIDs.forEach((uqid, i) => {
      const q = currentRoundData[uqid];
      const tr = document.createElement('tr');
      // question
      const tdQ = document.createElement('td');
      tdQ.textContent = q.question;
      tr.appendChild(tdQ);
      // answer
      const tdA = document.createElement('td');
      tdA.textContent = q.answer;
      tr.appendChild(tdA);
      // total points
      const tdPts = document.createElement('td');
      tdPts.textContent = q.totalPoints;
      tr.appendChild(tdPts);
      // slider cell
      const tdSlider = document.createElement('td');
      tdSlider.classList.add('slider-cell');
      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = "0";
      slider.max = (PERCENTAGE_MAP.length - 1).toString();
      slider.step = "1";
      slider.value = DEFAULT_SLIDER_VALUE; // default 100%
      const pctLabel = document.createElement('span');

      // existing partial
      const existingScore = Number(teamRoundScores[uqid] || 0);
      const ratio = q.totalPoints ? existingScore / q.totalPoints : 0;
      let bestIdx = 0;
      let bestDiff = 999;
      PERCENTAGE_MAP.forEach((pctVal, idx) => {
        const diff = Math.abs(pctVal - ratio);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestIdx = idx;
        }
      });
      slider.value = bestIdx;

      const tdCalc = document.createElement('td');
      tdCalc.classList.add('calc-cell');

      const recalcScore = () => {
        const idx = Number(slider.value);
        const pct = PERCENTAGE_MAP[idx];
        pctLabel.textContent = (pct*100).toFixed(0)+"%";
        const s = Math.round(q.totalPoints * pct * 100)/100;
        tdCalc.textContent = s.toString();
      };
      slider.addEventListener('input', recalcScore);

      // Init
      recalcScore();

      tdSlider.appendChild(slider);
      tdSlider.appendChild(pctLabel);
      tr.appendChild(tdSlider);

      // final numeric
      tr.appendChild(tdCalc);

      questionTable.appendChild(tr);
    });
  }

  btnSaveScores.addEventListener('click', async () => {
    if (!teamSelect.value) {
      alert("No team selected!");
      return;
    }
    const teamId = teamSelect.value;
    const rows = questionTable.querySelectorAll('tr');
    const uniqueQIDs = Object.keys(currentRoundData);
    let updates = {};

    rows.forEach((tr, i) => {
      const slider = tr.querySelector('input[type="range"]');
      if (!slider) return;
      const idx = Number(slider.value);
      const pct = PERCENTAGE_MAP[idx];
      const totalPoints = Number(tr.children[2].textContent || 0);
      const score = Math.round(totalPoints * pct * 100)/100;
      const uqid = uniqueQIDs[i]; // assume same order
      updates[uqid] = score;
    });

    const path = `scores/${currentDate}/${teamId}/scores/${currentRound}`;
    try {
      await set(ref(db, path), updates);
      alert("Scores saved!");
    } catch (err) {
      console.error(err);
      alert("Error saving scores.");
    }
  });

  btnSwitchTeam.addEventListener('click', () => {
    const idx = teamSelect.selectedIndex;
    if (teamSelect.options.length > 1) {
      const newIdx = (idx + 1) % teamSelect.options.length;
      teamSelect.selectedIndex = newIdx;
      loadTeamScoresIntoTable(teamSelect.value);
    } else {
      alert("Only one team in the list.");
    }
  });

  btnDoneRound.addEventListener('click', () => {
    showRubric();
  });

  /***************************************************
   * 11) Utility: Fetch teams for a date
   * We'll read all keys (teamIds), gather:
   *  - teamId
   *  - team_name
   *  - number_of_people
   ***************************************************/
  async function fetchTeamsForDate(date) {
    const snap = await get(child(ref(db), `scores/${date}`));
    let result = [];
    if (snap.exists()) {
      const data = snap.val(); 
      // data => { teamId: { team_name, number_of_people, ...}, ... }
      Object.keys(data).forEach(tid => {
        const tObj = data[tid];
        result.push({
          teamId: tid,
          teamName: tObj.team_name || "Unknown",
          teamSize: tObj.number_of_people || 0
        });
      });
    }
    return result;
  }

  /***************************************************
   * 12) Team Size Penalty Function
   ***************************************************/
  function getTeamSizePenalty(size) {
    if (size <= 6) return 0;
    const diff = size - 6; // how many over 6
    // 7 => -4, 8 => -6, 9 => -8
    return -2 * diff - 2;
  }

</script>

</body>
</html>
