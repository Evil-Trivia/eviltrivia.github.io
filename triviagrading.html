<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Trivia Grading App</title>
  <!-- Minimal styling for clarity -->
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .screen {
      display: none; /* All screens hidden by default */
      margin-bottom: 30px;
    }
    .screen.active {
      display: block; /* The currently active screen */
    }
    .section {
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 10px;
    }
    h2, h3 {
      margin: 0.2em 0;
    }
    select, input[type="text"], input[type="number"] {
      margin-right: 8px;
    }
    table {
      border-collapse: collapse;
      margin-top: 10px;
      width: 100%;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 6px;
      text-align: center;
      vertical-align: middle;
    }
    .button-row {
      margin-top: 16px;
    }
    .button-row button {
      margin-right: 8px;
    }
    .slider-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    /* For the "round" columns in rubric, we might do a narrower width: */
    .round-col {
      width: 70px;
    }
  </style>
</head>
<body>

<h1>Trivia Grading App</h1>

<!-- SCREEN A: Date Selection -->
<div id="screenDateSelect" class="screen active">
  <h2>1. Select Date</h2>
  <p>Select a trivia date from the database:</p>
  <select id="dateSelect"></select>
  <div class="button-row">
    <button id="btnCheckGrading">Continue</button>
  </div>
</div>

<!-- SCREEN B: Team Setup -->
<div id="screenTeamSetup" class="screen">
  <h2>2. Enter Teams</h2>
  <p>It seems there's no existing grading data for this date. Please add your teams:</p>
  
  <div>
    <input type="text" id="teamNameInput" placeholder="Team Name" />
    <input type="number" id="teamSizeInput" placeholder="Team Size" min="1" />
    <button id="btnAddTeam">Add Team</button>
  </div>

  <div class="section">
    <h3>Teams Added</h3>
    <ul id="teamList"></ul>
  </div>

  <div class="button-row">
    <button id="btnProceedToRounds">Proceed to Round Selection</button>
  </div>
</div>

<!-- SCREEN C: Rubric (Team & Round Overview) -->
<div id="screenRubric" class="screen">
  <h2>Rubric / Summary</h2>
  <p>Below are all teams found for this date, their scores per round, bonuses, penalty, and final score.</p>
  <button id="btnAddMoreTeams">Add / Edit Teams</button>
  <button id="btnSelectRoundFromRubric">Select a Round to Grade</button>
  <div id="rubricContent" class="section">
    <!-- Dynamic table with columns for each round + bonuses + penalty + total -->
  </div>
</div>

<!-- SCREEN D: Select Round -->
<div id="screenRoundSelect" class="screen">
  <h2>3. Select Round to Grade</h2>
  <p>Choose from the rounds found under <em>trivia/[date]</em> in the DB.</p>
  <select id="roundSelect"></select>
  <div class="button-row">
    <button id="btnOpenGrading">Grade This Round</button>
    <button id="btnBackToRubric">Back to Rubric</button>
  </div>
</div>

<!-- SCREEN E: Grading for One Round -->
<div id="screenGrading" class="screen">
  <h2>4. Grade Round</h2>
  <div class="section">
    <label for="teamSelect">Team:</label>
    <select id="teamSelect"></select>
  </div>

  <div class="section">
    <table id="questionTable">
      <thead>
        <tr>
          <th>Question</th>
          <th>Answer</th>
          <th>Points</th>
          <th>Score (%)</th>
          <th>Calculated</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows appended by JS -->
      </tbody>
    </table>
  </div>
  
  <div class="button-row">
    <button id="btnSaveScores">Save Scores</button>
    <button id="btnSwitchTeam">Switch Team</button>
    <button id="btnDoneRound">Done / Back to Rubric</button>
  </div>
</div>


<!-- Firebase + JS Logic -->
<script type="module">
  /***************************************************
   * 1) Import Firebase + Initialize
   ***************************************************/
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
  import { 
    getDatabase, ref, child, get, set, update, remove 
  } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";

  // TODO: Replace with your Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyBy8ExrgvBDto-BcNhlvrcC6ZB9G7HNaWE",
    authDomain: "eviltriviagrading.firebaseapp.com",
    databaseURL: "https://eviltriviagrading-default-rtdb.firebaseio.com",
    projectId: "eviltriviagrading",
    storageBucket: "eviltriviagrading.firebasestorage.app",
    messagingSenderId: "738486013114",
    appId: "1:738486013114:web:fe0f480cc3f66f42d6c683",
    measurementId: "G-R84N89NTJZ"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  /***************************************************
   * 2) DOM Elements
   ***************************************************/
  const screenDateSelect    = document.getElementById('screenDateSelect');
  const screenTeamSetup     = document.getElementById('screenTeamSetup');
  const screenRubric        = document.getElementById('screenRubric');
  const screenRoundSelect   = document.getElementById('screenRoundSelect');
  const screenGrading       = document.getElementById('screenGrading');

  const dateSelect          = document.getElementById('dateSelect');
  const btnCheckGrading     = document.getElementById('btnCheckGrading');

  const teamNameInput       = document.getElementById('teamNameInput');
  const teamSizeInput       = document.getElementById('teamSizeInput');
  const btnAddTeam          = document.getElementById('btnAddTeam');
  const teamList            = document.getElementById('teamList');
  const btnProceedToRounds  = document.getElementById('btnProceedToRounds');

  const rubricContent       = document.getElementById('rubricContent');
  const btnAddMoreTeams     = document.getElementById('btnAddMoreTeams');
  const btnSelectRoundFromRubric = document.getElementById('btnSelectRoundFromRubric');

  const roundSelect         = document.getElementById('roundSelect');
  const btnOpenGrading      = document.getElementById('btnOpenGrading');
  const btnBackToRubric     = document.getElementById('btnBackToRubric');

  const teamSelect          = document.getElementById('teamSelect');
  const questionTable       = document.getElementById('questionTable').querySelector('tbody');
  const btnSaveScores       = document.getElementById('btnSaveScores');
  const btnSwitchTeam       = document.getElementById('btnSwitchTeam');
  const btnDoneRound        = document.getElementById('btnDoneRound');

  /***************************************************
   * 3) App State Variables
   ***************************************************/
  let currentDate = null;
  let allTeams = []; // Array of { teamName, teamSize }
  let currentRound = null; // e.g. "1", "2"
  let currentRoundData = {}; // Flattened question data for the chosen round
  let cachedTriviaData = {}; // { date: { [roundNum]: { Written: {...}, Puzzle: {...}... } } }
  // We'll keep an array for the round order:
  const roundTypeOrder = ['Written','Puzzle','Visual','Fill-In','Music'];

  // For the grading screen slider:
  // We'll map the slider 0..6 to these percentages
  const PERCENTAGE_MAP = [0.0, 0.25, 0.33, 0.50, 0.66, 0.75, 1.0];
  const DEFAULT_SLIDER_VALUE = 6; // i.e. 100%

  /***************************************************
   * 4) Screen Navigation Helpers
   ***************************************************/
  function showScreen(screenElem) {
    [screenDateSelect, screenTeamSetup, screenRubric, screenRoundSelect, screenGrading]
      .forEach(s => s.classList.remove('active'));
    screenElem.classList.add('active');
  }

  /***************************************************
   * 5) On Page Load: Populate the date dropdown
   ***************************************************/
  window.addEventListener('DOMContentLoaded', async () => {
    await loadDates();
  });

  async function loadDates() {
    dateSelect.innerHTML = "";
    const snapshot = await get(child(ref(db), "trivia"));
    if (snapshot.exists()) {
      const data = snapshot.val();
      const dateKeys = Object.keys(data).sort().reverse();
      dateKeys.forEach(d => {
        const opt = document.createElement("option");
        opt.value = d;
        opt.textContent = d;
        dateSelect.appendChild(opt);
      });
    } else {
      // No trivia data
      const opt = document.createElement("option");
      opt.textContent = "No Trivia Data Found";
      opt.disabled = true;
      dateSelect.appendChild(opt);
    }
  }

  /***************************************************
   * 6) Date Selected -> Check if there's existing grading
   ***************************************************/
  btnCheckGrading.addEventListener('click', async () => {
    currentDate = dateSelect.value;
    if (!currentDate) {
      alert("Please select a date.");
      return;
    }
    // Check if scores/date exist
    const snap = await get(child(ref(db), `scores/${currentDate}`));
    if (snap.exists()) {
      // We have existing grading => Go to Rubric
      showRubric();
    } else {
      // No existing grading => go to Team Setup
      allTeams = [];
      teamList.innerHTML = "";
      showScreen(screenTeamSetup);
    }
  });

  /***************************************************
   * 7) Team Setup Screen
   ***************************************************/
  btnAddTeam.addEventListener('click', () => {
    const name = teamNameInput.value.trim();
    const size = Number(teamSizeInput.value.trim() || 0);
    if (!name) {
      alert("Enter a team name.");
      return;
    }
    if (size < 1) {
      alert("Enter a valid team size.");
      return;
    }
    // Add/update local array
    const existing = allTeams.find(t => t.teamName === name);
    if (existing) {
      existing.teamSize = size;
    } else {
      allTeams.push({ teamName: name, teamSize: size });
    }
    refreshTeamList();
    teamNameInput.value = "";
    teamSizeInput.value = "";
  });

  function refreshTeamList() {
    teamList.innerHTML = "";
    allTeams.forEach(t => {
      const li = document.createElement('li');
      li.textContent = `${t.teamName} (size: ${t.teamSize})`;
      teamList.appendChild(li);
    });
  }

  btnProceedToRounds.addEventListener('click', async () => {
    if (!allTeams.length) {
      alert("Please add at least one team first.");
      return;
    }
    // Save these teams into the DB under scores/[date]
    for (let t of allTeams) {
      const path = `scores/${currentDate}/${t.teamName}`;
      await set(ref(db, path), {
        number_of_people: t.teamSize
      });
    }
    // Now go to Round Select
    await loadRoundOptions();
    showScreen(screenRoundSelect);
  });

  /***************************************************
   * 8) Rubric Screen
   ***************************************************/
  btnAddMoreTeams.addEventListener('click', async () => {
    // Re-fetch teams from DB, show in Team Setup
    allTeams = await fetchTeamsForDate(currentDate);
    refreshTeamList();
    showScreen(screenTeamSetup);
  });

  btnSelectRoundFromRubric.addEventListener('click', async () => {
    await loadRoundOptions();
    showScreen(screenRoundSelect);
  });

  async function showRubric() {
    showScreen(screenRubric);
    // We want columns for each round + Bonus + Instagram + Final + TeamSizePenalty + FinalScore
    rubricContent.innerHTML = "Loading...";
    // 1) Find all round numbers (and load them) so we can create columns
    //    We'll use the cachedTriviaData
    if (!cachedTriviaData[currentDate]) {
      const snap = await get(child(ref(db), `trivia/${currentDate}`));
      cachedTriviaData[currentDate] = snap.exists() ? snap.val() : {};
    }
    const allRounds = Object.keys(cachedTriviaData[currentDate]).sort((a,b)=> Number(a)-Number(b));

    // 2) Load team data from /scores/[date]
    const snap = await get(child(ref(db), `scores/${currentDate}`));
    if (!snap.exists()) {
      rubricContent.innerHTML = "<p>No scores found for this date.</p>";
      return;
    }
    const dateScores = snap.val(); 
    // structure: { [teamName]: { number_of_people, bonus, instagram_challenge, final_challenge, scores: {...} } }

    // 3) Build the table header
    let html = `<table>
      <thead>
        <tr>
          <th>Team</th>
          <th>Size</th>`;
    allRounds.forEach(r => {
      html += `<th class="round-col">R${r}</th>`;
    });
    // Extra columns
    html += `
          <th class="round-col">Bonus</th>
          <th class="round-col">Instagram</th>
          <th class="round-col">Final Ch.</th>
          <th class="round-col">Penalty</th>
          <th class="round-col">Final</th>
        </tr>
      </thead>
      <tbody>
    `;

    // 4) For each team, gather round scores + bonus columns
    const teamNames = Object.keys(dateScores).sort();
    for (let tName of teamNames) {
      const tObj = dateScores[tName];
      const tSize = tObj.number_of_people || 0;
      let sumOfRounds = 0;
      let roundScores = {};

      // Parse their round data
      if (tObj.scores) {
        Object.keys(tObj.scores).forEach(rNum => {
          // rNum => e.g. "1", "2"
          // each rNum => { "Written-qid": score, "Puzzle-qid": score, ...}
          let roundTotal = 0;
          const qScoreObj = tObj.scores[rNum];
          if (qScoreObj) {
            Object.keys(qScoreObj).forEach(k => {
              roundTotal += Number(qScoreObj[k] || 0);
            });
          }
          roundScores[rNum] = roundTotal;
        });
      }

      // Bonus columns
      const bonus = Number(tObj.bonus || 0);
      const insta = Number(tObj.instagram_challenge || 0);
      const finalCh = Number(tObj.final_challenge || 0);

      // Build row
      html += `<tr data-team="${tName}">
        <td>${tName}</td>
        <td>${tSize}</td>
      `;
      // Round columns
      allRounds.forEach(r => {
        const val = roundScores[r] || 0;
        sumOfRounds += val;
        html += `<td>${val}</td>`;
      });

      // Compute penalty for team size
      const penalty = getTeamSizePenalty(tSize);

      // We will make Bonus, Insta, FinalCh editable
      html += `
        <td><input type="number" class="bonusInput" value="${bonus}" style="width:60px"></td>
        <td><input type="number" class="instaInput" value="${insta}" style="width:60px"></td>
        <td><input type="number" class="finalChInput" value="${finalCh}" style="width:60px"></td>
        <td>${penalty}</td>
      `;

      // Final = sumOfRounds + bonus + insta + finalCh + penalty
      const finalScore = sumOfRounds + bonus + insta + finalCh + penalty;
      html += `<td>${finalScore}</td>`;

      html += `</tr>`;
    }
    html += `</tbody></table>`;
    rubricContent.innerHTML = html;

    // 5) Attach listeners to the bonus/insta/finalCh inputs
    const rows = rubricContent.querySelectorAll('tr[data-team]');
    rows.forEach(row => {
      const tName = row.getAttribute('data-team');
      const bonusInput = row.querySelector('.bonusInput');
      const instaInput = row.querySelector('.instaInput');
      const finalChInput = row.querySelector('.finalChInput');

      function handleChange() {
        const b = Number(bonusInput.value || 0);
        const i = Number(instaInput.value || 0);
        const f = Number(finalChInput.value || 0);
        // update in DB
        const path = `scores/${currentDate}/${tName}`;
        update(ref(db, path), {
          bonus: b,
          instagram_challenge: i,
          final_challenge: f
        }).then(() => {
          // Recompute final score for this row
          recalcRow(row);
        }).catch(err => {
          console.error("Error saving bonus:", err);
        });
      }

      bonusInput.addEventListener('change', handleChange);
      instaInput.addEventListener('change', handleChange);
      finalChInput.addEventListener('change', handleChange);
    });
  }

  // Recompute final score for a single row
  function recalcRow(row) {
    const tSize = Number(row.children[1].textContent || 0); // second cell is size
    const penalty = getTeamSizePenalty(tSize);

    // Sum up the round columns
    // We know up to the bonus col is after all round columns
    let sumOfRounds = 0;
    // The first 2 columns are Team & Size,
    // Then we have some number of round columns, then bonus, insta, final, penalty, finalscore
    // We'll find the input boxes
    // We can loop over each cell from col=2 until we find an <input> or those known columns
    let colIndex = 2;
    while (true) {
      const cell = row.children[colIndex];
      if (!cell) break;
      const inputs = cell.querySelectorAll('input');
      if (inputs.length > 0) {
        // we reached the bonus column, so break from summation
        break;
      }
      // Otherwise it's a round score cell
      const val = Number(cell.textContent || 0);
      sumOfRounds += val;
      colIndex++;
    }
    // bonus, insta, finalCh are next 3 columns with inputs
    const bonus = Number(row.querySelector('.bonusInput').value || 0);
    const insta = Number(row.querySelector('.instaInput').value || 0);
    const finalCh = Number(row.querySelector('.finalChInput').value || 0);

    // The last cell in the row is the final score
    const finalCell = row.lastElementChild; // <td> for final score
    const finalScore = sumOfRounds + bonus + insta + finalCh + penalty;
    finalCell.textContent = finalScore;
    // The penalty cell is second-to-last
    const penaltyCell = finalCell.previousElementSibling;
    penaltyCell.textContent = penalty;
  }

  // Team size penalty: 6 or under => 0, 7 => -4, 8 => -6, 9 => -8, etc.
  function getTeamSizePenalty(size) {
    if (size <= 6) return 0;
    const diff = size - 6; // how many over 6
    // 7 => -4, 8 => -6, 9 => -8
    // we can use a formula: -2 * diff - 2
    // check that it matches examples:
    // 7 => diff=1 => -2*1 - 2= -4
    // 8 => diff=2 => -2*2 - 2= -6
    // 9 => diff=3 => -2*3 - 2= -8
    return -2 * diff - 2;
  }

  /***************************************************
   * 9) Round Selection Screen
   ***************************************************/
  btnOpenGrading.addEventListener('click', () => {
    currentRound = roundSelect.value; 
    if (!currentRound) {
      alert("No round selected.");
      return;
    }
    // Go to grading screen for that round
    showGradingScreen();
  });

  btnBackToRubric.addEventListener('click', () => {
    showRubric();
  });

  async function loadRoundOptions() {
    // We want to load the round numbers from /trivia/[currentDate]
    if (!cachedTriviaData[currentDate]) {
      const snap = await get(child(ref(db), `trivia/${currentDate}`));
      cachedTriviaData[currentDate] = snap.exists() ? snap.val() : {};
    }
    const data = cachedTriviaData[currentDate];
    const roundKeys = Object.keys(data).sort((a,b) => Number(a) - Number(b));
    roundSelect.innerHTML = "";
    roundKeys.forEach(rNum => {
      const opt = document.createElement("option");
      opt.value = rNum;
      opt.textContent = `Round ${rNum}`;
      roundSelect.appendChild(opt);
    });
    if (!roundKeys.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "No Rounds Found";
      roundSelect.appendChild(opt);
    }
  }

  /***************************************************
   * 10) Grading Screen
   ***************************************************/
  async function showGradingScreen() {
    showScreen(screenGrading);
    // 1) Load teams
    allTeams = await fetchTeamsForDate(currentDate);
    teamSelect.innerHTML = "";
    allTeams.forEach(t => {
      const opt = document.createElement("option");
      opt.value = t.teamName;
      opt.textContent = t.teamName;
      teamSelect.appendChild(opt);
    });
    // 2) Load question data for current round
    loadQuestionDataForRound(currentRound);
    // 3) By default, fill table for the first team
    loadTeamScoresIntoTable(teamSelect.value);
  }

  teamSelect.addEventListener('change', () => {
    loadTeamScoresIntoTable(teamSelect.value);
  });

  function loadQuestionDataForRound(rNum) {
    // Grab the object like: { Written: {...}, Puzzle: {...}, ... }
    const dataForDate = cachedTriviaData[currentDate] || {};
    const roundObj = dataForDate[rNum] || {};

    // We'll flatten them in the fixed order: Written, Puzzle, Visual, Fill-In, Music
    currentRoundData = {}; // { uniqueQID => { roundType, question, answer, totalPoints } }
    roundTypeOrder.forEach(rType => {
      if (roundObj[rType]) {
        const questionsOfType = roundObj[rType];
        Object.keys(questionsOfType).forEach(qId => {
          const q = questionsOfType[qId];
          const uniqueQID = `${rType}-${qId}`;
          currentRoundData[uniqueQID] = {
            roundType: rType,
            question: q.question || "",
            answer: q.answer || "",
            totalPoints: Number(q.total_possible_points) || 0
          };
        });
      }
    });
  }

  async function loadTeamScoresIntoTable(teamName) {
    // Load this team's existing scores for the current round
    const path = `scores/${currentDate}/${teamName}/scores/${currentRound}`;
    const snap = await get(child(ref(db), path));
    let teamRoundScores = snap.exists() ? snap.val() : {};
    // Build table rows in the order of currentRoundData
    questionTable.innerHTML = "";
    for (let uniqueQID of Object.keys(currentRoundData)) {
      const q = currentRoundData[uniqueQID];
      const tr = document.createElement('tr');

      // question
      const tdQ = document.createElement('td');
      tdQ.textContent = q.question;
      tr.appendChild(tdQ);

      // answer
      const tdA = document.createElement('td');
      tdA.textContent = q.answer;
      tr.appendChild(tdA);

      // total points
      const tdPts = document.createElement('td');
      tdPts.textContent = q.totalPoints;
      tr.appendChild(tdPts);

      // Score slider (0..6) mapping to PERCENTAGE_MAP
      const tdSlider = document.createElement('td');
      tdSlider.classList.add('slider-cell');

      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = "0";
      slider.max = (PERCENTAGE_MAP.length - 1).toString(); // 6
      slider.step = "1";
      slider.value = DEFAULT_SLIDER_VALUE; // default to 6 => 100%

      // We'll also show a span with the current % label
      const pctLabel = document.createElement('span');

      // figure out existing score => set the slider
      const existingScore = Number(teamRoundScores[uniqueQID] || 0);
      let ratio = q.totalPoints ? (existingScore / q.totalPoints) : 0;
      // find best match index
      let bestIdx = 0, bestDiff = 999;
      PERCENTAGE_MAP.forEach((pctVal, idx) => {
        const diff = Math.abs(pctVal - ratio);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestIdx = idx;
        }
      });
      slider.value = bestIdx;

      // function to recalc label & set table "Calculated" cell
      const recalcScore = () => {
        const idx = Number(slider.value);
        const pct = PERCENTAGE_MAP[idx];
        pctLabel.textContent = (pct*100).toFixed(0)+"%";
        // update the "Calculated" cell
        const calcCell = tr.querySelector('.calc-cell');
        if (calcCell) {
          const s = Math.round(q.totalPoints * pct * 100)/100;
          calcCell.textContent = s.toString();
        }
      };
      slider.addEventListener('input', recalcScore);

      // Initialize the label & calc cell
      recalcScore();

      tdSlider.appendChild(slider);
      tdSlider.appendChild(pctLabel);
      tr.appendChild(tdSlider);

      // A column to show the computed numeric score
      const tdCalc = document.createElement('td');
      tdCalc.classList.add('calc-cell');
      tr.appendChild(tdCalc);

      questionTable.appendChild(tr);
    }
    // Trigger a refresh so the calc columns match the slider positions
    const allSliders = questionTable.querySelectorAll('input[type="range"]');
    allSliders.forEach(sl => {
      sl.dispatchEvent(new Event('input'));
    });
  }

  btnSaveScores.addEventListener('click', async () => {
    const teamName = teamSelect.value;
    if (!teamName) {
      alert("No team selected!");
      return;
    }
    // gather from questionTable
    const rows = questionTable.querySelectorAll('tr');
    let updates = {};
    rows.forEach(tr => {
      const slider = tr.querySelector('input[type="range"]');
      if (!slider) return; // skip header or malformed
      const idx = Number(slider.value);
      const pct = PERCENTAGE_MAP[idx];

      const tdPts = tr.children[2];
      const totalPoints = Number(tdPts.textContent || 0);
      const score = Math.round(totalPoints * pct * 100)/100;

      // We need to figure out the uniqueQID for this question
      // We can do that by matching the question text and searching in currentRoundData,
      // but that’s not bulletproof. Alternatively, we stored uniqueQID in data attributes
      // If you want a simpler approach: we can reconstruct by the row index in the same order
    });
    // Actually let's build an array of uniqueQIDs from currentRoundData
    const uniqueQIDs = Object.keys(currentRoundData);

    // We'll assume row i corresponds to uniqueQIDs[i]
    const rowArray = Array.from(rows);
    rowArray.forEach((tr, i) => {
      const uniqueQID = uniqueQIDs[i];
      const slider = tr.querySelector('input[type="range"]');
      if (!slider) return;
      const idx = Number(slider.value);
      const pct = PERCENTAGE_MAP[idx];
      const totalPoints = Number(tr.children[2].textContent || 0);
      const score = Math.round(totalPoints * pct * 100)/100;
      updates[uniqueQID] = score;
    });

    // Write to /scores/[date]/[teamName]/scores/[roundNum]
    const path = `scores/${currentDate}/${teamName}/scores/${currentRound}`;
    try {
      await set(ref(db, path), updates);
      alert("Scores saved!");
    } catch (e) {
      console.error(e);
      alert("Error saving scores.");
    }
  });

  btnSwitchTeam.addEventListener('click', () => {
    if (teamSelect.options.length > 1) {
      const idx = teamSelect.selectedIndex;
      const newIdx = (idx + 1) % teamSelect.options.length;
      teamSelect.selectedIndex = newIdx;
      loadTeamScoresIntoTable(teamSelect.value);
    } else {
      alert("Only one team in the list.");
    }
  });

  btnDoneRound.addEventListener('click', () => {
    showRubric();
  });

  /***************************************************
   * 11) Utility: Fetch teams for a date
   ***************************************************/
  async function fetchTeamsForDate(date) {
    const snap = await get(child(ref(db), `scores/${date}`));
    let result = [];
    if (snap.exists()) {
      const data = snap.val();
      // data: { [teamName]: { number_of_people, ... } }
      Object.keys(data).forEach(tName => {
        const tObj = data[tName];
        result.push({
          teamName: tName,
          teamSize: tObj.number_of_people || 0
        });
      });
    }
    return result;
  }

</script>

</body>
</html>
