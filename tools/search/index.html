<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evil Trivia - Search Archive</title>
    <script src="/js/components/autoload-banner.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #FFCC00;
            --secondary-color: #000;
            --background-white: #fff;
            --text-color: #333;
            --border-color: #ddd;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
        }

        body {
            font-family: 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--primary-color);
            margin-top: 60px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 95%;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: var(--text-color);
            font-weight: 500;
        }
        
        .search-container {
            background-color: var(--background-white);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            width: 100%;
            box-sizing: border-box;
        }
        
        .search-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            width: 100%;
            align-items: flex-end;
        }
        
        .search-input-wrapper {
            flex-grow: 1;
            min-width: 250px;
            position: relative;
        }
        
        .search-input-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-color);
            font-size: 14px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
            transition: var(--transition);
            font-family: inherit;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(0,0,0,0.1);
        }
        
        .search-clear {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            display: none;
            padding: 4px;
            border-radius: 4px;
        }
        
        .search-clear:hover {
            background-color: #f0f0f0;
        }
        
        .search-clear.visible {
            display: block;
        }
        
        select {
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            min-width: 150px;
            font-family: inherit;
            transition: var(--transition);
        }
        
        select:focus {
            outline: none;
            border-color: var(--secondary-color);
        }
        
        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: var(--transition);
            font-family: inherit;
        }
        
        button:hover:not(:disabled) {
            background-color: #333;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .filter-section {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 180px;
        }
        
        .filter-group label {
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
            font-size: 14px;
        }
        
        .search-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #eee;
            margin-bottom: 16px;
            font-size: 14px;
            color: #666;
        }
        
        .search-time {
            font-style: italic;
        }
        
        .results-container {
            background-color: var(--background-white);
            border-radius: 12px;
            padding: 24px;
            box-shadow: var(--shadow);
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }
        
        .results-count {
            font-weight: 600;
            color: var(--text-color);
            font-size: 18px;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .results-table th, .results-table td {
            padding: 16px 12px;
            text-align: left;
            border-bottom: 1px solid #f0f0f0;
            vertical-align: middle;
        }
        
        .results-table th {
            background-color: #f8f9fa;
            color: var(--text-color);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .results-table tr:hover {
            background-color: #f8f9fa;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .load-more {
            text-align: center;
            margin-top: 24px;
        }
        
        .question-text {
            max-width: 400px;
            min-height: 40px;
            max-height: 120px;
            white-space: normal;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .relevance-score {
            display: inline-block;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }
        
        .highlighted {
            background-color: #fff3cd;
            padding: 1px 3px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .auth-container {
            background-color: var(--background-white);
            border-radius: 12px;
            padding: 40px;
            max-width: 500px;
            margin: 40px auto;
            text-align: center;
            box-shadow: var(--shadow);
        }
        
        .auth-container h2 {
            margin-top: 0;
            color: var(--text-color);
            font-weight: 500;
        }
        
        .auth-container p {
            margin-bottom: 24px;
            color: #666;
            line-height: 1.6;
        }
        
        .auth-btn {
            display: inline-block;
            background-color: var(--secondary-color);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            transition: var(--transition);
        }
        
        .auth-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .hidden {
            display: none;
        }

        .search-help {
            margin-top: 12px;
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }

        .search-help code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .filter-dropdown {
            position: relative;
            display: inline-block;
            min-width: 200px;
        }
        
        .filter-dropdown-header {
            padding: 12px 16px;
            background-color: var(--background-white);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
        }
        
        .filter-dropdown-header:hover {
            border-color: #bbb;
        }
        
        .filter-dropdown.open .filter-dropdown-header {
            border-color: var(--secondary-color);
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        
        .filter-dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--background-white);
            min-width: 280px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            padding: 12px;
            z-index: 20;
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid var(--secondary-color);
            border-top: none;
            border-radius: 0 0 8px 8px;
        }
        
        .filter-dropdown.open .filter-dropdown-content {
            display: block;
        }
        
        .filter-option {
            padding: 10px 12px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 6px;
            transition: var(--transition);
        }
        
        .filter-option:hover {
            background-color: #f8f9fa;
        }
        
        .filter-option input[type="checkbox"] {
            margin-right: 12px;
            transform: scale(1.1);
        }
        
        .filter-count {
            display: inline-block;
            background-color: #e9ecef;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            color: #495057;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--secondary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 0 0 8px 8px;
            box-shadow: var(--shadow);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .suggestion-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .suggestion-item:hover {
            background-color: #f8f9fa;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-count {
            font-size: 12px;
            color: #666;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .no-results, .end-results {
            text-align: center;
            padding: 40px 20px;
            color: #666;
            font-style: italic;
        }
        
        .end-results {
            border-top: 1px solid #eee;
            margin-top: 20px;
        }
        
        .performance-badge {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
        
        .cached-indicator {
            color: #28a745;
            font-size: 12px;
            margin-left: 8px;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                max-width: 100%;
                padding: 12px;
            }
            
            .search-container, .results-container {
                padding: 16px;
                border-radius: 8px;
            }
            
            .search-row {
                flex-direction: column;
                gap: 12px;
            }
            
            .filter-section {
                flex-direction: column;
                gap: 12px;
            }
            
            .filter-group {
                width: 100%;
                min-width: auto;
            }
            
            .results-table {
                font-size: 13px;
            }
            
            .results-table th, .results-table td {
                padding: 12px 8px;
            }
            
            .question-text {
                max-width: 250px;
            }
        }
        
        /* Advanced Search Features */
        .advanced-search {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
            margin-top: 16px;
            border: 1px solid #e9ecef;
        }
        
        .advanced-toggle {
            background: none;
            border: none;
            color: #666;
            font-size: 14px;
            cursor: pointer;
            padding: 8px 0;
            text-decoration: underline;
        }
        
        .search-mode-toggle {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        
        .mode-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            background: white;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .mode-btn.active {
            background: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }
        
        .search-analytics {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            font-size: 12px;
            min-width: 200px;
            display: none;
            z-index: 1000;
        }
        
        .analytics-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 Enhanced Trivia Archive Search</h1>
        
        <!-- Authentication Required Screen -->
        <div id="auth-screen" class="auth-container hidden">
            <h2>🔐 Access Required</h2>
            <p>You need admin or tools privileges to access this powerful search interface.</p>
            <a href="/account" class="auth-btn">Go to Account Page</a>
        </div>
        
        <!-- Search Interface -->
        <div id="search-screen" class="hidden">
            <div class="search-container">
                <div class="search-row">
                    <div class="search-input-wrapper">
                        <label class="search-input-label">Search questions, answers, and more...</label>
                        <input type="text" id="search-query" placeholder="Try: 'music', 'visual round', 'who invented*', etc.">
                        <button class="search-clear" id="search-clear" title="Clear search">×</button>
                        <div class="search-suggestions" id="search-suggestions"></div>
                    </div>
                    <button id="search-btn">
                        <span class="search-btn-text">Search</span>
                        <span class="loading-spinner hidden" id="search-spinner"></span>
                    </button>
                </div>
                
                <div class="search-help">
                    <strong>Pro tips:</strong> Use <code>*</code> for wildcards, <code>"exact phrase"</code> for exact matches, 
                    or try searches like <code>music visual</code> for multiple terms
                </div>
                
                <button class="advanced-toggle" id="advanced-toggle">⚙️ Advanced Search Options</button>
                
                <div class="advanced-search hidden" id="advanced-search">
                    <div class="search-mode-toggle">
                        <label style="margin-right: 12px; font-weight: 500;">Search Mode:</label>
                        <button class="mode-btn active" data-mode="smart">🧠 Smart</button>
                        <button class="mode-btn" data-mode="exact">📍 Exact</button>
                        <button class="mode-btn" data-mode="fuzzy">🔍 Fuzzy</button>
                    </div>
                    
                    <div class="filter-section">
                        <div class="filter-group">
                            <label>Format Filter</label>
                            <div class="filter-dropdown" id="format-dropdown">
                                <div class="filter-dropdown-header">
                                    <span>All Formats</span>
                                    <span class="filter-count">0</span>
                                    <span>▼</span>
                                </div>
                                <div class="filter-dropdown-content">
                                    <input type="text" class="filter-search" placeholder="Search formats...">
                                    <div class="filter-options" id="format-options"></div>
                                    <div class="filter-actions">
                                        <button class="select-all-btn">Select All</button>
                                        <button class="clear-btn">Clear All</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-group">
                            <label>Field Filter</label>
                            <div class="filter-dropdown" id="field-dropdown">
                                <div class="filter-dropdown-header">
                                    <span>All Fields</span>
                                    <span class="filter-count">0</span>
                                    <span>▼</span>
                                </div>
                                <div class="filter-dropdown-content">
                                    <input type="text" class="filter-search" placeholder="Search fields...">
                                    <div class="filter-options" id="field-options"></div>
                                    <div class="filter-actions">
                                        <button class="select-all-btn">Select All</button>
                                        <button class="clear-btn">Clear All</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="results-container">
                <div class="results-header">
                    <div class="results-count">Ready to search <span id="total-questions">0</span> questions</div>
                    <button id="clear-btn">Clear Results</button>
                </div>
                
                <div class="search-stats hidden" id="search-stats">
                    <div>
                        <span id="results-count">0</span> results found
                        <span class="cached-indicator hidden" id="cached-indicator">⚡ Cached</span>
                    </div>
                    <div class="search-time" id="search-time"></div>
                </div>
                
                <div class="table-responsive">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Score</th>
                                <th>Trivia #</th>
                                <th>Date</th>
                                <th>Round</th>
                                <th>Format</th>
                                <th>Question</th>
                                <th>Answer</th>
                                <th>Media</th>
                            </tr>
                        </thead>
                        <tbody id="results-body">
                            <!-- Results will be populated here -->
                        </tbody>
                    </table>
                </div>
                
                <div id="no-results" class="no-results hidden">
                    <p>🔍 No matching questions found.</p>
                    <p>Try adjusting your search terms or filters.</p>
                </div>
                
                <div id="end-results" class="end-results hidden">
                    <p>✅ That's all! No more results to display.</p>
                </div>
                
                <div class="load-more hidden" id="load-more">
                    <button id="load-more-btn">Load More Results</button>
                </div>
            </div>
        </div>
        
        <!-- Performance Badge -->
        <div class="performance-badge" id="performance-badge"></div>
        
        <!-- Search Analytics -->
        <div class="search-analytics" id="search-analytics">
            <div style="font-weight: 600; margin-bottom: 8px;">Search Analytics</div>
            <div class="analytics-row">
                <span>Cache Hit Rate:</span>
                <span id="cache-hit-rate">0%</span>
            </div>
            <div class="analytics-row">
                <span>Avg Search Time:</span>
                <span id="avg-search-time">0ms</span>
            </div>
            <div class="analytics-row">
                <span>Total Searches:</span>
                <span id="total-searches">0</span>
            </div>
        </div>
    </div>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
    
    <script>
        // Enhanced Search System with Modern Optimizations
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
            authDomain: "eviltrivia-47664.firebaseapp.com",
            databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
            projectId: "eviltrivia-47664",
            storageBucket: "eviltrivia-47664.firebasestorage.app",
            messagingSenderId: "401826818140",
            appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
            measurementId: "G-2W6RK96Y34"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();
        
        // Enhanced Search Engine
        class AdvancedSearchEngine {
            constructor() {
                this.searchIndex = new Map();
                this.searchCache = new Map();
                this.searchHistory = [];
                this.analytics = {
                    totalSearches: 0,
                    cacheHits: 0,
                    searchTimes: [],
                    popularTerms: new Map()
                };
                this.initializeIndexedDB();
                this.loadSearchIndex();
            }
            
            async initializeIndexedDB() {
                try {
                    const request = indexedDB.open('TriviaSearchDB', 1);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('searchIndex')) {
                            db.createObjectStore('searchIndex', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('searchCache')) {
                            db.createObjectStore('searchCache', { keyPath: 'query' });
                        }
                    };
                    
                    this.db = await new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('IndexedDB initialized successfully');
                } catch (error) {
                    console.warn('IndexedDB not available, using memory cache', error);
                }
            }
            
            async loadSearchIndex() {
                try {
                    // Try to load from IndexedDB first
                    const cachedIndex = await this.getFromIndexedDB('searchIndex', 'main');
                    
                    if (cachedIndex && this.isIndexFresh(cachedIndex.timestamp)) {
                        this.searchIndex = new Map(cachedIndex.data);
                        console.log('Loaded search index from cache');
                        return;
                    }
                    
                    // Build fresh index
                    await this.buildSearchIndex();
                } catch (error) {
                    console.error('Error loading search index:', error);
                    await this.buildSearchIndex();
                }
            }
            
            async buildSearchIndex() {
                console.log('Building fresh search index...');
                const startTime = performance.now();
                
                try {
                    // Load trivia data in chunks for better performance
                    const archiveRef = db.ref('trivia-archive/archive');
                    const snapshot = await archiveRef.once('value');
                    const data = snapshot.val();
                    
                    if (!data) {
                        console.warn('No trivia data found');
                        return;
                    }
                    
                    // Process data and build index
                    const index = new Map();
                    let questionCount = 0;
                    
                    for (const [triviaNumber, triviaSet] of Object.entries(data)) {
                        if (!triviaSet.trivia) continue;
                        
                        const processedQuestions = this.processTriviaSet(triviaNumber, triviaSet);
                        
                        for (const question of processedQuestions) {
                            index.set(question.id, question);
                            questionCount++;
                        }
                    }
                    
                    this.searchIndex = index;
                    
                    // Cache the index
                    await this.saveToIndexedDB('searchIndex', 'main', {
                        data: Array.from(index.entries()),
                        timestamp: Date.now(),
                        questionCount
                    });
                    
                    const endTime = performance.now();
                    console.log(`Search index built in ${(endTime - startTime).toFixed(2)}ms with ${questionCount} questions`);
                    
                    // Update UI
                    document.getElementById('total-questions').textContent = questionCount.toLocaleString();
                    
                } catch (error) {
                    console.error('Error building search index:', error);
                }
            }
            
            processTriviaSet(triviaNumber, triviaSet) {
                const questions = [];
                const triviaDate = triviaSet.date || '';
                
                for (const [roundKey, roundData] of Object.entries(triviaSet.trivia)) {
                    if (typeof roundData !== 'object') continue;
                    
                    for (const [formatKey, formatData] of Object.entries(roundData)) {
                        if (typeof formatData !== 'object') continue;
                        
                        for (const [questionKey, questionData] of Object.entries(formatData)) {
                            if (typeof questionData !== 'object' || 
                                ['Round Name', 'Round Type', 'Round Format', 'Round Instruction'].includes(questionKey)) {
                                continue;
                            }
                            
                            const processedQuestion = {
                                id: `${triviaNumber}-${roundKey}-${formatKey}-${questionKey}`,
                                triviaNumber,
                                triviaDate,
                                round: roundKey,
                                format: formatKey,
                                questionNumber: questionKey,
                                data: questionData,
                                searchableText: this.buildSearchableText(questionData),
                                keywords: this.extractKeywords(questionData)
                            };
                            
                            questions.push(processedQuestion);
                        }
                    }
                }
                
                return questions;
            }
            
            buildSearchableText(questionData) {
                const fields = [
                    questionData.Question || '',
                    questionData.Answer || '',
                    questionData['Round Name'] || '',
                    questionData['Round Instruction'] || '',
                    questionData['Hidden Structure_Theme'] || ''
                ];
                
                return fields.join(' ').toLowerCase();
            }
            
            extractKeywords(questionData) {
                const text = this.buildSearchableText(questionData);
                const words = text.match(/\b\w{3,}\b/g) || [];
                return [...new Set(words)];
            }
            
            async search(query, options = {}) {
                const startTime = performance.now();
                
                // Update analytics
                this.analytics.totalSearches++;
                this.updatePopularTerms(query);
                
                // Check cache first
                const cacheKey = this.getCacheKey(query, options);
                const cachedResult = await this.getFromCache(cacheKey);
                
                if (cachedResult) {
                    this.analytics.cacheHits++;
                    this.updateAnalyticsUI();
                    return {
                        ...cachedResult,
                        searchTime: performance.now() - startTime,
                        fromCache: true
                    };
                }
                
                // Perform search
                const results = this.performSearch(query, options);
                
                // Cache results
                const searchResult = {
                    results,
                    query,
                    options,
                    timestamp: Date.now()
                };
                
                await this.saveToCache(cacheKey, searchResult);
                
                const endTime = performance.now();
                const searchTime = endTime - startTime;
                this.analytics.searchTimes.push(searchTime);
                this.updateAnalyticsUI();
                
                return {
                    ...searchResult,
                    searchTime,
                    fromCache: false
                };
            }
            
            performSearch(query, options) {
                if (!query.trim()) return [];
                
                const searchMode = options.mode || 'smart';
                const results = [];
                
                for (const [id, question] of this.searchIndex) {
                    const score = this.calculateRelevanceScore(question, query, searchMode);
                    
                    if (score > 0) {
                        results.push({
                            ...question,
                            relevanceScore: score
                        });
                    }
                }
                
                // Sort by relevance score (highest first)
                results.sort((a, b) => b.relevanceScore - a.relevanceScore);
                
                // Apply filters
                return this.applyFilters(results, options);
            }
            
            calculateRelevanceScore(question, query, mode) {
                let score = 0;
                const searchableText = question.searchableText;
                const queryLower = query.toLowerCase().trim();
                
                switch (mode) {
                    case 'exact':
                        score = this.calculateExactScore(searchableText, queryLower);
                        break;
                    case 'fuzzy':
                        score = this.calculateFuzzyScore(searchableText, queryLower);
                        break;
                    default: // smart
                        score = this.calculateSmartScore(searchableText, queryLower, question);
                }
                
                return score;
            }
            
            calculateSmartScore(text, query, question) {
                let score = 0;
                
                // Exact phrase match (highest priority)
                if (query.includes('"')) {
                    const phrases = query.match(/"([^"]+)"/g) || [];
                    for (const phrase of phrases) {
                        const cleanPhrase = phrase.replace(/"/g, '');
                        if (text.includes(cleanPhrase)) {
                            score += 100;
                        }
                    }
                }
                
                // Wildcard matching
                if (query.includes('*')) {
                    const pattern = this.wildcardToRegex(query);
                    if (pattern.test(text)) {
                        score += 75;
                    }
                }
                
                // Individual word matching
                const queryWords = query.replace(/[*"]/g, '').split(/\s+/).filter(w => w.length > 0);
                for (const word of queryWords) {
                    if (text.includes(word)) {
                        // Higher score for question/answer fields
                        const questionText = (question.data.Question || '').toLowerCase();
                        const answerText = (question.data.Answer || '').toLowerCase();
                        
                        if (questionText.includes(word)) score += 50;
                        if (answerText.includes(word)) score += 40;
                        if (text.includes(word)) score += 10;
                        
                        // Bonus for word boundaries
                        const wordBoundaryRegex = new RegExp(`\\b${this.escapeRegex(word)}\\b`);
                        if (wordBoundaryRegex.test(text)) score += 20;
                    }
                }
                
                // Bonus for multiple word matches
                const matchedWords = queryWords.filter(word => text.includes(word));
                if (matchedWords.length > 1) {
                    score += matchedWords.length * 15;
                }
                
                return score;
            }
            
            calculateExactScore(text, query) {
                return text.includes(query) ? 100 : 0;
            }
            
            calculateFuzzyScore(text, query) {
                // Simple fuzzy matching - could be enhanced with more sophisticated algorithms
                const words = query.split(/\s+/);
                let matches = 0;
                
                for (const word of words) {
                    if (text.includes(word)) {
                        matches++;
                    } else {
                        // Check for partial matches
                        for (let i = 0; i < word.length - 2; i++) {
                            const substr = word.substring(i, i + 3);
                            if (text.includes(substr)) {
                                matches += 0.3;
                                break;
                            }
                        }
                    }
                }
                
                return (matches / words.length) * 100;
            }
            
            wildcardToRegex(pattern) {
                const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                const regex = escaped.replace(/\*/g, '.*').replace(/\?/g, '.');
                return new RegExp(regex, 'i');
            }
            
            escapeRegex(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }
            
            applyFilters(results, options) {
                let filtered = results;
                
                if (options.formats && options.formats.length > 0) {
                    filtered = filtered.filter(r => options.formats.includes(r.format));
                }
                
                if (options.fields && options.fields.length > 0) {
                    filtered = filtered.filter(r => {
                        return options.fields.some(field => {
                            const value = r.data[field];
                            return value && typeof value === 'string' && value.trim().length > 0;
                        });
                    });
                }
                
                return filtered;
            }
            
            async getFromCache(key) {
                try {
                    if (this.searchCache.has(key)) {
                        const cached = this.searchCache.get(key);
                        if (this.isCacheFresh(cached.timestamp)) {
                            return cached;
                        }
                    }
                    
                    // Try IndexedDB
                    if (this.db) {
                        const cached = await this.getFromIndexedDB('searchCache', key);
                        if (cached && this.isCacheFresh(cached.timestamp)) {
                            this.searchCache.set(key, cached);
                            return cached;
                        }
                    }
                } catch (error) {
                    console.warn('Cache retrieval error:', error);
                }
                
                return null;
            }
            
            async saveToCache(key, data) {
                try {
                    this.searchCache.set(key, data);
                    
                    if (this.db) {
                        await this.saveToIndexedDB('searchCache', key, data);
                    }
                } catch (error) {
                    console.warn('Cache save error:', error);
                }
            }
            
            async getFromIndexedDB(storeName, key) {
                if (!this.db) return null;
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });
            }
            
            async saveToIndexedDB(storeName, key, data) {
                if (!this.db) return;
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put({ ...data, id: key });
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => resolve(false);
                });
            }
            
            getCacheKey(query, options) {
                return `${query}-${JSON.stringify(options)}`;
            }
            
            isCacheFresh(timestamp) {
                return Date.now() - timestamp < 5 * 60 * 1000; // 5 minutes
            }
            
            isIndexFresh(timestamp) {
                return Date.now() - timestamp < 60 * 60 * 1000; // 1 hour
            }
            
            updatePopularTerms(query) {
                const words = query.toLowerCase().split(/\s+/);
                for (const word of words) {
                    if (word.length > 2) {
                        this.analytics.popularTerms.set(word, (this.analytics.popularTerms.get(word) || 0) + 1);
                    }
                }
            }
            
            updateAnalyticsUI() {
                const cacheHitRate = this.analytics.totalSearches > 0 
                    ? Math.round((this.analytics.cacheHits / this.analytics.totalSearches) * 100)
                    : 0;
                
                const avgSearchTime = this.analytics.searchTimes.length > 0
                    ? Math.round(this.analytics.searchTimes.reduce((a, b) => a + b, 0) / this.analytics.searchTimes.length)
                    : 0;
                
                document.getElementById('cache-hit-rate').textContent = `${cacheHitRate}%`;
                document.getElementById('avg-search-time').textContent = `${avgSearchTime}ms`;
                document.getElementById('total-searches').textContent = this.analytics.totalSearches;
            }
            
            getSuggestions(partialQuery) {
                const suggestions = [];
                const queryLower = partialQuery.toLowerCase();
                
                // Get popular terms that match
                for (const [term, count] of this.analytics.popularTerms) {
                    if (term.startsWith(queryLower) && term !== queryLower) {
                        suggestions.push({ text: term, count });
                    }
                }
                
                // Sort by popularity and limit results
                return suggestions
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 5);
            }
        }
        
        // Initialize search engine
        const searchEngine = new AdvancedSearchEngine();
        
        // DOM Elements
        const authScreen = document.getElementById('auth-screen');
        const searchScreen = document.getElementById('search-screen');
        const searchQuery = document.getElementById('search-query');
        const searchBtn = document.getElementById('search-btn');
        const searchSpinner = document.getElementById('search-spinner');
        const searchClear = document.getElementById('search-clear');
        const advancedToggle = document.getElementById('advanced-toggle');
        const advancedSearch = document.getElementById('advanced-search');
        const searchStats = document.getElementById('search-stats');
        const resultsBody = document.getElementById('results-body');
        const resultsCount = document.getElementById('results-count');
        const searchTime = document.getElementById('search-time');
        const cachedIndicator = document.getElementById('cached-indicator');
        const noResults = document.getElementById('no-results');
        const endResults = document.getElementById('end-results');
        const loadMoreSection = document.getElementById('load-more');
        const performanceBadge = document.getElementById('performance-badge');
        const searchSuggestions = document.getElementById('search-suggestions');
        
        // Search state
        let currentResults = [];
        let currentQuery = '';
        let currentOptions = {};
        let searchTimeout = null;
        
        // Debounced search function
        function debounceSearch(func, delay) {
            return function(...args) {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => func.apply(this, args), delay);
            };
        }
        
        const debouncedSearch = debounceSearch(performSearch, 300);
        
        // Event Listeners
        searchQuery.addEventListener('input', (e) => {
            const value = e.target.value;
            
            // Show/hide clear button
            searchClear.classList.toggle('visible', value.length > 0);
            
            // Show suggestions
            if (value.length > 2) {
                showSuggestions(value);
                // Auto-search for logged-in users
                debouncedSearch();
            } else {
                hideSuggestions();
            }
        });
        
        searchQuery.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                performSearch();
            }
        });
        
        searchClear.addEventListener('click', () => {
            searchQuery.value = '';
            searchClear.classList.remove('visible');
            hideSuggestions();
            clearResults();
        });
        
        searchBtn.addEventListener('click', performSearch);
        
        advancedToggle.addEventListener('click', () => {
            advancedSearch.classList.toggle('hidden');
            const isHidden = advancedSearch.classList.contains('hidden');
            advancedToggle.textContent = isHidden ? '⚙️ Advanced Search Options' : '⚙️ Hide Advanced Options';
        });
        
        // Search mode toggle
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Re-search with new mode if there's a query
                if (searchQuery.value.trim()) {
                    debouncedSearch();
                }
            });
        });
        
        async function performSearch() {
            const query = searchQuery.value.trim();
            if (!query) {
                clearResults();
                return;
            }
            
            // Show loading state
            setLoadingState(true);
            
            try {
                const activeMode = document.querySelector('.mode-btn.active').dataset.mode;
                const options = {
                    mode: activeMode,
                    formats: [], // Add filter logic here
                    fields: []   // Add filter logic here
                };
                
                currentQuery = query;
                currentOptions = options;
                
                const result = await searchEngine.search(query, options);
                currentResults = result.results;
                
                displayResults(result);
                updateSearchStats(result);
                
            } catch (error) {
                console.error('Search error:', error);
                showError('Search failed. Please try again.');
            } finally {
                setLoadingState(false);
            }
        }
        
        function displayResults(searchResult) {
            resultsBody.innerHTML = '';
            
            if (searchResult.results.length === 0) {
                noResults.classList.remove('hidden');
                searchStats.classList.add('hidden');
                return;
            }
            
            noResults.classList.add('hidden');
            searchStats.classList.remove('hidden');
            
            searchResult.results.forEach((result, index) => {
                const row = createResultRow(result, index);
                resultsBody.appendChild(row);
            });
        }
        
        function createResultRow(result, index) {
            const row = document.createElement('tr');
            row.style.animationDelay = `${index * 50}ms`;
            
            const question = result.data.Question || '';
            const answer = result.data.Answer || '';
            const dateStr = formatDate(result.triviaDate);
            
            // Highlight search terms
            const highlightedQuestion = highlightSearchTerms(question, currentQuery);
            const highlightedAnswer = highlightSearchTerms(answer, currentQuery);
            
            row.innerHTML = `
                <td>
                    <div class="relevance-score">${Math.round(result.relevanceScore)}</div>
                </td>
                <td><strong>#${result.triviaNumber}</strong></td>
                <td>${escapeHTML(dateStr)}</td>
                <td>R${result.round}</td>
                <td>${escapeHTML(result.format)}</td>
                <td class="question-text">${highlightedQuestion}</td>
                <td class="question-text">${highlightedAnswer}</td>
                <td>
                    ${createMediaPreview(result.data)}
                </td>
            `;
            
            // Add click handler for row details
            row.addEventListener('click', (e) => {
                if (!e.target.closest('a, iframe, img')) {
                    showQuestionDetails(result);
                }
            });
            
            return row;
        }
        
        function highlightSearchTerms(text, query) {
            if (!text || !query) return escapeHTML(text);
            
            const words = query.toLowerCase().split(/\s+/).filter(w => w.length > 2);
            let highlighted = escapeHTML(text);
            
            for (const word of words) {
                const regex = new RegExp(`\\b(${escapeRegex(word)})\\b`, 'gi');
                highlighted = highlighted.replace(regex, '<span class="highlighted">$1</span>');
            }
            
            return highlighted;
        }
        
        function createMediaPreview(data) {
            const items = [];
            
            if (data['Image Link']) {
                items.push(`<a href="${escapeHTML(data['Image Link'])}" target="_blank">🖼️ Image</a>`);
            }
            
            if (data['Answer Image Link']) {
                items.push(`<a href="${escapeHTML(data['Answer Image Link'])}" target="_blank">🖼️ Answer</a>`);
            }
            
            if (data['Music Clip Link']) {
                items.push(`<a href="${escapeHTML(data['Music Clip Link'])}" target="_blank">🎵 Audio</a>`);
            }
            
            return items.join('<br>');
        }
        
        function updateSearchStats(result) {
            resultsCount.textContent = result.results.length.toLocaleString();
            searchTime.textContent = `Search completed in ${Math.round(result.searchTime)}ms`;
            
            if (result.fromCache) {
                cachedIndicator.classList.remove('hidden');
            } else {
                cachedIndicator.classList.add('hidden');
            }
        }
        
        function showSuggestions(query) {
            const suggestions = searchEngine.getSuggestions(query);
            
            if (suggestions.length === 0) {
                hideSuggestions();
                return;
            }
            
            searchSuggestions.innerHTML = suggestions.map(s => `
                <div class="suggestion-item" data-suggestion="${escapeHTML(s.text)}">
                    <span>${escapeHTML(s.text)}</span>
                    <span class="suggestion-count">${s.count}</span>
                </div>
            `).join('');
            
            searchSuggestions.style.display = 'block';
            
            // Add click handlers
            searchSuggestions.querySelectorAll('.suggestion-item').forEach(item => {
                item.addEventListener('click', () => {
                    searchQuery.value = item.dataset.suggestion;
                    hideSuggestions();
                    performSearch();
                });
            });
        }
        
        function hideSuggestions() {
            searchSuggestions.style.display = 'none';
        }
        
        function setLoadingState(loading) {
            const btnText = document.querySelector('.search-btn-text');
            
            if (loading) {
                btnText.textContent = 'Searching...';
                searchSpinner.classList.remove('hidden');
                searchBtn.disabled = true;
            } else {
                btnText.textContent = 'Search';
                searchSpinner.classList.add('hidden');
                searchBtn.disabled = false;
            }
        }
        
        function clearResults() {
            resultsBody.innerHTML = '';
            searchStats.classList.add('hidden');
            noResults.classList.add('hidden');
            currentResults = [];
            currentQuery = '';
        }
        
        function showError(message) {
            // Implement error display
            console.error(message);
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            try {
                let date;
                if (/^\d{8}$/.test(dateStr)) {
                    const year = dateStr.substring(0, 4);
                    const month = dateStr.substring(4, 6);
                    const day = dateStr.substring(6, 8);
                    date = new Date(`${year}-${month}-${day}`);
                } else {
                    date = new Date(dateStr);
                }
                
                if (isNaN(date.getTime())) return dateStr;
                
                return date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            } catch (e) {
                return dateStr;
            }
        }
        
        function escapeHTML(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function showQuestionDetails(result) {
            // Implement modal for question details
            console.log('Show details for:', result);
        }
        
        // Authentication check
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                try {
                    const snapshot = await db.ref(`users/${user.uid}`).once('value');
                    const userData = snapshot.val() || {};
                    
                    const isAdmin = 
                        (userData.roles && Array.isArray(userData.roles) && userData.roles.includes('admin')) ||
                        (userData.role === 'admin');
                    
                    const hasToolsAccess =
                        (userData.roles && Array.isArray(userData.roles) && userData.roles.includes('tools')) ||
                        (userData.role === 'tools');
                    
                    if (isAdmin || hasToolsAccess) {
                        authScreen.classList.add('hidden');
                        searchScreen.classList.remove('hidden');
                        
                        // Initialize the search engine
                        await searchEngine.loadSearchIndex();
                        
                        // Check for URL parameters
                        const urlParams = new URLSearchParams(window.location.search);
                        const searchParam = urlParams.get('q');
                        const autoSubmit = urlParams.get('autosubmit') === 'true';
                        
                        if (searchParam) {
                            searchQuery.value = searchParam;
                            searchClear.classList.add('visible');
                            
                            if (autoSubmit) {
                                await performSearch();
                            }
                        }
                        
                    } else {
                        authScreen.classList.remove('hidden');
                        searchScreen.classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Error checking user role:', error);
                    authScreen.classList.remove('hidden');
                    searchScreen.classList.add('hidden');
                }
            } else {
                authScreen.classList.remove('hidden');
                searchScreen.classList.add('hidden');
            }
        });
        
        // Show analytics on development
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            document.getElementById('search-analytics').style.display = 'block';
        }
        
        console.log('🚀 Enhanced Trivia Search Engine loaded successfully!');
        
    </script>
</body>
</html> 