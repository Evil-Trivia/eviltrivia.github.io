<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evil Trivia - Search Archive</title>
    <script src="/js/components/autoload-banner.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #FFCC00;
            margin-top: 60px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .search-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .search-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .search-input {
            flex-grow: 1;
            min-width: 250px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            min-width: 150px;
        }
        
        button {
            background-color: #000;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #333;
        }
        
        .filter-section {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }
        
        .filter-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        .results-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .results-count {
            font-weight: bold;
            color: #333;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .results-table th, .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }
        
        .results-table th {
            background-color: #f5f5f5;
            color: #333;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .results-table tr:hover {
            background-color: #f9f9f9;
            cursor: pointer;
        }
        
        .load-more {
            text-align: center;
            margin-top: 20px;
        }
        
        .question-text {
            max-width: 375px;
            min-height: 40px;
            max-height: 120px;
            overflow-y: auto;
            white-space: normal;
            line-height: 1.4;
        }
        
        .iframe-container {
            width: 250px;
            height: 180px;
            overflow: hidden;
            border-radius: 4px;
            margin-bottom: 4px;
            position: relative;
        }
        
        .iframe-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .image-preview {
            width: 250px;
            height: 180px;
            object-fit: contain;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        
        .image-preview:hover {
            border-color: #999;
        }
        
        .image-link {
            display: block;
            font-size: 12px;
            color: #555;
            text-decoration: none;
            margin-top: 2px;
        }
        
        .image-link:hover {
            text-decoration: underline;
        }
        
        .filter-toggle {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .filter-group-label {
            font-weight: bold;
            width: 100%;
            margin-bottom: 5px;
            color: #555;
        }
        
        .filter-button {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
        }
        
        .filter-button.active {
            background-color: #000;
            color: white;
        }
        
        .filter-button:hover {
            background-color: #333;
            color: white;
        }
        
        .only-button {
            background-color: #888;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 5px;
            margin-left: 5px;
            font-size: 11px;
            cursor: pointer;
            opacity: 0.7;
        }
        
        .only-button:hover {
            opacity: 1;
        }
        
        .no-results {
            text-align: center;
            padding: 40px 0;
            color: #666;
            font-style: italic;
        }
        
        .end-results {
            text-align: center;
            padding: 20px 0;
            color: #666;
            font-style: italic;
            border-top: 1px solid #eee;
            margin-top: 20px;
        }
        
        .image-container {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .auth-container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            margin: 40px auto;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .auth-container h2 {
            margin-top: 0;
            color: #333;
        }
        
        .auth-container p {
            margin-bottom: 20px;
            color: #666;
        }
        
        .auth-btn {
            display: inline-block;
            background-color: #000;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .hidden {
            display: none;
        }

        .search-help {
            margin-top: 10px;
            font-size: 0.85rem;
            color: #666;
        }

        .search-help code {
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .filter-dropdown {
            position: relative;
            display: inline-block;
            min-width: 200px;
        }
        
        .filter-dropdown-header {
            padding: 10px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 250px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            padding: 10px;
            z-index: 20;
            max-height: 400px;
            overflow-y: auto;
            border-radius: 4px;
        }
        
        .filter-dropdown.open .filter-dropdown-content {
            display: block;
        }
        
        .filter-option {
            padding: 8px 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .filter-option:hover {
            background-color: #f5f5f5;
        }
        
        .filter-option input[type="checkbox"] {
            margin-right: 10px;
        }
        
        .filter-option-label {
            flex-grow: 1;
        }
        
        .only-option {
            color: #555;
            font-size: 12px;
            margin-left: 5px;
            cursor: pointer;
            opacity: 0.7;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .only-option:hover {
            background-color: #eee;
            color: #000;
            opacity: 1;
        }
        
        .filter-search {
            padding: 5px 8px;
            margin-bottom: 10px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .filter-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }
        
        .filter-count {
            display: inline-block;
            background-color: #f0f0f0;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 12px;
            margin-left: 5px;
        }
        
        #search-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 30px;
            font-size: 16px;
            color: #666;
        }
        
        #search-loading::after {
            content: "";
            width: 20px;
            height: 20px;
            margin-left: 10px;
            border-radius: 50%;
            border: 3px solid #ddd;
            border-top-color: #000;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        .results-table th:nth-child(1),
        .results-table td:nth-child(1) {
            width: 70px;  /* Trivia # */
        }
        
        .results-table th:nth-child(2),
        .results-table td:nth-child(2) {
            width: 80px;  /* Date */
        }
        
        .results-table th:nth-child(3),
        .results-table td:nth-child(3) {
            width: 60px;  /* Round */
        }
        
        .results-table th:nth-child(4),
        .results-table td:nth-child(4) {
            width: 130px;  /* Round Name - make narrower */
        }
        
        .results-table th:nth-child(5),
        .results-table td:nth-child(5) {
            width: 180px;  /* Round Instruction - make wider */
            max-width: 250px; /* Add max-width to allow for responsive behavior */
            min-width: 150px; /* Set a minimum width */
        }
        
        /* Make the Round Instruction content behave like the Question field */
        .results-table td:nth-child(5) {
            overflow-y: auto;
            white-space: normal;
            line-height: 1.4;
        }
        
        .results-table th:nth-child(6),
        .results-table td:nth-child(6) {
            width: 80px;  /* Format */
        }
        
        /* Improved mobile responsiveness */
        @media (max-width: 768px) {
            .container {
                max-width: 100%;
                padding: 10px;
            }
            
            .search-container, 
            .results-container {
                padding: 15px;
            }
            
            .search-row {
                flex-direction: column;
                gap: 10px;
            }
            
            .search-input {
                width: 100%;
            }
            
            .filter-section {
                flex-direction: column;
                gap: 10px;
            }
            
            .filter-group {
                width: 100%;
            }
            
            /* Make table horizontally scrollable on mobile */
            .table-responsive {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin-bottom: 15px;
                white-space: nowrap;
            }
            
            table.results-table {
                font-size: 14px;
                width: 100%;
                min-width: 500px; /* Ensure minimum width for scrolling */
            }
            
            table.results-table td, 
            table.results-table th {
                padding: 8px 5px;
            }
            
            /* Improve question display on mobile */
            .question-dialog-content {
                padding: 10px;
                max-width: 100%;
                width: 95%;
                margin: 10px auto;
            }
            
            .question-dialog-content h2 {
                font-size: 1.2rem;
                margin-top: 0;
            }
            
            .question-dialog-content .info-row {
                flex-direction: column;
                align-items: flex-start;
                margin-bottom: 15px;
            }
            
            /* Optimize loading indicator */
            #search-loading {
                padding: 15px !important;
                margin: 10px auto;
                background-color: rgba(255,255,255,0.8);
                border-radius: 4px;
                font-weight: bold;
            }
            
            /* Hide table view by default on mobile and show cards instead */
            .table-view {
                display: none;
            }
            
            .card-view {
                display: block;
            }
        }
        
        /* Card view styling */
        .card-view {
            display: none; /* Hidden by default on desktop */
        }
        
        .result-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 15px;
            padding: 15px;
            position: relative;
        }
        
        .result-card-header {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        
        .result-card-meta {
            font-size: 0.9rem;
            color: #666;
        }
        
        .result-card-format {
            display: inline-block;
            background-color: #f0f0f0;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 5px;
        }
        
        .result-card-body {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .result-card-section {
            margin-bottom: 10px;
        }
        
        .result-card-section h4 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 1rem;
        }
        
        .result-card-section p {
            margin: 0;
            line-height: 1.4;
        }
        
        .result-card-images {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .result-card-image {
            width: 100%;
            max-width: 250px;
        }
        
        .view-toggle {
            display: flex;
            align-items: center;
            margin-left: 15px;
        }
        
        .view-toggle-label {
            margin-right: 10px;
            font-size: 14px;
            color: #666;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #000;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(32px);
        }
        
        .view-icons {
            display: flex;
            gap: 5px;
            align-items: center;
            font-size: 12px;
        }
        
        .toggle-icon {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Trivia Question Archive Search</h1>
        
        <!-- Authentication Required Screen -->
        <div id="auth-screen" class="auth-container hidden">
            <h2>Access Required</h2>
            <p>You need admin or tools privileges to access this page.</p>
            <a href="/account" class="auth-btn">Go to Account Page</a>
        </div>
        
        <!-- Search Interface -->
        <div id="search-screen" class="hidden">
            <div class="search-container">
                <div class="search-row">
                    <div class="search-input">
                        <input type="text" id="search-query" placeholder="Search for questions or answers...">
                        <div class="search-help">
                            Supports wildcards: <code>*</code> for any number of characters, <code>?</code> for a single character
                        </div>
                    </div>
                    <button id="search-btn">Search</button>
                </div>
                
                <div class="filter-section">
                    <div class="filter-group">
                        <label>Format</label>
                        <div class="filter-dropdown" id="format-dropdown">
                            <div class="filter-dropdown-header">
                                <span>All Formats</span>
                                <span class="filter-count">0</span>
                                <span>â–¼</span>
                            </div>
                            <div class="filter-dropdown-content">
                                <input type="text" class="filter-search" placeholder="Search formats...">
                                <div class="filter-options" id="format-options">
                                    <!-- Format options will be populated dynamically -->
                                </div>
                                <div class="filter-actions">
                                    <button class="select-all-btn">Select All</button>
                                    <button class="clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Field</label>
                        <div class="filter-dropdown" id="field-dropdown">
                            <div class="filter-dropdown-header">
                                <span>All Fields</span>
                                <span class="filter-count">0</span>
                                <span>â–¼</span>
                            </div>
                            <div class="filter-dropdown-content">
                                <input type="text" class="filter-search" placeholder="Search fields...">
                                <div class="filter-options" id="field-options">
                                    <!-- Field options will be populated dynamically -->
                                </div>
                                <div class="filter-actions">
                                    <button class="select-all-btn">Select All</button>
                                    <button class="clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Removing the sort filter as requested -->
                </div>
            </div>
            
            <div class="results-container">
                <div class="results-header">
                    <div class="results-count">Showing <span id="results-count">0</span> results</div>
                    
                    <!-- Add view toggle switch -->
                    <div class="view-toggle">
                        <div class="view-toggle-label">View:</div>
                        <div class="view-icons">
                            <span class="toggle-icon">ðŸ“Š</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="view-toggle">
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-icon">ðŸ“±</span>
                        </div>
                    </div>
                    
                    <button id="clear-btn">Clear Results</button>
                </div>
                
                <!-- Table View -->
                <div class="table-view">
                    <div class="table-responsive">
                        <table class="results-table">
                            <thead>
                                <tr>
                                    <th>Trivia #</th>
                                    <th>Date</th>
                                    <th>Round</th>
                                    <th>Round Name</th>
                                    <th>Round Instruction</th>
                                    <th>Format</th>
                                    <th>Question</th>
                                    <th>Answer</th>
                                    <th>Question Image</th>
                                    <th>Answer Image</th>
                                </tr>
                            </thead>
                            <tbody id="results-body">
                                <!-- Results will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Card View -->
                <div class="card-view">
                    <div id="card-results">
                        <!-- Card results will be populated here -->
                    </div>
                </div>
                
                <div id="no-results" class="no-results hidden">
                    <p>No matching questions found. Try adjusting your search criteria.</p>
                </div>
                
                <div id="end-results" class="no-results hidden">
                    <p>End of results. No more questions to display.</p>
                </div>
                
                <div class="load-more hidden" id="load-more">
                    <button id="load-more-btn">Load More Results</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
    
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
            authDomain: "eviltrivia-47664.firebaseapp.com",
            databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
            projectId: "eviltrivia-47664",
            storageBucket: "eviltrivia-47664.firebasestorage.app",
            messagingSenderId: "401826818140",
            appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
            measurementId: "G-2W6RK96Y34"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();
        
        // DOM Elements
        const authScreen = document.getElementById('auth-screen');
        const searchScreen = document.getElementById('search-screen');
        const searchQuery = document.getElementById('search-query');
        const searchBtn = document.getElementById('search-btn');
        const clearBtn = document.getElementById('clear-btn');
        const formatDropdown = document.getElementById('format-dropdown');
        const fieldDropdown = document.getElementById('field-dropdown');
        const formatOptions = document.getElementById('format-options');
        const fieldOptions = document.getElementById('field-options');
        const resultsBody = document.getElementById('results-body');
        const cardResults = document.getElementById('card-results');
        const noResults = document.getElementById('no-results');
        const endResults = document.getElementById('end-results');
        const resultsCount = document.getElementById('results-count');
        const loadMoreSection = document.getElementById('load-more');
        const loadMoreBtn = document.getElementById('load-more-btn');
        const viewToggle = document.getElementById('view-toggle');
        const tableView = document.querySelector('.table-view');
        const cardView = document.querySelector('.card-view');
        
        // Search state
        let currentSearch = {
            query: '',
            formats: [],
            rounds: [], // Kept for backward compatibility
            fields: [],
            sort: 'newest', // Always use newest first
            lastKey: null,
            results: [],
            hasMore: false,
            endReached: false,
            useExactMatch: false, // Add new flag for exact matching
            resultCount: 0 // Add a counter to track total results processed
        };

        // Store metadata about the database
        const dbMetadata = {
            rounds: new Set(),
            formats: new Set(),
            fields: new Set()
        };

        // Initialize the page
        async function initializePage() {
            await loadDatabaseMetadata();
            populateFilterDropdowns();
        }

        // Load metadata about database structure
        async function loadDatabaseMetadata() {
            try {
                // Get a sample of the archive to extract structure
                const archiveRef = db.ref('trivia-archive/archive');
                const snapshot = await archiveRef.limitToLast(3).once('value');
                const data = snapshot.val();
                
                if (!data) return;
                
                console.log('Loading metadata from sample data...');
                
                // Process each trivia set to extract rounds and formats
                for (const [triviaNumber, triviaSet] of Object.entries(data)) {
                    if (!triviaSet.trivia) continue;
                    
                    // Extract rounds
                    for (const roundKey of Object.keys(triviaSet.trivia)) {
                        if (typeof triviaSet.trivia[roundKey] !== 'object') continue;
                        dbMetadata.rounds.add(roundKey);
                        
                        // Extract formats for each round
                        const round = triviaSet.trivia[roundKey];
                        for (const formatKey of Object.keys(round)) {
                            if (typeof round[formatKey] !== 'object') continue;
                            dbMetadata.formats.add(formatKey);
                            
                            // Extract fields from a sample question
                            const format = round[formatKey];
                            // Find a question
                            for (const qKey of Object.keys(format)) {
                                const question = format[qKey];
                                if (typeof question === 'object' && question !== null) {
                                    // Extract field names
                                    for (const fieldName of Object.keys(question)) {
                                        dbMetadata.fields.add(fieldName);
                                    }
                                    break; // Just need one question for fields
                                }
                            }
                        }
                    }
                }
                
                console.log('Database metadata loaded:', {
                    rounds: Array.from(dbMetadata.rounds),
                    formats: Array.from(dbMetadata.formats),
                    fields: Array.from(dbMetadata.fields)
                });
            } catch (error) {
                console.error('Error loading database metadata:', error);
            }
        }

        // Populate dropdowns with database values
        function populateFilterDropdowns() {
            // Populate format filter
            const formatOptionsArray = Array.from(dbMetadata.formats).sort();
            formatOptions.innerHTML = '';
            for (const format of formatOptionsArray) {
                addFilterOption(formatOptions, format, format, 'formats');
            }
            
            // Populate field filter
            const commonFields = ['Question', 'Answer', 'Hidden Structure_Theme', 'Round Name', 'Round Instruction'];
            const allFields = new Set([...commonFields, ...dbMetadata.fields]);
            const fieldOptionsArray = Array.from(allFields).sort();
            
            fieldOptions.innerHTML = '';
            for (const field of fieldOptionsArray) {
                // Skip internal fields or fields with no valuable search content
                if (field === 'uid' || field === 'id' || field === 'createdAt' || field === 'updatedAt') continue;
                
                addFilterOption(fieldOptions, field, field.replace(/_/g, ' '), 'fields');
            }
            
            // Add dropdown toggle behavior
            setupDropdowns();
        }
        
        // Add a single filter option with checkbox and "only" option
        function addFilterOption(container, value, displayText, filterType) {
            const option = document.createElement('div');
            option.className = 'filter-option';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = value;
            checkbox.id = `${filterType}-${value}`;
            checkbox.addEventListener('change', () => updateFilterSelection(filterType));
            
            const label = document.createElement('label');
            label.className = 'filter-option-label';
            label.textContent = displayText;
            label.htmlFor = checkbox.id;
            
            const onlyBtn = document.createElement('span');
            onlyBtn.className = 'only-option';
            onlyBtn.textContent = 'only';
            onlyBtn.title = `Show only ${displayText}`;
            onlyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                setOnlyFilter(value, filterType);
            });
            
            option.appendChild(checkbox);
            option.appendChild(label);
            option.appendChild(onlyBtn);
            container.appendChild(option);
        }
        
        // Setup the dropdowns (toggle open/close and filter search)
        function setupDropdowns() {
            const dropdowns = document.querySelectorAll('.filter-dropdown');
            
            dropdowns.forEach(dropdown => {
                const header = dropdown.querySelector('.filter-dropdown-header');
                const content = dropdown.querySelector('.filter-dropdown-content');
                const search = dropdown.querySelector('.filter-search');
                const options = dropdown.querySelector('.filter-options');
                const selectAllBtn = dropdown.querySelector('.select-all-btn');
                const clearBtn = dropdown.querySelector('.clear-btn');
                
                // Toggle dropdown
                header.addEventListener('click', () => {
                    dropdowns.forEach(d => {
                        if (d !== dropdown) {
                            d.classList.remove('open');
                        }
                    });
                    dropdown.classList.toggle('open');
                });
                
                // Filter options on search
                if (search) {
                    search.addEventListener('input', () => {
                        const query = search.value.toLowerCase();
                        const optionElements = options.querySelectorAll('.filter-option');
                        
                        optionElements.forEach(option => {
                            const text = option.textContent.toLowerCase();
                            if (text.includes(query)) {
                                option.style.display = 'flex';
                            } else {
                                option.style.display = 'none';
                            }
                        });
                    });
                }
                
                // Select all button
                if (selectAllBtn) {
                    selectAllBtn.addEventListener('click', () => {
                        const checkboxes = options.querySelectorAll('input[type="checkbox"]');
                        checkboxes.forEach(cb => {
                            cb.checked = true;
                        });
                        
                        // Get the filter type
                        let filterType;
                        if (dropdown.id === 'format-dropdown') filterType = 'formats';
                        else if (dropdown.id === 'field-dropdown') filterType = 'fields';
                        
                        updateFilterSelection(filterType);
                    });
                }
                
                // Clear all button
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        const checkboxes = options.querySelectorAll('input[type="checkbox"]');
                        checkboxes.forEach(cb => {
                            cb.checked = false;
                        });
                        
                        // Get the filter type
                        let filterType;
                        if (dropdown.id === 'format-dropdown') filterType = 'formats';
                        else if (dropdown.id === 'field-dropdown') filterType = 'fields';
                        
                        updateFilterSelection(filterType);
                    });
                }
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.filter-dropdown')) {
                    dropdowns.forEach(d => d.classList.remove('open'));
                }
            });
        }
        
        // Update filter selection based on checkboxes
        function updateFilterSelection(filterType) {
            let container, headerText, countElement;
            
            // Get corresponding elements
            if (filterType === 'formats') {
                container = formatOptions;
                headerText = formatDropdown.querySelector('.filter-dropdown-header span:first-child');
                countElement = formatDropdown.querySelector('.filter-count');
            } else if (filterType === 'fields') {
                container = fieldOptions;
                headerText = fieldDropdown.querySelector('.filter-dropdown-header span:first-child');
                countElement = fieldDropdown.querySelector('.filter-count');
            }
            
            // Get checked values
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const values = Array.from(checkboxes).map(cb => cb.value);
            
            // Update search state
            currentSearch[filterType] = values;
            
            // Update header text
            const selectionCount = values.length;
            if (selectionCount === 0) {
                headerText.textContent = filterType === 'formats' ? 'All Formats' : 'All Fields';
                countElement.textContent = '';
                countElement.style.display = 'none';
            } else {
                headerText.textContent = selectionCount === 1 ? 
                    checkboxes[0].nextElementSibling.textContent :
                    `Multiple ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}`;
                countElement.textContent = selectionCount;
                countElement.style.display = 'inline-block';
            }
        }
        
        // Set a filter to "only" this value
        function setOnlyFilter(value, filterType) {
            let container;
            
            // Get corresponding container
            if (filterType === 'formats') {
                container = formatOptions;
            } else if (filterType === 'fields') {
                container = fieldOptions;
            }
            
            // Uncheck all checkboxes
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = cb.value === value;
            });
            
            // Update filter selection
            updateFilterSelection(filterType);
        }

        // Search function
        async function searchQuestions() {
            // Update search state for query and sort
            currentSearch.query = searchQuery.value.trim();
            currentSearch.sort = 'newest'; // Always use newest first
            currentSearch.lastKey = null;
            currentSearch.results = [];
            currentSearch.resultCount = 0; // Add a counter to track total results processed
            
            // Determine if we should use exact matching (no wildcards)
            const hasWildcards = currentSearch.query.includes('*') || currentSearch.query.includes('?');
            currentSearch.useExactMatch = !hasWildcards;
            
            console.log('Search mode:', currentSearch.useExactMatch ? 'Exact match' : 'Wildcard match');
            
            // Clear previous results
            resultsBody.innerHTML = '';
            cardResults.innerHTML = '';
            noResults.classList.add('hidden');
            endResults.classList.add('hidden');
            loadMoreSection.classList.add('hidden');
            
            // Perform search
            await loadQuestions();
        }
        
        // Smarter batch loading function
        async function loadSmartQuestionBatch(loadMore = false) {
            // Get reference to trivia-archive
            const archiveRef = db.ref('trivia-archive/archive');
            
            // Check for wildcard searches that might return too many results
            const query = currentSearch.query;
            if (!loadMore && (query === '*' || query === '*a*' || query === '*e*' || query === '*i*' || 
                query === '*o*' || query === '*u*' || query === '* *')) {
                console.log('Search query would return too many results, limiting batch size');
                // For these searches, display a warning and limit results
                const warningDiv = document.createElement('div');
                warningDiv.className = 'warning-message';
                warningDiv.style.padding = '10px';
                warningDiv.style.backgroundColor = '#fff3cd';
                warningDiv.style.color = '#856404';
                warningDiv.style.borderRadius = '4px';
                warningDiv.style.marginBottom = '15px';
                warningDiv.textContent = 'Your search matches many results. Only showing 50 results at a time. Please use a more specific search term for better results.';
                
                // Check if warning is already present
                const existingWarning = document.querySelector('.warning-message');
                if (!existingWarning) {
                    // Insert the warning before the results table
                    const resultsContainer = document.querySelector('.results-container');
                    if (resultsContainer) {
                        resultsContainer.insertBefore(warningDiv, resultsContainer.firstChild);
                    }
                }
            }
            
            // For the initial load, we will get a large batch of trivia sets at once
            // This is much more efficient than loading one set at a time
            const batchSize = 30; // Load 30 trivia sets at once
            
            // Start by querying trivia numbers (sort by key in reverse for newest first)
            let triviaQuery = archiveRef.orderByKey();
            
            if (currentSearch.sort === 'newest') {
                // For newest first, we start at the end and move backward
                if (loadMore && currentSearch.lastKey) {
                    // When loading more in newest-first mode, we need to get records OLDER than the last one
                    // So we use endBefore to get records with keys up to (but not including) the last key
                    triviaQuery = triviaQuery.endBefore(currentSearch.lastKey);
                    console.log(`Loading more trivia before key ${currentSearch.lastKey}`);
                }
                triviaQuery = triviaQuery.limitToLast(batchSize);
            } else {
                // For oldest first, we start at the beginning and move forward
                if (loadMore && currentSearch.lastKey) {
                    // When loading more in oldest-first mode, we need to get records NEWER than the last one
                    // So we use startAfter to get records with keys after the last key
                    triviaQuery = triviaQuery.startAfter(currentSearch.lastKey);
                    console.log(`Loading more trivia after key ${currentSearch.lastKey}`);
                }
                triviaQuery = triviaQuery.limitToFirst(batchSize);
            }
            
            // Get trivia numbers
            console.log(`Loading batch of up to ${batchSize} trivia sets...`);
            const triviaSnap = await triviaQuery.once('value');
            const triviaData = triviaSnap.val();
            
            if (!triviaData) {
                // No trivia found
                console.log('No trivia data found');
                if (!loadMore) {
                    noResults.classList.remove('hidden');
                    resultsCount.textContent = '0';
                }
                loadMoreSection.classList.add('hidden');
                currentSearch.endReached = true;
                return [];
            }
            
            // Convert to array and sort
            let triviaItems = Object.entries(triviaData).map(([triviaNumber, data]) => ({
                triviaNumber,
                data
            }));
            
            // Sort by trivia number (newest first or oldest first)
            if (currentSearch.sort === 'newest') {
                triviaItems.sort((a, b) => b.triviaNumber.localeCompare(a.triviaNumber));
            } else {
                triviaItems.sort((a, b) => a.triviaNumber.localeCompare(b.triviaNumber));
            }
            
            console.log(`Processing ${triviaItems.length} trivia items...`);
            
            // Create an array of promises to process each trivia set in parallel
            // This significantly speeds up the search process
            const processPromises = [];
            
            // Process each trivia item
            for (const item of triviaItems) {
                processPromises.push(processTrivia(item));
            }
            
            // Wait for all processing to complete
            const resultsArrays = await Promise.all(processPromises);
            
            // Flatten results array
            let results = resultsArrays.flat();
            
            // If there are no results at all but we have trivia items, we need to try loading more
            if (results.length === 0 && triviaItems.length > 0) {
                // There are more trivia items but no matching results in this batch
                // Set the last key for the next pagination attempt
                const lastItem = triviaItems[triviaItems.length - 1];
                currentSearch.lastKey = lastItem.triviaNumber;
                console.log(`No matching results in this batch. Setting last key to ${currentSearch.lastKey} for next attempt`);
                
                // If we're already loading more data, recursively try to load more
                if (loadMore) {
                    console.log("Automatically loading next batch since no results were found in this batch");
                    return loadSmartQuestionBatch(true);
                } else {
                    // For initial search, just show no results
                    currentSearch.endReached = true;
                    return [];
                }
            }
            
            // If we actually found results, update the last key from the current batch
            if (triviaItems.length > 0) {
                const lastItem = triviaItems[triviaItems.length - 1];
                currentSearch.lastKey = lastItem.triviaNumber;
                console.log(`Setting last key to ${currentSearch.lastKey} for next pagination`);
            }
            
            // Always limit results to exactly 50 per page
            const maxResultsPerPage = 50;
            
            if (results.length > maxResultsPerPage) {
                console.log(`Limiting results from ${results.length} to ${maxResultsPerPage} for this page`);
                results = results.slice(0, maxResultsPerPage);
                // Always set hasMore to true if we had to limit the results
                currentSearch.hasMore = true;
            } else if (triviaItems.length >= (batchSize - 5) && !currentSearch.endReached) {
                // There might be more results in the database if we got close to a full batch
                console.log("Setting hasMore to true since we might have more trivia in the database");
                currentSearch.hasMore = true;
            } else {
                // We didn't fill a page and didn't get close to a full batch, so probably no more results
                currentSearch.hasMore = false;
            }
            
            // Increment the result counter
            const prevResultCount = currentSearch.resultCount || 0;
            currentSearch.resultCount = prevResultCount + results.length;
            
            return results;
        }
        
        // Load questions from Firebase
        async function loadQuestions(loadMore = false) {
            try {
                if (!loadMore) {
                    // New search, reset results
                    currentSearch.results = [];
                    currentSearch.lastKey = null;
                    currentSearch.endReached = false;
                    currentSearch.resultCount = 0; // Reset counter for new search
                    endResults.classList.add('hidden');
                    
                    // Remove any existing warning messages
                    const existingWarning = document.querySelector('.warning-message');
                    if (existingWarning) {
                        existingWarning.remove();
                    }
                }
                
                // Don't try to load more if we've already reached the end
                if (currentSearch.endReached) {
                    console.log('Already reached end of results');
                    return;
                }
                
                // Log for debugging
                console.log('Starting search with query:', currentSearch.query);
                console.log('Search filters:', {
                    formats: currentSearch.formats,
                    fields: currentSearch.fields,
                    sort: currentSearch.sort
                });
                
                // Show loading indicator
                const loadingIndicator = document.createElement('div');
                loadingIndicator.id = 'search-loading';
                loadingIndicator.textContent = 'Searching...';
                loadingIndicator.style.textAlign = 'center';
                loadingIndicator.style.padding = '20px';
                loadingIndicator.style.color = '#666';
                
                if (!loadMore) {
                    resultsBody.innerHTML = '';
                    cardResults.innerHTML = '';
                    resultsBody.appendChild(loadingIndicator);
                } else {
                    loadMoreBtn.disabled = true;
                    loadMoreBtn.textContent = 'Loading...';
                }
                
                // Use a smarter approach for loading data
                // Instead of loading trivia sets one by one, load a larger chunk at once
                const results = await loadSmartQuestionBatch(loadMore);
                
                // Remove loading indicator
                const existingLoadingIndicator = document.getElementById('search-loading');
                if (existingLoadingIndicator) {
                    existingLoadingIndicator.remove();
                }
                if (loadMore) {
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.textContent = 'Load More Results';
                }
                
                // Update display
                displayResults(results, loadMore);
                
                // Show end of results message if appropriate
                if (currentSearch.endReached) {
                    endResults.classList.remove('hidden');
                    loadMoreSection.classList.add('hidden');
                } else if (currentSearch.hasMore) {
                    // Show load more button if there are potentially more results
                    endResults.classList.add('hidden');
                    loadMoreSection.classList.remove('hidden');
                } else {
                    // No more results but not officially at the end (e.g., if we have exactly 50 results)
                    endResults.classList.remove('hidden');
                    loadMoreSection.classList.add('hidden');
                }
                
            } catch (error) {
                console.error('Error searching questions:', error);
                // Remove loading indicator on error
                const existingLoadingIndicator = document.getElementById('search-loading');
                if (existingLoadingIndicator) {
                    existingLoadingIndicator.remove();
                }
                if (loadMore) {
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.textContent = 'Load More Results';
                }
            }
        }
        
        // Define fieldMatches function once at this level
        const fieldMatches = (fieldName, fieldValue, regexPattern, searchQuery, useExactMatch, forceVerbose = false) => {
            if (!fieldValue || (typeof fieldValue !== 'string' && typeof fieldValue !== 'number')) {
                return false;
            }
            
            const textValue = String(fieldValue).toLowerCase();
            const queryLower = searchQuery.toLowerCase();
            
            // Log for debugging (with forceVerbose flag)
            if (forceVerbose) {
                console.log(`Checking field ${fieldName} with value "${textValue}" against "${queryLower}"`);
            }
            
            // If using regex pattern with wildcards
            if (regexPattern) {
                // Test with the regex pattern
                const matches = regexPattern.test(textValue);
                if (matches) {
                    console.log(`SUCCESS! RegEx match: "${searchQuery}" matches "${textValue}" (field: ${fieldName})`);
                    return true;
                }
                
                // Return false if we have a regex pattern but it didn't match
                // This ensures wildcard searches are handled exclusively by the regex
                return false;
            }
            
            // If exact matching is requested (no wildcards used)
            if (useExactMatch) {
                // Check for exact match of the entire string or for word boundaries
                const exactMatch = textValue === queryLower;
                const wordMatch = new RegExp(`\\b${escapeRegExp(queryLower)}\\b`).test(textValue);
                
                if (exactMatch || wordMatch) {
                    console.log(`SUCCESS! Exact match: "${searchQuery}" found in "${textValue}" (field: ${fieldName})`);
                    return true;
                }
            } else {
                // Default: Simple substring match for searches without wildcards that don't need to be exact
                if (textValue.includes(queryLower)) {
                    console.log(`SUCCESS! Simple substring match: "${queryLower}" found in "${textValue}" (field: ${fieldName})`);
                    return true;
                }
            }
            
            return false;
        };
        
        // Convert wildcards to regex pattern
        function wildcardToRegExp(s) {
            if (!s || typeof s !== 'string') {
                return null;
            }
            
            // Escape special regex chars except * and ?
            let pattern = s.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            
            // Check if the pattern starts and ends with wildcards
            const startsWithWildcard = s.startsWith('*');
            const endsWithWildcard = s.endsWith('*');
            
            // Replace * with .* (any number of characters) and ? with . (exactly one character)
            pattern = pattern.replace(/\*/g, '.*').replace(/\?/g, '.');
            
            // Apply anchors appropriately based on whether wildcards are at beginning/end
            if (!startsWithWildcard) {
                pattern = '^' + pattern;
            }
            if (!endsWithWildcard) {
                pattern = pattern + '$';
            }
            
            console.log(`Converting "${s}" to regex: ${pattern}`);
            
            // Return RegExp object with case-insensitive flag
            return new RegExp(pattern, 'i');
        }
        
        // Escape special regex characters
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // Process a single trivia set
        async function processTrivia(item) {
            try {
                const results = [];
                
                // First, check if this trivia set has necessary data
                if (!item.data || !item.data.trivia) {
                    return results;
                }
                
                // Get trivia metadata
                const triviaNumber = item.triviaNumber;
                const triviaName = item.data.name || '';
                const triviaDate = item.data.date || '';
                const triviaNode = item.data.trivia;
                
                // Precompute regex pattern if using wildcards
                let regexPattern = null;
                const searchQuery = currentSearch.query.toLowerCase();
                
                if (currentSearch.query && (currentSearch.query.includes('*') || currentSearch.query.includes('?'))) {
                    regexPattern = wildcardToRegExp(currentSearch.query);
                }
                
                // Go through each round in the trivia set
                for (const roundKey of Object.keys(triviaNode)) {
                    const roundData = triviaNode[roundKey];
                    
                    // Skip non-object values
                    if (typeof roundData !== 'object' || roundData === null) continue;
                    
                    // Try to find a round name
                    let roundName = '';
                    // Check in round data directly
                    if (roundData['Round Name']) {
                        roundName = roundData['Round Name'];
                    } else if (roundData['name']) {
                        roundName = roundData['name'];
                    } else if (roundKey.toLowerCase().includes('final')) {
                        roundName = "Final Round";
                    } else {
                        // Default to a formatted round number
                        roundName = `Round ${roundKey}`;
                    }
                    
                    // Apply format filter early to reduce processing
                    let formatsToProcess = Object.keys(roundData);
                    if (currentSearch.formats.length > 0) {
                        formatsToProcess = formatsToProcess.filter(formatKey => 
                            currentSearch.formats.includes(formatKey));
                        
                        // If no formats match, skip this round
                        if (formatsToProcess.length === 0) {
                            continue;
                        }
                    }
                    
                    // Process each format in the round
                    for (const formatKey of formatsToProcess) {
                        const formatData = roundData[formatKey];
                        
                        // Skip non-object values
                        if (typeof formatData !== 'object' || formatData === null) continue;
                        
                        // Check for round name in the format data as well
                        let formatRoundName = roundName;
                        if (formatData['Round Name']) {
                            formatRoundName = formatData['Round Name'];
                        } else if (formatData['name']) {
                            formatRoundName = formatData['name'];
                        }
                        
                        // Get round level metadata (including Round Type)
                        const roundType = formatData['Round Type'] || '';
                        
                        // Get the correct format from the round format field if available
                        let roundFormat = formatData['Round Format'] || '';
                        
                        // Check for visual rounds in multiple places since format appears inconsistent
                        if (!roundFormat) {
                            if (roundType === 'Visual') {
                                roundFormat = 'Visual';
                            } else if (formatKey === 'Visual') {
                                roundFormat = 'Visual';
                            } else if (formatData['Round Type'] === 'Visual') {
                                roundFormat = 'Visual';
                            }
                        }
                        
                        // Process each question in the format
                        for (const [questionKey, questionData] of Object.entries(formatData)) {
                            // Skip non-object values or non-question keys
                            if (typeof questionData !== 'object' || questionData === null) {
                                continue;
                            }
                            
                            // More permissive check for question keys - accept any keys that might be questions
                            // Only skip keys that are clearly metadata
                            const metadataKeys = ['Round Name', 'Round Type', 'Round Format', 'Round Instruction'];
                            if (metadataKeys.includes(questionKey)) {
                                continue;
                            }
                            
                            // Check for round name in the question data as a last resort
                            let formatRoundNameFinal = formatRoundName;
                            if (questionData['Round Name']) {
                                formatRoundNameFinal = questionData['Round Name'];
                            }
                            
                            // Get question-specific round type if available
                            const questionRoundType = questionData['Round Type'] || roundType;
                            
                            // Check if this question matches our search criteria
                            let matches = false;
                            
                            if (currentSearch.query) {
                                // If searching for a specific field
                                if (currentSearch.fields.length > 0) {
                                    // For field search, check each selected field
                                    for (const field of currentSearch.fields) {
                                        if (fieldMatches(field, questionData[field], regexPattern, searchQuery, currentSearch.useExactMatch)) {
                                            matches = true;
                                            break;
                                        }
                                    }
                                } else {
                                    // Search in all fields
                                    for (const [fieldName, fieldValue] of Object.entries(questionData)) {
                                        if (fieldMatches(fieldName, fieldValue, regexPattern, searchQuery, currentSearch.useExactMatch)) {
                                            matches = true;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                // No query, so it matches if it passes the format filters
                                matches = true;
                            }
                            
                            if (matches) {
                                const resultItem = {
                                    triviaNumber: triviaNumber,
                                    triviaName: triviaName,
                                    triviaDate: triviaDate,
                                    round: roundKey,
                                    roundName: formatRoundNameFinal,
                                    // Use Round Format field for format if available, otherwise use format key
                                    format: roundFormat || formatKey,
                                    roundType: questionRoundType,
                                    questionNum: questionKey,
                                    questionData: questionData
                                };
                                
                                results.push(resultItem);
                            }
                        }
                    }
                }
                
                return results;
            } catch (error) {
                console.error(`Error processing trivia ${item.triviaNumber}:`, error);
                return [];
            }
        }
        
        // Display search results
        function displayResults(results, appendResults = false) {
            if (!appendResults) {
                resultsBody.innerHTML = '';
                cardResults.innerHTML = '';
            }
            
            if (!results.length && !currentSearch.results.length) {
                noResults.classList.remove('hidden');
                resultsCount.textContent = '0';
                return;
            }
            
            // Log results for debugging
            if (currentSearch.query && currentSearch.query.toLowerCase().includes('clockwork')) {
                console.log('Got search results for clockwork:', results);
                
                // Check if we found trivia #81
                const hasTrivia81 = results.some(r => r.triviaNumber === '81');
                console.log('Contains trivia #81:', hasTrivia81);
            }
            
            // Add new results to our state
            currentSearch.results = [...currentSearch.results, ...results];
            
            // Update the display
            noResults.classList.add('hidden');
            
            // Update the results count display
            resultsCount.textContent = currentSearch.results.length;
            
            // Display results in both formats
            displayResultsAsTable(results, appendResults);
            displayResultsAsCards(results, appendResults);
        }
        
        // Display results as table (original format)
        function displayResultsAsTable(results, appendResults = false) {
            if (!appendResults) {
                resultsBody.innerHTML = '';
            }
            
            // Add rows to the table
            results.forEach(result => {
                const row = document.createElement('tr');
                
                // Get the data from the question data
                const question = result.questionData.Question || result.questionData.question || '';
                const answer = result.questionData.Answer || result.questionData.answer || '';
                
                // Format the date nicely if available
                const dateStr = formatDate(result.triviaDate);
                
                // Get image links if available
                const imageLink = result.questionData['Image Link'] || result.questionData['image_link'] || '';
                const answerImageLink = result.questionData['Answer Image Link'] || result.questionData['answer_image_link'] || '';
                
                // Get round instruction if available (might be at various levels)
                let roundInstruction = '';
                
                // Check in question data first
                if (result.questionData['Round Instruction']) {
                    roundInstruction = result.questionData['Round Instruction'];
                }
                
                // Use the actual round format from the data - NOT free drink question text
                // We want to display the format field, which should be the format like "Visual" etc.
                let displayFormat = result.format || '';
                
                // Get actual round type from the result data if available
                const roundType = result.roundType || result.questionData['Round Type'] || '';
                
                // Handle the specific case where we're seeing "Free Drink Question" instead of "Visual"
                // If we have a round type, prioritize it for display
                if (roundType === 'Visual' || displayFormat === 'Visual') {
                    displayFormat = 'Visual';
                } else if (displayFormat === 'Free Drink Question' && roundType) {
                    // Replace "Free Drink Question" with the actual round type if available
                    displayFormat = roundType;
                }
                
                row.innerHTML = `
                    <td>${result.triviaNumber}</td>
                    <td>${escapeHTML(dateStr)}</td>
                    <td>${result.round}</td>
                    <td>${escapeHTML(result.roundName || '')}</td>
                    <td class="question-text">${escapeHTML(roundInstruction)}</td>
                    <td>${escapeHTML(displayFormat)}</td>
                    <td class="question-text">${escapeHTML(question)}</td>
                    <td class="question-text">${escapeHTML(answer)}</td>
                    <td>${createImagePreview(imageLink, 'Question Image')}</td>
                    <td>${createImagePreview(answerImageLink, 'Answer Image')}</td>
                `;
                
                // Add click event to show round details
                row.addEventListener('click', (e) => {
                    // Don't trigger round view when clicking on links or iframes
                    if (e.target.tagName === 'A' || e.target.tagName === 'IFRAME' || e.target.tagName === 'IMG') {
                        return;
                    }
                    showRoundDetails(result.triviaNumber, result.round, result.format, result.roundName);
                });
                
                resultsBody.appendChild(row);
            });
        }
        
        // Display results as cards (mobile-friendly format)
        function displayResultsAsCards(results, appendResults = false) {
            if (!appendResults) {
                cardResults.innerHTML = '';
            }
            
            // Add cards to the container
            results.forEach(result => {
                const card = document.createElement('div');
                card.className = 'result-card';
                
                // Get the data from the question data
                const question = result.questionData.Question || result.questionData.question || '';
                const answer = result.questionData.Answer || result.questionData.answer || '';
                
                // Format the date nicely if available
                const dateStr = formatDate(result.triviaDate);
                
                // Get image links if available
                const imageLink = result.questionData['Image Link'] || result.questionData['image_link'] || '';
                const answerImageLink = result.questionData['Answer Image Link'] || result.questionData['answer_image_link'] || '';
                
                // Get round instruction if available (might be at various levels)
                let roundInstruction = '';
                
                // Check in question data first
                if (result.questionData['Round Instruction']) {
                    roundInstruction = result.questionData['Round Instruction'];
                }
                
                // Use the actual round format from the data
                let displayFormat = result.format || '';
                
                // Get actual round type from the result data if available
                const roundType = result.roundType || result.questionData['Round Type'] || '';
                
                // Handle the specific case where we're seeing "Free Drink Question" instead of "Visual"
                if (roundType === 'Visual' || displayFormat === 'Visual') {
                    displayFormat = 'Visual';
                } else if (displayFormat === 'Free Drink Question' && roundType) {
                    displayFormat = roundType;
                }
                
                // Create the card HTML
                card.innerHTML = `
                    <div class="result-card-header">
                        <div class="result-card-meta">
                            <strong>Trivia #${result.triviaNumber}</strong> | ${escapeHTML(dateStr)} | Round ${result.round}
                            <span class="result-card-format">${escapeHTML(displayFormat)}</span>
                        </div>
                    </div>
                    <div class="result-card-body">
                        <div class="result-card-section">
                            <h4>Round: ${escapeHTML(result.roundName || '')}</h4>
                            ${roundInstruction ? `<p><strong>Instructions:</strong> ${escapeHTML(roundInstruction)}</p>` : ''}
                        </div>
                        
                        <div class="result-card-section">
                            <h4>Question</h4>
                            <p>${escapeHTML(question)}</p>
                        </div>
                        
                        <div class="result-card-section">
                            <h4>Answer</h4>
                            <p>${escapeHTML(answer)}</p>
                        </div>
                        
                        ${(imageLink || answerImageLink) ? `
                        <div class="result-card-images">
                            ${imageLink ? `
                            <div class="result-card-image">
                                <h4>Question Image</h4>
                                ${createImagePreview(imageLink, 'Question Image')}
                            </div>
                            ` : ''}
                            
                            ${answerImageLink ? `
                            <div class="result-card-image">
                                <h4>Answer Image</h4>
                                ${createImagePreview(answerImageLink, 'Answer Image')}
                            </div>
                            ` : ''}
                        </div>
                        ` : ''}
                    </div>
                `;
                
                // Add click event to show round details (same as table rows)
                card.addEventListener('click', (e) => {
                    // Don't trigger round view when clicking on links or iframes
                    if (e.target.tagName === 'A' || e.target.tagName === 'IFRAME' || e.target.tagName === 'IMG') {
                        return;
                    }
                    showRoundDetails(result.triviaNumber, result.round, result.format, result.roundName);
                });
                
                cardResults.appendChild(card);
            });
        }
        
        // Show all questions in a round
        async function showRoundDetails(triviaNumber, roundNumber, format, roundName) {
            try {
                // Create modal element
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                modal.style.display = 'flex';
                modal.style.justifyContent = 'center';
                modal.style.alignItems = 'center';
                modal.style.zIndex = '1000';
                
                // Create loading indicator
                const loading = document.createElement('div');
                loading.textContent = 'Loading round questions...';
                loading.style.color = 'white';
                loading.style.fontSize = '20px';
                modal.appendChild(loading);
                
                // Add to document immediately to show loading state
                document.body.appendChild(modal);
                
                // Fetch round data from Firebase
                const roundRef = db.ref(`trivia-archive/archive/${triviaNumber}/trivia/${roundNumber}/${format}`);
                const snapshot = await roundRef.once('value');
                const roundData = snapshot.val();
                
                // Remove loading indicator
                modal.removeChild(loading);
                
                // Create modal content
                const content = document.createElement('div');
                content.style.backgroundColor = 'white';
                content.style.padding = '30px';
                content.style.borderRadius = '8px';
                content.style.maxWidth = '900px';
                content.style.width = '90%';
                content.style.maxHeight = '85vh';
                content.style.overflowY = 'auto';
                
                // Create header with close button
                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #eee';
                header.style.paddingBottom = '15px';
                
                // Get round type if available
                let roundType = '';
                if (roundData && roundData['Round Type']) {
                    roundType = roundData['Round Type'];
                }
                
                const formatLabel = roundType && roundType !== format ? `${format} (${roundType})` : format;
                
                const title = document.createElement('h2');
                title.style.margin = '0';
                title.innerHTML = `Trivia #${triviaNumber} - ${roundName || `Round ${roundNumber}`} <span style="font-size: 16px; font-weight: normal; color: #666;">Format: ${formatLabel}</span>`;
                
                const closeBtn = document.createElement('button');
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.innerHTML = '&times;';
                closeBtn.style.padding = '0 10px';
                closeBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                
                header.appendChild(title);
                header.appendChild(closeBtn);
                content.appendChild(header);
                
                // If no data found
                if (!roundData) {
                    const noData = document.createElement('p');
                    noData.textContent = 'No questions found for this round.';
                    noData.style.textAlign = 'center';
                    noData.style.color = '#666';
                    noData.style.fontStyle = 'italic';
                    content.appendChild(noData);
                    modal.appendChild(content);
                    return;
                }
                
                // Add round metadata section
                const metadataDiv = document.createElement('div');
                metadataDiv.style.marginBottom = '20px';
                metadataDiv.style.padding = '10px';
                metadataDiv.style.backgroundColor = '#f5f5f5';
                metadataDiv.style.borderRadius = '4px';
                
                // Collect metadata from roundData
                const metadata = [];
                if (roundName) {
                    metadata.push(`<strong>Round Name:</strong> ${escapeHTML(roundName)}`);
                }
                if (roundType) {
                    metadata.push(`<strong>Round Type:</strong> ${escapeHTML(roundType)}`);
                }
                if (roundData['Round Format']) {
                    metadata.push(`<strong>Round Format:</strong> ${escapeHTML(roundData['Round Format'])}`);
                }
                
                if (metadata.length > 0) {
                    metadataDiv.innerHTML = metadata.join(' | ');
                    content.appendChild(metadataDiv);
                }
                
                // Check if we have round instructions
                let roundInstruction = null;
                if (roundData['Round Instruction']) {
                    roundInstruction = roundData['Round Instruction'];
                }
                
                // If we have round instructions, display them
                if (roundInstruction) {
                    const instructionDiv = document.createElement('div');
                    instructionDiv.style.padding = '15px';
                    instructionDiv.style.backgroundColor = '#f9f9f9';
                    instructionDiv.style.borderRadius = '6px';
                    instructionDiv.style.marginBottom = '20px';
                    
                    const instructionTitle = document.createElement('h3');
                    instructionTitle.textContent = 'Round Instructions';
                    instructionTitle.style.margin = '0 0 10px 0';
                    instructionTitle.style.color = '#333';
                    
                    const instructionText = document.createElement('p');
                    instructionText.textContent = roundInstruction;
                    instructionText.style.margin = '0';
                    
                    instructionDiv.appendChild(instructionTitle);
                    instructionDiv.appendChild(instructionText);
                    content.appendChild(instructionDiv);
                }
                
                // Sort questions numerically
                const questions = Object.entries(roundData)
                    .filter(([key, value]) => !isNaN(parseInt(key)) && typeof value === 'object')
                    .sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
                
                // Create table for questions
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                
                // Add table header
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr>
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; background-color: #f5f5f5;">#</th>
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; background-color: #f5f5f5;">Question</th>
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; background-color: #f5f5f5;">Answer</th>
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; background-color: #f5f5f5;">Images</th>
                    </tr>
                `;
                table.appendChild(thead);
                
                // Add questions to table
                const tbody = document.createElement('tbody');
                questions.forEach(([questionNum, questionData]) => {
                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #eee';
                    
                    // Get question and answer
                    const question = questionData.Question || questionData.question || '';
                    const answer = questionData.Answer || questionData.answer || '';
                    
                    // Get image links
                    const imageLink = questionData['Image Link'] || questionData['image_link'] || '';
                    const answerImageLink = questionData['Answer Image Link'] || questionData['answer_image_link'] || '';
                    
                    // Create image previews
                    let imagePreviewsHtml = '';
                    if (imageLink || answerImageLink) {
                        if (imageLink) {
                            imagePreviewsHtml += `<div style="margin-bottom: 10px;">
                                <strong>Question Image:</strong><br>
                                ${createImagePreview(imageLink, 'Question Image')}
                            </div>`;
                        }
                        if (answerImageLink) {
                            imagePreviewsHtml += `<div>
                                <strong>Answer Image:</strong><br>
                                ${createImagePreview(answerImageLink, 'Answer Image')}
                            </div>`;
                        }
                    }
                    
                    row.innerHTML = `
                        <td style="padding: 12px; vertical-align: top; font-weight: bold;">${questionNum}</td>
                        <td style="padding: 12px; vertical-align: top; max-width: 300px;">${escapeHTML(question)}</td>
                        <td style="padding: 12px; vertical-align: top; max-width: 250px;">${escapeHTML(answer)}</td>
                        <td style="padding: 12px; vertical-align: top;">${imagePreviewsHtml}</td>
                    `;
                    
                    tbody.appendChild(row);
                });
                
                table.appendChild(tbody);
                content.appendChild(table);
                
                // Replace loading indicator with content
                modal.appendChild(content);
                
                // Add close event for clicking outside the modal
                modal.addEventListener('click', e => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                });
                
            } catch (error) {
                console.error('Error loading round details:', error);
                // If modal exists, update with error
                const modal = document.querySelector('div[style*="position: fixed"]');
                if (modal) {
                    modal.innerHTML = `
                        <div style="background-color: white; padding: 30px; border-radius: 8px;">
                            <h3>Error Loading Round</h3>
                            <p>There was an error loading the round details. Please try again.</p>
                            <button onclick="document.body.removeChild(this.parentNode.parentNode)">Close</button>
                        </div>
                    `;
                }
            }
        }
        
        // Format date string
        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            try {
                // Try to parse and format the date
                // Handle different formats: YYYYMMDD, MM/DD/YYYY, etc.
                let date;
                
                if (/^\d{8}$/.test(dateStr)) {
                    // Format YYYYMMDD
                    const year = dateStr.substring(0, 4);
                    const month = dateStr.substring(4, 6);
                    const day = dateStr.substring(6, 8);
                    date = new Date(`${year}-${month}-${day}`);
                } else {
                    // Try standard date parsing
                    date = new Date(dateStr);
                }
                
                // Check if date is valid
                if (isNaN(date.getTime())) {
                    return dateStr; // Return original if parsing failed
                }
                
                // Format as MM/DD/YYYY
                return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
            } catch (e) {
                console.error('Error formatting date:', e);
                return dateStr; // Return original on error
            }
        }
        
        // Extract iframe embeddable URL from various image hosting services
        function getEmbedUrl(url) {
            if (!url || typeof url !== 'string') return null;
            
            try {
                // Handle Google Drive links
                if (url.includes('drive.google.com')) {
                    const fileIdMatch = url.match(/[-\w]{25,}/);
                    if (fileIdMatch) {
                        return `https://drive.google.com/file/d/${fileIdMatch[0]}/preview`;
                    }
                }
                
                // Handle Imgur links
                if (url.includes('imgur.com')) {
                    const imgurIdMatch = url.match(/imgur\.com\/(?:a\/|gallery\/)?([a-zA-Z0-9]{5,})/);
                    if (imgurIdMatch) {
                        return `https://imgur.com/${imgurIdMatch[1]}/embed`;
                    }
                }
                
                // Handle YouTube links
                if (url.includes('youtube.com') || url.includes('youtu.be')) {
                    let videoId;
                    if (url.includes('youtube.com/watch?v=')) {
                        videoId = new URL(url).searchParams.get('v');
                    } else if (url.includes('youtu.be/')) {
                        videoId = url.split('youtu.be/')[1].split('?')[0];
                    }
                    if (videoId) {
                        return `https://www.youtube.com/embed/${videoId}`;
                    }
                }
                
                // For direct image URLs, return the original URL (will be used in an img tag)
                if (url.match(/\.(jpeg|jpg|gif|png)$/i)) {
                    return url;
                }
                
                // For unknown URLs, return null (will default to showing the URL as text)
                return null;
                
            } catch (e) {
                console.error('Error parsing URL for embed:', e);
                return null;
            }
        }
        
        // Create HTML for image and iframe previews
        function createImagePreview(url, title) {
            if (!url || typeof url !== 'string') return '';
            
            const embedUrl = getEmbedUrl(url);
            
            if (!embedUrl) {
                // If we couldn't convert to an embeddable URL, just show a link
                return `<a href="${escapeHTML(url)}" target="_blank" class="image-link">Full Screen</a>`;
            }
            
            // For direct image URLs
            if (embedUrl.match(/\.(jpeg|jpg|gif|png)$/i)) {
                return `<img src="${escapeHTML(embedUrl)}" alt="${escapeHTML(title || 'Image')}" class="image-preview" data-full-url="${escapeHTML(url)}">
                       <a href="${escapeHTML(url)}" target="_blank" class="image-link">Full Screen</a>`;
            }
            
            // For embeddable URLs
            return `
                <div class="iframe-container">
                    <iframe src="${escapeHTML(embedUrl)}" title="${escapeHTML(title || 'Preview')}" allowfullscreen></iframe>
                </div>
                <a href="${escapeHTML(url)}" target="_blank" class="image-link">Full Screen</a>
            `;
        }
        
        // Show question details in a modal (keeping this function for reference but not using it anymore)
        function showQuestionDetails(result) {
            // This function is no longer used - we now show the entire round instead
        }
        
        // Helper function to check if a string is a URL
        function isUrl(str) {
            try {
                return str.startsWith('http://') || str.startsWith('https://');
            } catch (e) {
                return false;
            }
        }
        
        // Helper function to escape HTML
        function escapeHTML(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }
        
        // Helper function to scroll to results - separated to avoid breaking search functionality
        function scrollToResults() {
            // Scroll to results container when performing search
            try {
                const resultsContainer = document.querySelector('.results-container');
                if (resultsContainer) {
                    setTimeout(() => {
                        resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
            } catch (error) {
                console.error('Error scrolling to results:', error);
                // Fail silently - don't break search functionality
            }
        }

        // Event listeners
        searchBtn.addEventListener('click', () => {
            searchQuestions();
            scrollToResults();
        });

        searchQuery.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission
                searchQuestions();
                scrollToResults();
            }
        });
        
        clearBtn.addEventListener('click', () => {
            // Clear inputs
            searchQuery.value = '';
            
            // Reset all filter buttons
            resetFilterButtons();
            
            // Clear results
            resultsBody.innerHTML = '';
            cardResults.innerHTML = '';
            noResults.classList.add('hidden');
            endResults.classList.add('hidden');
            loadMoreSection.classList.add('hidden');
            resultsCount.textContent = '0';
            
            // Reset search state
            currentSearch = {
                query: '',
                formats: [],
                rounds: [], // Kept for backward compatibility
                fields: [],
                sort: 'newest', // Always use newest first
                lastKey: null,
                results: [],
                hasMore: false,
                endReached: false,
                useExactMatch: false,
                resultCount: 0 // Add counter to track total results
            };
        });
        
        loadMoreBtn.addEventListener('click', () => {
            loadQuestions(true);
        });
        
        // View toggle event listener
        viewToggle.addEventListener('change', function() {
            if (this.checked) {
                // Card view
                tableView.style.display = 'none';
                cardView.style.display = 'block';
            } else {
                // Table view
                tableView.style.display = 'block';
                cardView.style.display = 'none';
            }
        });
        
        // Initialize view based on screen size
        function initializeView() {
            // Check if mobile
            const isMobile = window.innerWidth <= 768;
            
            // Set toggle state based on screen size
            viewToggle.checked = isMobile;
            
            // Update view
            if (isMobile) {
                tableView.style.display = 'none';
                cardView.style.display = 'block';
            } else {
                tableView.style.display = 'block';
                cardView.style.display = 'none';
            }
        }
        
        // Call on page load and window resize
        window.addEventListener('load', initializeView);
        window.addEventListener('resize', initializeView);

        // Event delegation for image previews
        document.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('image-preview')) {
                e.stopPropagation(); // Don't open the question details modal
                const fullUrl = e.target.getAttribute('data-full-url');
                if (fullUrl) {
                    openImageModal(fullUrl, e.target.getAttribute('title') || 'Image');
                }
            }
        });
        
        // Open a full-size image in a modal
        function openImageModal(imageUrl, title) {
            // Create modal element
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '2000';
            
            // Create image container
            const container = document.createElement('div');
            container.style.position = 'relative';
            container.style.maxWidth = '90%';
            container.style.maxHeight = '90%';
            
            // Create title
            const titleElement = document.createElement('div');
            titleElement.textContent = title;
            titleElement.style.color = 'white';
            titleElement.style.position = 'absolute';
            titleElement.style.top = '-40px';
            titleElement.style.left = '0';
            titleElement.style.fontSize = '20px';
            titleElement.style.fontWeight = 'bold';
            
            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Ã—';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '-40px';
            closeBtn.style.right = '0';
            closeBtn.style.backgroundColor = 'transparent';
            closeBtn.style.border = 'none';
            closeBtn.style.color = 'white';
            closeBtn.style.fontSize = '30px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            // Create image
            const img = document.createElement('img');
            img.src = imageUrl;
            img.style.maxWidth = '100%';
            img.style.maxHeight = '80vh';
            img.style.objectFit = 'contain';
            img.style.border = '2px solid white';
            
            // Add elements to container
            container.appendChild(titleElement);
            container.appendChild(closeBtn);
            container.appendChild(img);
            
            // Add container to modal
            modal.appendChild(container);
            
            // Add close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            // Add to document
            document.body.appendChild(modal);
        }
        
        // Reset all filter buttons to initial state
        function resetFilterButtons() {
            // Reset format filters
            const formatCheckboxes = formatOptions.querySelectorAll('input[type="checkbox"]');
            formatCheckboxes.forEach(cb => {
                cb.checked = false;
            });
            updateFilterSelection('formats');
            
            // Reset field filters
            const fieldCheckboxes = fieldOptions.querySelectorAll('input[type="checkbox"]');
            fieldCheckboxes.forEach(cb => {
                cb.checked = false;
            });
            updateFilterSelection('fields');
        }
        
        // Check if user is admin
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                try {
                    // Get user data
                    const snapshot = await db.ref(`users/${user.uid}`).once('value');
                    const userData = snapshot.val() || {};
                    
                    // Check for admin role - in both new roles array and old role field
                    const isAdmin = 
                        (userData.roles && Array.isArray(userData.roles) && userData.roles.includes('admin')) ||
                        (userData.role === 'admin');
                    
                    // Check for tools role
                    const hasToolsAccess =
                        (userData.roles && Array.isArray(userData.roles) && userData.roles.includes('tools')) ||
                        (userData.role === 'tools');
                    
                    if (isAdmin || hasToolsAccess) {
                        // User has appropriate access, show search interface
                        authScreen.classList.add('hidden');
                        searchScreen.classList.remove('hidden');
                        initializePage(); // Initialize dropdowns and metadata
                    } else {
                        // User does not have access
                        authScreen.classList.remove('hidden');
                        searchScreen.classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Error checking user role:', error);
                    authScreen.classList.remove('hidden');
                    searchScreen.classList.add('hidden');
                }
            } else {
                // User is not signed in
                authScreen.classList.remove('hidden');
                searchScreen.classList.add('hidden');
            }
        });
        
        console.log("Search tool loaded successfully!");
    </script>
</body>
</html> 