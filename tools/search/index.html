<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evil Trivia - Search Archive</title>
    <script src="/js/components/autoload-banner.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #FFCC00;
            margin-top: 60px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .search-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .search-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .search-input {
            flex-grow: 1;
            min-width: 250px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            min-width: 150px;
        }
        
        button {
            background-color: #000;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #333;
        }
        
        .filter-section {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }
        
        .filter-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        .results-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .results-count {
            font-weight: bold;
            color: #333;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .results-table th, .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }
        
        .results-table th {
            background-color: #f5f5f5;
            color: #333;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .results-table tr:hover {
            background-color: #f9f9f9;
            cursor: pointer;
        }
        
        .load-more {
            text-align: center;
            margin-top: 20px;
        }
        
        .question-text {
            max-width: 375px;
            min-height: 40px;
            max-height: 120px;
            overflow-y: auto;
            white-space: normal;
            line-height: 1.4;
        }
        
        .iframe-container {
            width: 250px;
            height: 180px;
            overflow: hidden;
            border-radius: 4px;
            margin-bottom: 4px;
            position: relative;
        }
        
        .iframe-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .image-preview {
            width: 250px;
            height: 180px;
            object-fit: contain;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        
        .image-preview:hover {
            border-color: #999;
        }
        
        .image-link {
            display: block;
            font-size: 12px;
            color: #555;
            text-decoration: none;
            margin-top: 2px;
        }
        
        .image-link:hover {
            text-decoration: underline;
        }
        
        .filter-toggle {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .filter-group-label {
            font-weight: bold;
            width: 100%;
            margin-bottom: 5px;
            color: #555;
        }
        
        .filter-button {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
        }
        
        .filter-button.active {
            background-color: #000;
            color: white;
        }
        
        .filter-button:hover {
            background-color: #333;
            color: white;
        }
        
        .only-button {
            background-color: #888;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 5px;
            margin-left: 5px;
            font-size: 11px;
            cursor: pointer;
            opacity: 0.7;
        }
        
        .only-button:hover {
            opacity: 1;
        }
        
        .no-results {
            text-align: center;
            padding: 40px 0;
            color: #666;
            font-style: italic;
        }
        
        .end-results {
            text-align: center;
            padding: 20px 0;
            color: #666;
            font-style: italic;
            border-top: 1px solid #eee;
            margin-top: 20px;
        }
        
        .image-container {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .auth-container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            margin: 40px auto;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .auth-container h2 {
            margin-top: 0;
            color: #333;
        }
        
        .auth-container p {
            margin-bottom: 20px;
            color: #666;
        }
        
        .auth-btn {
            display: inline-block;
            background-color: #000;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .hidden {
            display: none;
        }

        .search-help {
            margin-top: 10px;
            font-size: 0.85rem;
            color: #666;
        }

        .search-help code {
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .filter-dropdown {
            position: relative;
            display: inline-block;
            min-width: 200px;
        }
        
        .filter-dropdown-header {
            padding: 10px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 250px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            padding: 10px;
            z-index: 20;
            max-height: 400px;
            overflow-y: auto;
            border-radius: 4px;
        }
        
        .filter-dropdown.open .filter-dropdown-content {
            display: block;
        }
        
        .filter-option {
            padding: 8px 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .filter-option:hover {
            background-color: #f5f5f5;
        }
        
        .filter-option input[type="checkbox"] {
            margin-right: 10px;
        }
        
        .filter-option-label {
            flex-grow: 1;
        }
        
        .only-option {
            color: #555;
            font-size: 12px;
            margin-left: 5px;
            cursor: pointer;
            opacity: 0.7;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .only-option:hover {
            background-color: #eee;
            color: #000;
            opacity: 1;
        }
        
        .filter-search {
            padding: 5px 8px;
            margin-bottom: 10px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .filter-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }
        
        .filter-count {
            display: inline-block;
            background-color: #f0f0f0;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 12px;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Trivia Question Archive Search</h1>
        
        <!-- Authentication Required Screen -->
        <div id="auth-screen" class="auth-container hidden">
            <h2>Admin Access Required</h2>
            <p>You need admin privileges to access this page.</p>
            <a href="/account" class="auth-btn">Go to Account Page</a>
        </div>
        
        <!-- Search Interface -->
        <div id="search-screen" class="hidden">
            <div class="search-container">
                <div class="search-row">
                    <div class="search-input">
                        <input type="text" id="search-query" placeholder="Search for questions or answers...">
                        <div class="search-help">
                            Supports wildcards: <code>*</code> for any number of characters, <code>?</code> for a single character
                        </div>
                    </div>
                    <button id="search-btn">Search</button>
                </div>
                
                <div class="filter-section">
                    <div class="filter-group">
                        <label>Format</label>
                        <div class="filter-dropdown" id="format-dropdown">
                            <div class="filter-dropdown-header">
                                <span>All Formats</span>
                                <span class="filter-count">0</span>
                                <span>▼</span>
                            </div>
                            <div class="filter-dropdown-content">
                                <input type="text" class="filter-search" placeholder="Search formats...">
                                <div class="filter-options" id="format-options">
                                    <!-- Format options will be populated dynamically -->
                                </div>
                                <div class="filter-actions">
                                    <button class="select-all-btn">Select All</button>
                                    <button class="clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Round</label>
                        <div class="filter-dropdown" id="round-dropdown">
                            <div class="filter-dropdown-header">
                                <span>All Rounds</span>
                                <span class="filter-count">0</span>
                                <span>▼</span>
                            </div>
                            <div class="filter-dropdown-content">
                                <input type="text" class="filter-search" placeholder="Search rounds...">
                                <div class="filter-options" id="round-options">
                                    <!-- Round options will be populated dynamically -->
                                </div>
                                <div class="filter-actions">
                                    <button class="select-all-btn">Select All</button>
                                    <button class="clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Field</label>
                        <div class="filter-dropdown" id="field-dropdown">
                            <div class="filter-dropdown-header">
                                <span>All Fields</span>
                                <span class="filter-count">0</span>
                                <span>▼</span>
                            </div>
                            <div class="filter-dropdown-content">
                                <input type="text" class="filter-search" placeholder="Search fields...">
                                <div class="filter-options" id="field-options">
                                    <!-- Field options will be populated dynamically -->
                                </div>
                                <div class="filter-actions">
                                    <button class="select-all-btn">Select All</button>
                                    <button class="clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label for="sort-filter">Sort By</label>
                        <select id="sort-filter">
                            <option value="newest">Newest First</option>
                            <option value="oldest">Oldest First</option>
                            <option value="relevance">Relevance</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="results-container">
                <div class="results-header">
                    <div class="results-count">Showing <span id="results-count">0</span> results</div>
                    <button id="clear-btn">Clear Results</button>
                </div>
                
                <div id="results-table-container">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Trivia #</th>
                                <th>Date</th>
                                <th>Round</th>
                                <th>Round Name</th>
                                <th>Format</th>
                                <th>Question</th>
                                <th>Answer</th>
                                <th>Question Image</th>
                                <th>Answer Image</th>
                            </tr>
                        </thead>
                        <tbody id="results-body">
                            <!-- Results will be populated here -->
                        </tbody>
                    </table>
                    
                    <div id="no-results" class="no-results hidden">
                        <p>No matching questions found. Try adjusting your search criteria.</p>
                    </div>
                    
                    <div id="end-results" class="no-results hidden">
                        <p>End of results. No more questions to display.</p>
                    </div>
                </div>
                
                <div class="load-more hidden" id="load-more">
                    <button id="load-more-btn">Load More Results</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
    
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
            authDomain: "eviltrivia-47664.firebaseapp.com",
            databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
            projectId: "eviltrivia-47664",
            storageBucket: "eviltrivia-47664.firebasestorage.app",
            messagingSenderId: "401826818140",
            appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
            measurementId: "G-2W6RK96Y34"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();
        
        // DOM Elements
        const authScreen = document.getElementById('auth-screen');
        const searchScreen = document.getElementById('search-screen');
        const searchQuery = document.getElementById('search-query');
        const searchBtn = document.getElementById('search-btn');
        const clearBtn = document.getElementById('clear-btn');
        const formatDropdown = document.getElementById('format-dropdown');
        const roundDropdown = document.getElementById('round-dropdown');
        const fieldDropdown = document.getElementById('field-dropdown');
        const formatOptions = document.getElementById('format-options');
        const roundOptions = document.getElementById('round-options');
        const fieldOptions = document.getElementById('field-options');
        const sortFilter = document.getElementById('sort-filter');
        const resultsBody = document.getElementById('results-body');
        const noResults = document.getElementById('no-results');
        const endResults = document.getElementById('end-results');
        const resultsCount = document.getElementById('results-count');
        const loadMoreSection = document.getElementById('load-more');
        const loadMoreBtn = document.getElementById('load-more-btn');
        
        // Search state
        let currentSearch = {
            query: '',
            formats: [],
            rounds: [],
            fields: [],
            sort: 'newest',
            lastKey: null,
            results: [],
            hasMore: false,
            endReached: false
        };

        // Store metadata about the database
        const dbMetadata = {
            rounds: new Set(),
            formats: new Set(),
            fields: new Set()
        };

        // Initialize the page
        async function initializePage() {
            await loadDatabaseMetadata();
            populateFilterDropdowns();
        }

        // Load metadata about database structure
        async function loadDatabaseMetadata() {
            try {
                // Get a sample of the archive to extract structure
                const archiveRef = db.ref('trivia-archive/archive');
                const snapshot = await archiveRef.limitToLast(3).once('value');
                const data = snapshot.val();
                
                if (!data) return;
                
                console.log('Loading metadata from sample data...');
                
                // Process each trivia set to extract rounds and formats
                for (const [triviaNumber, triviaSet] of Object.entries(data)) {
                    if (!triviaSet.trivia) continue;
                    
                    // Extract rounds
                    for (const roundKey of Object.keys(triviaSet.trivia)) {
                        if (typeof triviaSet.trivia[roundKey] !== 'object') continue;
                        dbMetadata.rounds.add(roundKey);
                        
                        // Extract formats for each round
                        const round = triviaSet.trivia[roundKey];
                        for (const formatKey of Object.keys(round)) {
                            if (typeof round[formatKey] !== 'object') continue;
                            dbMetadata.formats.add(formatKey);
                            
                            // Extract fields from a sample question
                            const format = round[formatKey];
                            // Find a question
                            for (const qKey of Object.keys(format)) {
                                const question = format[qKey];
                                if (typeof question === 'object' && question !== null) {
                                    // Extract field names
                                    for (const fieldName of Object.keys(question)) {
                                        dbMetadata.fields.add(fieldName);
                                    }
                                    break; // Just need one question for fields
                                }
                            }
                        }
                    }
                }
                
                console.log('Database metadata loaded:', {
                    rounds: Array.from(dbMetadata.rounds),
                    formats: Array.from(dbMetadata.formats),
                    fields: Array.from(dbMetadata.fields)
                });
            } catch (error) {
                console.error('Error loading database metadata:', error);
            }
        }

        // Populate dropdowns with database values
        function populateFilterDropdowns() {
            // Populate round filter
            const roundOptionsArray = Array.from(dbMetadata.rounds)
                .sort((a, b) => {
                    // Sort numerically if possible
                    const numA = parseInt(a);
                    const numB = parseInt(b);
                    if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                    return a.localeCompare(b);
                });
            
            roundOptions.innerHTML = '';
            for (const round of roundOptionsArray) {
                const displayName = round.startsWith('final') ? 'Final' : `Round ${round}`;
                addFilterOption(roundOptions, round, displayName, 'rounds');
            }
            
            // Populate format filter
            const formatOptionsArray = Array.from(dbMetadata.formats).sort();
            formatOptions.innerHTML = '';
            for (const format of formatOptionsArray) {
                addFilterOption(formatOptions, format, format, 'formats');
            }
            
            // Populate field filter
            const commonFields = ['Question', 'Answer', 'Hidden Structure_Theme', 'Round Name', 'Round Instruction'];
            const allFields = new Set([...commonFields, ...dbMetadata.fields]);
            const fieldOptionsArray = Array.from(allFields).sort();
            
            fieldOptions.innerHTML = '';
            for (const field of fieldOptionsArray) {
                // Skip internal fields or fields with no valuable search content
                if (field === 'uid' || field === 'id' || field === 'createdAt' || field === 'updatedAt') continue;
                
                addFilterOption(fieldOptions, field, field.replace(/_/g, ' '), 'fields');
            }
            
            // Add dropdown toggle behavior
            setupDropdowns();
        }
        
        // Add a single filter option with checkbox and "only" option
        function addFilterOption(container, value, displayText, filterType) {
            const option = document.createElement('div');
            option.className = 'filter-option';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = value;
            checkbox.id = `${filterType}-${value}`;
            checkbox.addEventListener('change', () => updateFilterSelection(filterType));
            
            const label = document.createElement('label');
            label.className = 'filter-option-label';
            label.textContent = displayText;
            label.htmlFor = checkbox.id;
            
            const onlyBtn = document.createElement('span');
            onlyBtn.className = 'only-option';
            onlyBtn.textContent = 'only';
            onlyBtn.title = `Show only ${displayText}`;
            onlyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                setOnlyFilter(value, filterType);
            });
            
            option.appendChild(checkbox);
            option.appendChild(label);
            option.appendChild(onlyBtn);
            container.appendChild(option);
        }
        
        // Setup the dropdowns (toggle open/close and filter search)
        function setupDropdowns() {
            const dropdowns = document.querySelectorAll('.filter-dropdown');
            
            dropdowns.forEach(dropdown => {
                const header = dropdown.querySelector('.filter-dropdown-header');
                const content = dropdown.querySelector('.filter-dropdown-content');
                const search = dropdown.querySelector('.filter-search');
                const options = dropdown.querySelector('.filter-options');
                const selectAllBtn = dropdown.querySelector('.select-all-btn');
                const clearBtn = dropdown.querySelector('.clear-btn');
                
                // Toggle dropdown
                header.addEventListener('click', () => {
                    dropdowns.forEach(d => {
                        if (d !== dropdown) {
                            d.classList.remove('open');
                        }
                    });
                    dropdown.classList.toggle('open');
                });
                
                // Filter options on search
                if (search) {
                    search.addEventListener('input', () => {
                        const query = search.value.toLowerCase();
                        const optionElements = options.querySelectorAll('.filter-option');
                        
                        optionElements.forEach(option => {
                            const text = option.textContent.toLowerCase();
                            if (text.includes(query)) {
                                option.style.display = 'flex';
                            } else {
                                option.style.display = 'none';
                            }
                        });
                    });
                }
                
                // Select all button
                if (selectAllBtn) {
                    selectAllBtn.addEventListener('click', () => {
                        const checkboxes = options.querySelectorAll('input[type="checkbox"]');
                        checkboxes.forEach(cb => {
                            cb.checked = true;
                        });
                        
                        // Get the filter type
                        let filterType;
                        if (dropdown.id === 'format-dropdown') filterType = 'formats';
                        else if (dropdown.id === 'round-dropdown') filterType = 'rounds';
                        else if (dropdown.id === 'field-dropdown') filterType = 'fields';
                        
                        updateFilterSelection(filterType);
                    });
                }
                
                // Clear all button
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        const checkboxes = options.querySelectorAll('input[type="checkbox"]');
                        checkboxes.forEach(cb => {
                            cb.checked = false;
                        });
                        
                        // Get the filter type
                        let filterType;
                        if (dropdown.id === 'format-dropdown') filterType = 'formats';
                        else if (dropdown.id === 'round-dropdown') filterType = 'rounds';
                        else if (dropdown.id === 'field-dropdown') filterType = 'fields';
                        
                        updateFilterSelection(filterType);
                    });
                }
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.filter-dropdown')) {
                    dropdowns.forEach(d => d.classList.remove('open'));
                }
            });
        }
        
        // Update filter selection based on checkboxes
        function updateFilterSelection(filterType) {
            let container, headerText, countElement;
            
            // Get corresponding elements
            if (filterType === 'formats') {
                container = formatOptions;
                headerText = formatDropdown.querySelector('.filter-dropdown-header span:first-child');
                countElement = formatDropdown.querySelector('.filter-count');
            } else if (filterType === 'rounds') {
                container = roundOptions;
                headerText = roundDropdown.querySelector('.filter-dropdown-header span:first-child');
                countElement = roundDropdown.querySelector('.filter-count');
            } else if (filterType === 'fields') {
                container = fieldOptions;
                headerText = fieldDropdown.querySelector('.filter-dropdown-header span:first-child');
                countElement = fieldDropdown.querySelector('.filter-count');
            }
            
            // Get checked values
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const values = Array.from(checkboxes).map(cb => cb.value);
            
            // Update search state
            currentSearch[filterType] = values;
            
            // Update header text
            const selectionCount = values.length;
            if (selectionCount === 0) {
                headerText.textContent = filterType === 'formats' ? 'All Formats' : 
                                         filterType === 'rounds' ? 'All Rounds' : 'All Fields';
                countElement.textContent = '';
                countElement.style.display = 'none';
            } else {
                headerText.textContent = selectionCount === 1 ? 
                    checkboxes[0].nextElementSibling.textContent :
                    `Multiple ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}`;
                countElement.textContent = selectionCount;
                countElement.style.display = 'inline-block';
            }
        }
        
        // Set a filter to "only" this value
        function setOnlyFilter(value, filterType) {
            let container;
            
            // Get corresponding container
            if (filterType === 'formats') {
                container = formatOptions;
            } else if (filterType === 'rounds') {
                container = roundOptions;
            } else if (filterType === 'fields') {
                container = fieldOptions;
            }
            
            // Uncheck all checkboxes
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = cb.value === value;
            });
            
            // Update filter selection
            updateFilterSelection(filterType);
        }

        // Search function
        async function searchQuestions() {
            // Update search state for query and sort
            currentSearch.query = searchQuery.value.trim();
            currentSearch.sort = sortFilter.value;
            currentSearch.lastKey = null;
            currentSearch.results = [];
            
            // Clear previous results
            resultsBody.innerHTML = '';
            noResults.classList.add('hidden');
            loadMoreSection.classList.add('hidden');
            
            // Perform search
            await loadQuestions();
        }
        
        // Load questions from Firebase
        async function loadQuestions(loadMore = false) {
            try {
                if (!loadMore) {
                    // New search, reset results
                    currentSearch.results = [];
                    currentSearch.lastKey = null;
                    currentSearch.endReached = false;
                    endResults.classList.add('hidden');
                }
                
                // Don't try to load more if we've already reached the end
                if (currentSearch.endReached) {
                    console.log('Already reached end of results');
                    return;
                }
                
                // Log for debugging
                console.log('Starting search with query:', currentSearch.query);
                console.log('Search filters:', {
                    rounds: currentSearch.rounds,
                    formats: currentSearch.formats,
                    fields: currentSearch.fields,
                    sort: currentSearch.sort
                });
                
                // Track if we need to load more batches to reach results
                let continueLoading = true;
                let batchesLoaded = 0;
                const maxBatches = 25; // Increase maximum batches to search more trivia sets
                let allResults = [];
                
                // Keep loading batches until we exhaust data or hit max batches
                while (continueLoading && batchesLoaded < maxBatches) {
                    batchesLoaded++;
                    const batchResults = await loadQuestionBatch(loadMore || batchesLoaded > 1);
                    
                    if (batchResults.length === 0) {
                        // No more results found
                        console.log('No more results found after batch', batchesLoaded);
                        currentSearch.endReached = true;
                        continueLoading = false;
                    } else {
                        allResults = [...allResults, ...batchResults];
                        
                        // If it's a specific search query, keep looking for more results
                        // Otherwise, once we have 50 results or no more data, we can stop
                        if (!currentSearch.query && (currentSearch.results.length + allResults.length >= 50 || !currentSearch.hasMore)) {
                            console.log('Reached sufficient results or end of data');
                            continueLoading = false;
                        }
                    }
                }
                
                console.log('Search complete, found total results:', allResults.length);
                
                // Update display
                displayResults(allResults, loadMore);
                
                // Show end of results message if appropriate
                if (currentSearch.endReached) {
                    endResults.classList.remove('hidden');
                    loadMoreSection.classList.add('hidden');
                } else {
                    endResults.classList.add('hidden');
                    loadMoreSection.classList.toggle('hidden', !currentSearch.hasMore);
                }
                
            } catch (error) {
                console.error('Error searching questions:', error);
            }
        }
        
        // Load a batch of questions from Firebase
        async function loadQuestionBatch(loadMore = false) {
            // Get reference to trivia-archive
            const archiveRef = db.ref('trivia-archive/archive');
            
            // Start by querying trivia numbers (sort by key in reverse for newest first)
            let triviaQuery = archiveRef.orderByKey();
            
            if (currentSearch.sort === 'newest') {
                // For newest first, we start at the end and move backward
                if (loadMore && currentSearch.lastKey) {
                    triviaQuery = triviaQuery.endAt(currentSearch.lastKey);
                }
                triviaQuery = triviaQuery.limitToLast(20); // Increase to load more trivia sets at a time
            } else {
                // For oldest first, we start at the beginning and move forward
                if (loadMore && currentSearch.lastKey) {
                    triviaQuery = triviaQuery.startAt(currentSearch.lastKey);
                }
                triviaQuery = triviaQuery.limitToFirst(20); // Increase to load more trivia sets at a time
            }
            
            // Get trivia numbers
            const triviaSnap = await triviaQuery.once('value');
            const triviaData = triviaSnap.val();
            
            if (!triviaData) {
                // No trivia found
                console.log('No trivia data found');
                if (!loadMore) {
                    noResults.classList.remove('hidden');
                    resultsCount.textContent = '0';
                }
                loadMoreSection.classList.add('hidden');
                return [];
            }
            
            // Convert to array and sort
            let triviaItems = Object.entries(triviaData).map(([triviaNumber, data]) => ({
                triviaNumber,
                data
            }));
            
            // Sort by trivia number (newest first or oldest first)
            if (currentSearch.sort === 'newest') {
                triviaItems.sort((a, b) => b.triviaNumber.localeCompare(a.triviaNumber));
            } else {
                triviaItems.sort((a, b) => a.triviaNumber.localeCompare(b.triviaNumber));
            }
            
            console.log('Processing trivia items:', triviaItems.length);
            
            // Process each trivia set
            const results = [];
            let processedCount = 0;
            
            for (const item of triviaItems) {
                // Skip the first item if loading more (it was the last key from previous batch)
                if (loadMore && processedCount === 0 && currentSearch.lastKey === item.triviaNumber) {
                    processedCount++;
                    continue;
                }
                
                processedCount++;
                console.log('Processing trivia #:', item.triviaNumber);
                
                // First, check if this trivia set has a "trivia" node
                const triviaRef = db.ref(`trivia-archive/archive/${item.triviaNumber}`);
                const triviaSnap = await triviaRef.once('value');
                const triviaData = triviaSnap.val();
                
                if (!triviaData) {
                    console.log('No data for trivia #:', item.triviaNumber);
                    continue;
                }

                // Check if the trivia data has a "trivia" subnode
                const triviaNode = triviaData.trivia || null;
                if (!triviaNode) {
                    console.log('No trivia node found for trivia #:', item.triviaNumber);
                    continue;
                }

                console.log('Found trivia node with rounds:', Object.keys(triviaNode));
                
                // Get trivia metadata
                const triviaNumber = item.triviaNumber;
                const triviaName = triviaData.name || '';
                const triviaDate = triviaData.date || '';
                
                // Process each round in the trivia set
                for (const [roundKey, roundData] of Object.entries(triviaNode)) {
                    // Skip non-object values
                    if (typeof roundData !== 'object' || roundData === null) continue;
                    
                    // Apply round filter
                    if (currentSearch.rounds.length > 0 && !currentSearch.rounds.includes(roundKey)) continue;
                    
                    // Get round metadata
                    const roundName = getRoundName(triviaNode, roundKey);
                    
                    // Process each format in the round
                    for (const [formatKey, formatData] of Object.entries(roundData)) {
                        // Skip non-object values
                        if (typeof formatData !== 'object' || formatData === null) continue;
                        
                        // Apply format filter
                        if (currentSearch.formats.length > 0 && !currentSearch.formats.includes(formatKey)) continue;
                        
                        // Process each question in the format
                        for (const [questionKey, questionData] of Object.entries(formatData)) {
                            // Skip non-object values
                            if (typeof questionData !== 'object' || questionData === null) continue;
                            
                            // Skip non-numeric question keys (other metadata)
                            if (isNaN(questionKey) && !/^\d+$/.test(questionKey)) continue;
                            
                            // Check if this question matches our search criteria
                            let matches = false;
                            
                            if (currentSearch.query) {
                                // If searching for a specific field
                                if (currentSearch.fields.length > 0) {
                                    // For field search, check each selected field
                                    for (const field of currentSearch.fields) {
                                        const fieldValue = questionData[field];
                                        if (fieldValue && matchesQuery(fieldValue, currentSearch.query)) {
                                            matches = true;
                                            break;
                                        }
                                    }
                                } else {
                                    // Search in all fields
                                    for (const [fieldName, fieldValue] of Object.entries(questionData)) {
                                        // Skip empty values or non-string/number values
                                        if (!fieldValue || (typeof fieldValue !== 'string' && typeof fieldValue !== 'number')) continue;
                                        
                                        if (matchesQuery(fieldValue, currentSearch.query)) {
                                            matches = true;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                // No query, so it matches if it passes the round/format filters
                                matches = true;
                            }
                            
                            if (matches) {
                                const resultItem = {
                                    triviaNumber: triviaNumber,
                                    triviaName: triviaName,
                                    triviaDate: triviaDate,
                                    round: roundKey,
                                    roundName: roundName,
                                    format: formatKey,
                                    questionNum: questionKey,
                                    questionData: questionData
                                };
                                
                                results.push(resultItem);
                            }
                        }
                    }
                }
                
                // Remember the last key for pagination only if we processed this trivia
                if (processedCount > 1) {
                    currentSearch.lastKey = item.triviaNumber;
                }
            }
            
            // Update paging info - we have more if we found at least one item and processed more than 1
            currentSearch.hasMore = results.length > 0 && processedCount > 1;
            
            return results;
        }
        
        // Helper function to get a round name from trivia data
        function getRoundName(triviaNode, roundKey) {
            try {
                // Try to find round name in different possible locations
                if (triviaNode[roundKey] && triviaNode[roundKey]['Round Name']) {
                    return triviaNode[roundKey]['Round Name'];
                }
                
                if (triviaNode[roundKey] && typeof triviaNode[roundKey] === 'object') {
                    // Look through formats for round name
                    for (const formatKey of Object.keys(triviaNode[roundKey])) {
                        const format = triviaNode[roundKey][formatKey];
                        if (format && format['Round Name']) {
                            return format['Round Name'];
                        }
                        
                        // Look through questions for round name
                        if (format && typeof format === 'object') {
                            for (const qKey of Object.keys(format)) {
                                const q = format[qKey];
                                if (q && q['Round Name']) {
                                    return q['Round Name'];
                                }
                            }
                        }
                    }
                }
                
                // If round is 'final', return "Final Round"
                if (roundKey.toLowerCase().includes('final')) {
                    return "Final Round";
                }
                
                // Default to formatted round number
                return `Round ${roundKey}`;
            } catch (e) {
                console.error('Error getting round name:', e);
                return `Round ${roundKey}`;
            }
        }
        
        // Display search results
        function displayResults(results, appendResults = false) {
            if (!appendResults) {
                resultsBody.innerHTML = '';
            }
            
            if (!results.length && !currentSearch.results.length) {
                noResults.classList.remove('hidden');
                resultsCount.textContent = '0';
                return;
            }
            
            // Add new results to our state
            currentSearch.results = [...currentSearch.results, ...results];
            
            // Update the display
            noResults.classList.add('hidden');
            
            // Add rows to the table
            results.forEach(result => {
                const row = document.createElement('tr');
                
                // Get the data from the question data
                const question = result.questionData.Question || result.questionData.question || '';
                const answer = result.questionData.Answer || result.questionData.answer || '';
                
                // Format the date nicely if available
                const dateStr = formatDate(result.triviaDate);
                
                // Get image links if available
                const imageLink = result.questionData['Image Link'] || result.questionData['image_link'] || '';
                const answerImageLink = result.questionData['Answer Image Link'] || result.questionData['answer_image_link'] || '';
                
                row.innerHTML = `
                    <td>${result.triviaNumber}</td>
                    <td>${escapeHTML(dateStr)}</td>
                    <td>${result.round}</td>
                    <td>${escapeHTML(result.roundName || '')}</td>
                    <td>${result.format}</td>
                    <td class="question-text">${escapeHTML(question)}</td>
                    <td class="question-text">${escapeHTML(answer)}</td>
                    <td>${createImagePreview(imageLink, 'Question Image')}</td>
                    <td>${createImagePreview(answerImageLink, 'Answer Image')}</td>
                `;
                
                // Add click event to show full details
                row.addEventListener('click', (e) => {
                    // Don't trigger detail view when clicking on links or iframes
                    if (e.target.tagName === 'A' || e.target.tagName === 'IFRAME' || e.target.tagName === 'IMG') {
                        return;
                    }
                    showQuestionDetails(result);
                });
                
                resultsBody.appendChild(row);
            });
            
            // Update count
            resultsCount.textContent = currentSearch.results.length;
        }
        
        // Format date string
        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            try {
                // Try to parse and format the date
                // Handle different formats: YYYYMMDD, MM/DD/YYYY, etc.
                let date;
                
                if (/^\d{8}$/.test(dateStr)) {
                    // Format YYYYMMDD
                    const year = dateStr.substring(0, 4);
                    const month = dateStr.substring(4, 6);
                    const day = dateStr.substring(6, 8);
                    date = new Date(`${year}-${month}-${day}`);
                } else {
                    // Try standard date parsing
                    date = new Date(dateStr);
                }
                
                // Check if date is valid
                if (isNaN(date.getTime())) {
                    return dateStr; // Return original if parsing failed
                }
                
                // Format as MM/DD/YYYY
                return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
            } catch (e) {
                console.error('Error formatting date:', e);
                return dateStr; // Return original on error
            }
        }
        
        // Extract iframe embeddable URL from various image hosting services
        function getEmbedUrl(url) {
            if (!url || typeof url !== 'string') return null;
            
            try {
                // Handle Google Drive links
                if (url.includes('drive.google.com')) {
                    const fileIdMatch = url.match(/[-\w]{25,}/);
                    if (fileIdMatch) {
                        return `https://drive.google.com/file/d/${fileIdMatch[0]}/preview`;
                    }
                }
                
                // Handle Imgur links
                if (url.includes('imgur.com')) {
                    const imgurIdMatch = url.match(/imgur\.com\/(?:a\/|gallery\/)?([a-zA-Z0-9]{5,})/);
                    if (imgurIdMatch) {
                        return `https://imgur.com/${imgurIdMatch[1]}/embed`;
                    }
                }
                
                // Handle YouTube links
                if (url.includes('youtube.com') || url.includes('youtu.be')) {
                    let videoId;
                    if (url.includes('youtube.com/watch?v=')) {
                        videoId = new URL(url).searchParams.get('v');
                    } else if (url.includes('youtu.be/')) {
                        videoId = url.split('youtu.be/')[1].split('?')[0];
                    }
                    if (videoId) {
                        return `https://www.youtube.com/embed/${videoId}`;
                    }
                }
                
                // For direct image URLs, return the original URL (will be used in an img tag)
                if (url.match(/\.(jpeg|jpg|gif|png)$/i)) {
                    return url;
                }
                
                // For unknown URLs, return null (will default to showing the URL as text)
                return null;
                
            } catch (e) {
                console.error('Error parsing URL for embed:', e);
                return null;
            }
        }
        
        // Create HTML for image and iframe previews
        function createImagePreview(url, title) {
            if (!url || typeof url !== 'string') return '';
            
            const embedUrl = getEmbedUrl(url);
            
            if (!embedUrl) {
                // If we couldn't convert to an embeddable URL, just show a link
                return `<a href="${escapeHTML(url)}" target="_blank" class="image-link">Full Screen</a>`;
            }
            
            // For direct image URLs
            if (embedUrl.match(/\.(jpeg|jpg|gif|png)$/i)) {
                return `<img src="${escapeHTML(embedUrl)}" alt="${escapeHTML(title || 'Image')}" class="image-preview" data-full-url="${escapeHTML(url)}">
                       <a href="${escapeHTML(url)}" target="_blank" class="image-link">Full Screen</a>`;
            }
            
            // For embeddable URLs
            return `
                <div class="iframe-container">
                    <iframe src="${escapeHTML(embedUrl)}" title="${escapeHTML(title || 'Preview')}" allowfullscreen></iframe>
                </div>
                <a href="${escapeHTML(url)}" target="_blank" class="image-link">Full Screen</a>
            `;
        }
        
        // Show question details in a modal
        function showQuestionDetails(result) {
            // Create modal element
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '1000';
            
            // Create modal content
            const content = document.createElement('div');
            content.style.backgroundColor = 'white';
            content.style.padding = '30px';
            content.style.borderRadius = '8px';
            content.style.maxWidth = '800px';
            content.style.width = '90%';
            content.style.maxHeight = '80vh';
            content.style.overflowY = 'auto';
            
            // Create header with close button
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.marginBottom = '20px';
            
            const title = document.createElement('h2');
            title.style.margin = '0';
            title.textContent = `Question Details`;
            
            const closeBtn = document.createElement('button');
            closeBtn.id = 'closeModal';
            closeBtn.style.background = 'none';
            closeBtn.style.border = 'none';
            closeBtn.style.fontSize = '24px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.innerHTML = '&times;';
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            header.appendChild(title);
            header.appendChild(closeBtn);
            content.appendChild(header);
            
            // Add basic info fields
            const basicInfoFields = [
                {label: 'Trivia #', value: result.triviaNumber},
                {label: 'Trivia Name', value: result.triviaName},
                {label: 'Round', value: result.round},
                {label: 'Format', value: result.format},
                {label: 'Question #', value: result.questionNum}
            ];
            
            basicInfoFields.forEach(field => {
                if (field.value) {
                    addFieldToModal(content, field.label, field.value);
                }
            });
            
            // Add all question data fields
            for (const [fieldName, fieldValue] of Object.entries(result.questionData)) {
                // Skip empty values or complex objects
                if (!fieldValue || typeof fieldValue === 'object') continue;
                
                // Skip fields we already displayed
                if (basicInfoFields.some(f => f.label === fieldName)) continue;
                
                addFieldToModal(content, fieldName, fieldValue);
            }
            
            // Add content to modal
            modal.appendChild(content);
            
            // Add close event for clicking outside the modal
            modal.addEventListener('click', e => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            // Add to document
            document.body.appendChild(modal);
        }
        
        // Helper function to add a field to the modal
        function addFieldToModal(container, label, value) {
            const wrapper = document.createElement('div');
            wrapper.style.marginBottom = '15px';
            
            const labelElem = document.createElement('strong');
            labelElem.textContent = label + ':';
            wrapper.appendChild(labelElem);
            
            const valueContainer = document.createElement('div');
            valueContainer.style.padding = '10px';
            valueContainer.style.backgroundColor = '#f9f9f9';
            valueContainer.style.borderRadius = '4px';
            valueContainer.style.marginTop = '5px';
            
            // Check if it's an image link or a music link
            if ((label.includes('Image') || label.includes('image')) && typeof value === 'string' && isUrl(value)) {
                const img = document.createElement('img');
                img.src = value;
                img.style.maxWidth = '100%';
                img.style.maxHeight = '300px';
                valueContainer.appendChild(img);
                
                // Also add the raw link
                const linkText = document.createElement('div');
                linkText.style.marginTop = '5px';
                linkText.style.fontSize = '0.8em';
                linkText.style.wordBreak = 'break-all';
                linkText.textContent = value;
                valueContainer.appendChild(linkText);
            } 
            else if ((label.includes('Music') || label.includes('Audio') || label.includes('audio')) && 
                     typeof value === 'string' && isUrl(value)) {
                const audio = document.createElement('audio');
                audio.controls = true;
                audio.src = value;
                valueContainer.appendChild(audio);
                
                // Also add the raw link
                const linkText = document.createElement('div');
                linkText.style.marginTop = '5px';
                linkText.style.fontSize = '0.8em';
                linkText.style.wordBreak = 'break-all';
                linkText.textContent = value;
                valueContainer.appendChild(linkText);
            }
            else if (typeof value === 'string' && isUrl(value)) {
                // For other URLs, make them clickable
                const link = document.createElement('a');
                link.href = value;
                link.target = '_blank';
                link.textContent = value;
                link.style.wordBreak = 'break-all';
                valueContainer.appendChild(link);
            }
            else {
                valueContainer.textContent = value;
            }
            
            wrapper.appendChild(valueContainer);
            container.appendChild(wrapper);
        }
        
        // Helper function to check if a string is a URL
        function isUrl(str) {
            try {
                return str.startsWith('http://') || str.startsWith('https://');
            } catch (e) {
                return false;
            }
        }
        
        // Helper function to escape HTML
        function escapeHTML(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }
        
        // Event listeners
        searchBtn.addEventListener('click', searchQuestions);
        searchQuery.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchQuestions();
            }
        });
        
        clearBtn.addEventListener('click', () => {
            // Clear inputs
            searchQuery.value = '';
            sortFilter.value = 'newest';
            
            // Reset all filter buttons
            resetFilterButtons();
            
            // Clear results
            resultsBody.innerHTML = '';
            noResults.classList.add('hidden');
            endResults.classList.add('hidden');
            loadMoreSection.classList.add('hidden');
            resultsCount.textContent = '0';
            
            // Reset search state
            currentSearch = {
                query: '',
                formats: [],
                rounds: [],
                fields: [],
                sort: 'newest',
                lastKey: null,
                results: [],
                hasMore: false,
                endReached: false
            };
        });
        
        loadMoreBtn.addEventListener('click', () => {
            loadQuestions(true);
        });
        
        // Event delegation for image previews
        document.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('image-preview')) {
                e.stopPropagation(); // Don't open the question details modal
                const fullUrl = e.target.getAttribute('data-full-url');
                if (fullUrl) {
                    openImageModal(fullUrl, e.target.getAttribute('title') || 'Image');
                }
            }
        });
        
        // Open a full-size image in a modal
        function openImageModal(imageUrl, title) {
            // Create modal element
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '2000';
            
            // Create image container
            const container = document.createElement('div');
            container.style.position = 'relative';
            container.style.maxWidth = '90%';
            container.style.maxHeight = '90%';
            
            // Create title
            const titleElement = document.createElement('div');
            titleElement.textContent = title;
            titleElement.style.color = 'white';
            titleElement.style.position = 'absolute';
            titleElement.style.top = '-40px';
            titleElement.style.left = '0';
            titleElement.style.fontSize = '20px';
            titleElement.style.fontWeight = 'bold';
            
            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '×';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '-40px';
            closeBtn.style.right = '0';
            closeBtn.style.backgroundColor = 'transparent';
            closeBtn.style.border = 'none';
            closeBtn.style.color = 'white';
            closeBtn.style.fontSize = '30px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            // Create image
            const img = document.createElement('img');
            img.src = imageUrl;
            img.style.maxWidth = '100%';
            img.style.maxHeight = '80vh';
            img.style.objectFit = 'contain';
            img.style.border = '2px solid white';
            
            // Add elements to container
            container.appendChild(titleElement);
            container.appendChild(closeBtn);
            container.appendChild(img);
            
            // Add container to modal
            modal.appendChild(container);
            
            // Add close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            // Add to document
            document.body.appendChild(modal);
        }
        
        // Reset all filter buttons to initial state
        function resetFilterButtons() {
            // Reset format filters
            const formatCheckboxes = formatOptions.querySelectorAll('input[type="checkbox"]');
            formatCheckboxes.forEach(cb => {
                cb.checked = false;
            });
            updateFilterSelection('formats');
            
            // Reset round filters
            const roundCheckboxes = roundOptions.querySelectorAll('input[type="checkbox"]');
            roundCheckboxes.forEach(cb => {
                cb.checked = false;
            });
            updateFilterSelection('rounds');
            
            // Reset field filters
            const fieldCheckboxes = fieldOptions.querySelectorAll('input[type="checkbox"]');
            fieldCheckboxes.forEach(cb => {
                cb.checked = false;
            });
            updateFilterSelection('fields');
        }
        
        // Test if a string matches a query (either contains or matches wildcard)
        function matchesQuery(text, query) {
            if (!text || !query) return false;
            
            // Ensure we're working with strings
            const textStr = String(text).toLowerCase();
            const queryStr = String(query).toLowerCase();
            
            // Handle wildcards
            if (queryStr.includes('*') || queryStr.includes('?')) {
                const regexPattern = wildcardToRegExp(queryStr);
                if (regexPattern) {
                    // Test the whole text and individual words
                    return regexPattern.test(textStr) || 
                           textStr.split(/\s+/).some(word => regexPattern.test(word));
                }
            }
            
            // For simple queries, just check if the text contains the query
            return textStr.includes(queryStr);
        }
        
        // Convert wildcards to regex pattern
        function wildcardToRegExp(s) {
            if (!s || (!s.includes('*') && !s.includes('?'))) {
                return null; // Return null if there are no wildcards
            }
            
            // Escape special regex chars except * and ?
            let pattern = s.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            
            // Convert * and ? to their regex equivalents
            pattern = pattern.replace(/\*/g, '.*').replace(/\?/g, '.');
            
            // Return RegExp object with case-insensitive flag
            return new RegExp(pattern, 'i');
        }
        
        // Check if user is admin
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                try {
                    // Get user data
                    const snapshot = await db.ref(`users/${user.uid}`).once('value');
                    const userData = snapshot.val() || {};
                    
                    // Check for admin role - in both new roles array and old role field
                    const isAdmin = 
                        (userData.roles && Array.isArray(userData.roles) && userData.roles.includes('admin')) ||
                        (userData.role === 'admin');
                    
                    if (isAdmin) {
                        // User is admin, show search interface
                        authScreen.classList.add('hidden');
                        searchScreen.classList.remove('hidden');
                        initializePage(); // Initialize dropdowns and metadata
                    } else {
                        // User is not admin
                        authScreen.classList.remove('hidden');
                        searchScreen.classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Error checking user role:', error);
                    authScreen.classList.remove('hidden');
                    searchScreen.classList.add('hidden');
                }
            } else {
                // User is not signed in
                authScreen.classList.remove('hidden');
                searchScreen.classList.add('hidden');
            }
        });
        
        console.log("Search tool loaded successfully!");
    </script>
</body>
</html> 