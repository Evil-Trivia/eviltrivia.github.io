<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evil Trivia - Search Archive</title>
    <script src="/js/components/autoload-banner.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #FFCC00;
            margin-top: 60px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .search-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .search-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .search-input {
            flex-grow: 1;
            min-width: 250px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            min-width: 150px;
        }
        
        button {
            background-color: #000;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #333;
        }
        
        .filter-section {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }
        
        .filter-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        .results-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .results-count {
            font-weight: bold;
            color: #333;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .results-table th, .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .results-table th {
            background-color: #f5f5f5;
            color: #333;
            font-weight: bold;
        }
        
        .results-table tr:hover {
            background-color: #f9f9f9;
            cursor: pointer;
        }
        
        .load-more {
            text-align: center;
            margin-top: 20px;
        }
        
        .question-text {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .no-results {
            text-align: center;
            padding: 40px 0;
            color: #666;
            font-style: italic;
        }
        
        .end-results {
            text-align: center;
            padding: 20px 0;
            color: #666;
            font-style: italic;
            border-top: 1px solid #eee;
            margin-top: 20px;
        }
        
        .image-preview {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
            margin-right: 5px;
            cursor: pointer;
            border: 1px solid #ddd;
        }
        
        .image-preview:hover {
            border-color: #999;
        }
        
        .image-container {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .auth-container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            margin: 40px auto;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .auth-container h2 {
            margin-top: 0;
            color: #333;
        }
        
        .auth-container p {
            margin-bottom: 20px;
            color: #666;
        }
        
        .auth-btn {
            display: inline-block;
            background-color: #000;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .hidden {
            display: none;
        }

        .search-help {
            margin-top: 10px;
            font-size: 0.85rem;
            color: #666;
        }

        .search-help code {
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Trivia Question Archive Search</h1>
        
        <!-- Authentication Required Screen -->
        <div id="auth-screen" class="auth-container hidden">
            <h2>Admin Access Required</h2>
            <p>You need admin privileges to access this page.</p>
            <a href="/account" class="auth-btn">Go to Account Page</a>
        </div>
        
        <!-- Search Interface -->
        <div id="search-screen" class="hidden">
            <div class="search-container">
                <div class="search-row">
                    <div class="search-input">
                        <input type="text" id="search-query" placeholder="Search for questions or answers...">
                        <div class="search-help">
                            Supports wildcards: <code>*</code> for any number of characters, <code>?</code> for a single character
                        </div>
                    </div>
                    <button id="search-btn">Search</button>
                </div>
                
                <div class="filter-section">
                    <div class="filter-group">
                        <label for="format-filter">Format</label>
                        <select id="format-filter">
                            <option value="">All Formats</option>
                            <!-- Formats will be populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="round-filter">Round</label>
                        <select id="round-filter">
                            <option value="">All Rounds</option>
                            <!-- Rounds will be populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="field-filter">Field</label>
                        <select id="field-filter">
                            <option value="">All Fields</option>
                            <option value="Question">Question</option>
                            <option value="Answer">Answer</option>
                            <option value="Hidden Structure_Theme">Hidden Theme</option>
                            <option value="Round Name">Round Name</option>
                            <option value="Round Instruction">Round Instruction</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="sort-filter">Sort By</label>
                        <select id="sort-filter">
                            <option value="newest">Newest First</option>
                            <option value="oldest">Oldest First</option>
                            <option value="relevance">Relevance</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="results-container">
                <div class="results-header">
                    <div class="results-count">Showing <span id="results-count">0</span> results</div>
                    <button id="clear-btn">Clear Results</button>
                </div>
                
                <div id="results-table-container">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Trivia #</th>
                                <th>Date</th>
                                <th>Round</th>
                                <th>Round Name</th>
                                <th>Format</th>
                                <th>Question</th>
                                <th>Answer</th>
                                <th>Images</th>
                            </tr>
                        </thead>
                        <tbody id="results-body">
                            <!-- Results will be populated here -->
                        </tbody>
                    </table>
                    
                    <div id="no-results" class="no-results hidden">
                        <p>No matching questions found. Try adjusting your search criteria.</p>
                    </div>
                    
                    <div id="end-results" class="no-results hidden">
                        <p>End of results. No more questions to display.</p>
                    </div>
                </div>
                
                <div class="load-more hidden" id="load-more">
                    <button id="load-more-btn">Load More Results</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
    
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
            authDomain: "eviltrivia-47664.firebaseapp.com",
            databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
            projectId: "eviltrivia-47664",
            storageBucket: "eviltrivia-47664.firebasestorage.app",
            messagingSenderId: "401826818140",
            appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
            measurementId: "G-2W6RK96Y34"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();
        
        // DOM Elements
        const authScreen = document.getElementById('auth-screen');
        const searchScreen = document.getElementById('search-screen');
        const searchQuery = document.getElementById('search-query');
        const searchBtn = document.getElementById('search-btn');
        const clearBtn = document.getElementById('clear-btn');
        const formatFilter = document.getElementById('format-filter');
        const roundFilter = document.getElementById('round-filter');
        const fieldFilter = document.getElementById('field-filter');
        const sortFilter = document.getElementById('sort-filter');
        const resultsBody = document.getElementById('results-body');
        const noResults = document.getElementById('no-results');
        const endResults = document.getElementById('end-results');
        const resultsCount = document.getElementById('results-count');
        const loadMoreSection = document.getElementById('load-more');
        const loadMoreBtn = document.getElementById('load-more-btn');
        
        // Search state
        let currentSearch = {
            query: '',
            format: '',
            round: '',
            field: '',
            sort: 'newest',
            lastKey: null,
            results: [],
            hasMore: false,
            endReached: false
        };

        // Store metadata about the database
        const dbMetadata = {
            rounds: new Set(),
            formats: new Set(),
            fields: new Set()
        };

        // Initialize the page
        async function initializePage() {
            await loadDatabaseMetadata();
            populateFilterDropdowns();
        }

        // Load metadata about database structure
        async function loadDatabaseMetadata() {
            try {
                // Get a sample of the archive to extract structure
                const archiveRef = db.ref('trivia-archive/archive');
                const snapshot = await archiveRef.limitToLast(3).once('value');
                const data = snapshot.val();
                
                if (!data) return;
                
                console.log('Loading metadata from sample data...');
                
                // Process each trivia set to extract rounds and formats
                for (const [triviaNumber, triviaSet] of Object.entries(data)) {
                    if (!triviaSet.trivia) continue;
                    
                    // Extract rounds
                    for (const roundKey of Object.keys(triviaSet.trivia)) {
                        if (typeof triviaSet.trivia[roundKey] !== 'object') continue;
                        dbMetadata.rounds.add(roundKey);
                        
                        // Extract formats for each round
                        const round = triviaSet.trivia[roundKey];
                        for (const formatKey of Object.keys(round)) {
                            if (typeof round[formatKey] !== 'object') continue;
                            dbMetadata.formats.add(formatKey);
                            
                            // Extract fields from a sample question
                            const format = round[formatKey];
                            // Find a question
                            for (const qKey of Object.keys(format)) {
                                const question = format[qKey];
                                if (typeof question === 'object' && question !== null) {
                                    // Extract field names
                                    for (const fieldName of Object.keys(question)) {
                                        dbMetadata.fields.add(fieldName);
                                    }
                                    break; // Just need one question for fields
                                }
                            }
                        }
                    }
                }
                
                console.log('Database metadata loaded:', {
                    rounds: Array.from(dbMetadata.rounds),
                    formats: Array.from(dbMetadata.formats),
                    fields: Array.from(dbMetadata.fields)
                });
            } catch (error) {
                console.error('Error loading database metadata:', error);
            }
        }

        // Populate dropdowns with database values
        function populateFilterDropdowns() {
            // Populate round filter
            const roundOptions = Array.from(dbMetadata.rounds)
                .sort((a, b) => {
                    // Sort numerically if possible
                    const numA = parseInt(a);
                    const numB = parseInt(b);
                    if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                    return a.localeCompare(b);
                });
                
            roundFilter.innerHTML = '<option value="">All Rounds</option>';
            for (const round of roundOptions) {
                const option = document.createElement('option');
                option.value = round;
                option.textContent = round.startsWith('final') ? 'Final' : `Round ${round}`;
                roundFilter.appendChild(option);
            }
            
            // Populate format filter
            const formatOptions = Array.from(dbMetadata.formats).sort();
            formatFilter.innerHTML = '<option value="">All Formats</option>';
            for (const format of formatOptions) {
                const option = document.createElement('option');
                option.value = format;
                option.textContent = format;
                formatFilter.appendChild(option);
            }
            
            // Populate field filter with common fields
            // We'll keep this manual to ensure consistent naming and order
            fieldFilter.innerHTML = '<option value="">All Fields</option>';
            const commonFields = ['Question', 'Answer', 'Hidden Structure_Theme', 'Round Name', 'Round Instruction'];
            
            // Add other fields from metadata
            const allFields = new Set([...commonFields, ...dbMetadata.fields]);
            const fieldOptions = Array.from(allFields).sort();
            
            for (const field of fieldOptions) {
                // Skip internal fields or fields with no valuable search content
                if (field === 'uid' || field === 'id' || field === 'createdAt' || field === 'updatedAt') continue;
                
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field.replace(/_/g, ' ');
                fieldFilter.appendChild(option);
            }
        }

        // Convert wildcards to regex pattern
        function wildcardToRegExp(s) {
            if (!s || !s.includes('*') && !s.includes('?')) {
                return null; // Return null if there are no wildcards
            }
            
            // Escape special regex chars except * and ?
            let pattern = s.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            
            // Convert * and ? to their regex equivalents
            pattern = pattern.replace(/\*/g, '.*').replace(/\?/g, '.');
            
            // Return RegExp object with case-insensitive flag
            return new RegExp('^' + pattern + '$', 'i');
        }
        
        // Test if a string matches a query (either contains or matches wildcard)
        function matchesQuery(text, query) {
            if (!text || !query) return false;
            
            // Ensure we're working with strings
            const textStr = String(text);
            const queryStr = String(query);
            
            // Check if query has wildcards
            const regexPattern = wildcardToRegExp(queryStr);
            
            if (regexPattern) {
                // Split into words and test each word
                return textStr.toLowerCase().split(/\s+/).some(word => regexPattern.test(word));
            } else {
                // Normal contains check (case insensitive)
                return textStr.toLowerCase().includes(queryStr.toLowerCase());
            }
        }
        
        // Check if user is admin
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                try {
                    // Get user data
                    const snapshot = await db.ref(`users/${user.uid}`).once('value');
                    const userData = snapshot.val() || {};
                    
                    // Check for admin role - in both new roles array and old role field
                    const isAdmin = 
                        (userData.roles && Array.isArray(userData.roles) && userData.roles.includes('admin')) ||
                        (userData.role === 'admin');
                    
                    if (isAdmin) {
                        // User is admin, show search interface
                        authScreen.classList.add('hidden');
                        searchScreen.classList.remove('hidden');
                        initializePage(); // Initialize dropdowns and metadata
                    } else {
                        // User is not admin
                        authScreen.classList.remove('hidden');
                        searchScreen.classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Error checking user role:', error);
                    authScreen.classList.remove('hidden');
                    searchScreen.classList.add('hidden');
                }
            } else {
                // User is not signed in
                authScreen.classList.remove('hidden');
                searchScreen.classList.add('hidden');
            }
        });
        
        // Search function
        async function searchQuestions() {
            // Update search state
            currentSearch.query = searchQuery.value.trim();
            currentSearch.format = formatFilter.value;
            currentSearch.round = roundFilter.value;
            currentSearch.field = fieldFilter.value;
            currentSearch.sort = sortFilter.value;
            currentSearch.lastKey = null;
            currentSearch.results = [];
            
            // Clear previous results
            resultsBody.innerHTML = '';
            noResults.classList.add('hidden');
            loadMoreSection.classList.add('hidden');
            
            // Perform search
            await loadQuestions();
        }
        
        // Load questions from Firebase
        async function loadQuestions(loadMore = false) {
            try {
                if (!loadMore) {
                    // New search, reset results
                    currentSearch.results = [];
                    currentSearch.lastKey = null;
                    currentSearch.endReached = false;
                    endResults.classList.add('hidden');
                }
                
                // Don't try to load more if we've already reached the end
                if (currentSearch.endReached) {
                    console.log('Already reached end of results');
                    return;
                }
                
                // Log for debugging
                console.log('Starting search with query:', currentSearch.query);
                console.log('Search filters:', {
                    round: currentSearch.round,
                    format: currentSearch.format,
                    field: currentSearch.field,
                    sort: currentSearch.sort
                });
                
                // Track if we need to load more batches to reach 50 results
                let continueLoading = true;
                let batchesLoaded = 0;
                const maxBatches = 10; // Prevent infinite loading
                let allResults = [];
                
                // Keep loading batches until we have 50 results or exhaust data
                while (continueLoading && batchesLoaded < maxBatches) {
                    batchesLoaded++;
                    const batchResults = await loadQuestionBatch(loadMore || batchesLoaded > 1);
                    
                    if (batchResults.length === 0) {
                        // No more results found
                        console.log('No more results found after batch', batchesLoaded);
                        currentSearch.endReached = true;
                        continueLoading = false;
                    } else {
                        allResults = [...allResults, ...batchResults];
                        
                        // Check if we have enough results or hit the last batch
                        if (currentSearch.results.length + allResults.length >= 50 || !currentSearch.hasMore) {
                            console.log('Reached sufficient results or end of data');
                            continueLoading = false;
                        }
                    }
                }
                
                console.log('Search complete, found total results:', allResults.length);
                
                // Update display
                displayResults(allResults, loadMore);
                
                // Show end of results message if appropriate
                if (currentSearch.endReached) {
                    endResults.classList.remove('hidden');
                    loadMoreSection.classList.add('hidden');
                } else {
                    endResults.classList.add('hidden');
                    loadMoreSection.classList.toggle('hidden', !currentSearch.hasMore);
                }
                
            } catch (error) {
                console.error('Error searching questions:', error);
            }
        }
        
        // Load a batch of questions from Firebase
        async function loadQuestionBatch(loadMore = false) {
            // Get reference to trivia-archive
            const archiveRef = db.ref('trivia-archive/archive');
            
            // Start by querying trivia numbers (sort by key in reverse for newest first)
            let triviaQuery = archiveRef.orderByKey();
            
            if (currentSearch.sort === 'newest') {
                // For newest first, we start at the end and move backward
                if (loadMore && currentSearch.lastKey) {
                    triviaQuery = triviaQuery.endAt(currentSearch.lastKey);
                }
                triviaQuery = triviaQuery.limitToLast(10); // Get more trivia sets at a time
            } else {
                // For oldest first, we start at the beginning and move forward
                if (loadMore && currentSearch.lastKey) {
                    triviaQuery = triviaQuery.startAt(currentSearch.lastKey);
                }
                triviaQuery = triviaQuery.limitToFirst(10); // Get more trivia sets at a time
            }
            
            // Get trivia numbers
            const triviaSnap = await triviaQuery.once('value');
            const triviaData = triviaSnap.val();
            
            if (!triviaData) {
                // No trivia found
                console.log('No trivia data found');
                if (!loadMore) {
                    noResults.classList.remove('hidden');
                    resultsCount.textContent = '0';
                }
                loadMoreSection.classList.add('hidden');
                return [];
            }
            
            // Convert to array and sort
            let triviaItems = Object.entries(triviaData).map(([triviaNumber, data]) => ({
                triviaNumber,
                data
            }));
            
            // Sort by trivia number (newest first or oldest first)
            if (currentSearch.sort === 'newest') {
                triviaItems.sort((a, b) => b.triviaNumber.localeCompare(a.triviaNumber));
            } else {
                triviaItems.sort((a, b) => a.triviaNumber.localeCompare(b.triviaNumber));
            }
            
            console.log('Processing trivia items:', triviaItems.length);
            
            // Process each trivia set
            const results = [];
            let processedCount = 0;
            let reachedLimit = false;
            
            for (const item of triviaItems) {
                // Skip the first item if loading more (it was the last key from previous batch)
                if (loadMore && processedCount === 0 && currentSearch.lastKey === item.triviaNumber) {
                    processedCount++;
                    continue;
                }
                
                processedCount++;
                console.log('Processing trivia #:', item.triviaNumber);
                
                // First, check if this trivia set has a "trivia" node
                const triviaRef = db.ref(`trivia-archive/archive/${item.triviaNumber}`);
                const triviaSnap = await triviaRef.once('value');
                const triviaData = triviaSnap.val();
                
                if (!triviaData) {
                    console.log('No data for trivia #:', item.triviaNumber);
                    continue;
                }

                // Check if the trivia data has a "trivia" subnode
                const triviaNode = triviaData.trivia || null;
                if (!triviaNode) {
                    console.log('No trivia node found for trivia #:', item.triviaNumber);
                    continue;
                }

                console.log('Found trivia node with rounds:', Object.keys(triviaNode));
                
                // Get trivia metadata
                const triviaNumber = item.triviaNumber;
                const triviaName = triviaData.name || '';
                const triviaDate = triviaData.date || '';
                
                // Process each round in the trivia set
                for (const [roundKey, roundData] of Object.entries(triviaNode)) {
                    // Skip non-object values
                    if (typeof roundData !== 'object' || roundData === null) continue;
                    
                    // Apply round filter
                    if (currentSearch.round && currentSearch.round !== roundKey) continue;
                    
                    console.log('Processing round:', roundKey, 'with formats:', Object.keys(roundData));
                    
                    // Get round metadata
                    const roundName = getRoundName(triviaNode, roundKey);
                    
                    // Process each format in the round
                    for (const [formatKey, formatData] of Object.entries(roundData)) {
                        // Skip non-object values
                        if (typeof formatData !== 'object' || formatData === null) continue;
                        
                        // Apply format filter
                        if (currentSearch.format && currentSearch.format !== formatKey) continue;
                        
                        console.log('Processing format:', formatKey, 'with questions:', Object.keys(formatData).length);
                        
                        // Process each question in the format
                        for (const [questionKey, questionData] of Object.entries(formatData)) {
                            // Skip non-object values
                            if (typeof questionData !== 'object' || questionData === null) continue;
                            
                            // Skip non-numeric question keys (other metadata)
                            if (isNaN(questionKey) && !/^\d+$/.test(questionKey)) continue;
                            
                            // Check if this question matches our search criteria
                            let matches = false;
                            
                            if (currentSearch.query) {
                                // If searching for a specific field
                                if (currentSearch.field) {
                                    // Check if the question has the field we're looking for
                                    const fieldValue = questionData[currentSearch.field];
                                    if (fieldValue && matchesQuery(fieldValue, currentSearch.query)) {
                                        matches = true;
                                    }
                                } else {
                                    // Search in all fields
                                    for (const [fieldName, fieldValue] of Object.entries(questionData)) {
                                        // Skip empty values or non-string/number values
                                        if (!fieldValue || (typeof fieldValue !== 'string' && typeof fieldValue !== 'number')) continue;
                                        
                                        if (matchesQuery(fieldValue, currentSearch.query)) {
                                            matches = true;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                // No query, so it matches if it passes the round/format filters
                                matches = true;
                            }
                            
                            if (matches) {
                                const resultItem = {
                                    triviaNumber: triviaNumber,
                                    triviaName: triviaName,
                                    triviaDate: triviaDate,
                                    round: roundKey,
                                    roundName: roundName,
                                    format: formatKey,
                                    questionNum: questionKey,
                                    questionData: questionData
                                };
                                
                                results.push(resultItem);
                            }
                        }
                    }
                }
                
                // Remember the last key for pagination only if we processed this trivia
                if (processedCount > 1) {
                    currentSearch.lastKey = item.triviaNumber;
                }
            }
            
            // Update paging info - we have more if we found at least one item and processed more than 1
            currentSearch.hasMore = results.length > 0 && processedCount > 1;
            
            return results;
        }
        
        // Helper function to get a round name from trivia data
        function getRoundName(triviaNode, roundKey) {
            try {
                // Try to find round name in different possible locations
                if (triviaNode[roundKey] && triviaNode[roundKey]['Round Name']) {
                    return triviaNode[roundKey]['Round Name'];
                }
                
                if (triviaNode[roundKey] && typeof triviaNode[roundKey] === 'object') {
                    // Look through formats for round name
                    for (const formatKey of Object.keys(triviaNode[roundKey])) {
                        const format = triviaNode[roundKey][formatKey];
                        if (format && format['Round Name']) {
                            return format['Round Name'];
                        }
                        
                        // Look through questions for round name
                        if (format && typeof format === 'object') {
                            for (const qKey of Object.keys(format)) {
                                const q = format[qKey];
                                if (q && q['Round Name']) {
                                    return q['Round Name'];
                                }
                            }
                        }
                    }
                }
                
                // If round is 'final', return "Final Round"
                if (roundKey.toLowerCase().includes('final')) {
                    return "Final Round";
                }
                
                // Default to formatted round number
                return `Round ${roundKey}`;
            } catch (e) {
                console.error('Error getting round name:', e);
                return `Round ${roundKey}`;
            }
        }
        
        // Display search results
        function displayResults(results, appendResults = false) {
            if (!appendResults) {
                resultsBody.innerHTML = '';
            }
            
            if (!results.length && !currentSearch.results.length) {
                noResults.classList.remove('hidden');
                resultsCount.textContent = '0';
                return;
            }
            
            // Add new results to our state
            currentSearch.results = [...currentSearch.results, ...results];
            
            // Update the display
            noResults.classList.add('hidden');
            
            // Add rows to the table
            results.forEach(result => {
                const row = document.createElement('tr');
                
                // Get the data from the question data
                const question = result.questionData.Question || result.questionData.question || '';
                const answer = result.questionData.Answer || result.questionData.answer || '';
                
                // Format the date nicely if available
                const dateStr = formatDate(result.triviaDate);
                
                // Get image links if available
                const imageLink = result.questionData['Image Link'] || result.questionData['image_link'] || '';
                const answerImageLink = result.questionData['Answer Image Link'] || result.questionData['answer_image_link'] || '';
                
                // Create image previews if available
                const imagePreviewsHtml = createImagePreviewsHtml(imageLink, answerImageLink);
                
                row.innerHTML = `
                    <td>${result.triviaNumber}</td>
                    <td>${escapeHTML(dateStr)}</td>
                    <td>${result.round}</td>
                    <td>${escapeHTML(result.roundName || '')}</td>
                    <td>${result.format}</td>
                    <td class="question-text" title="${escapeHTML(question)}">${escapeHTML(question)}</td>
                    <td class="question-text" title="${escapeHTML(answer)}">${escapeHTML(answer)}</td>
                    <td>${imagePreviewsHtml}</td>
                `;
                
                // Add click event to show full details
                row.addEventListener('click', () => showQuestionDetails(result));
                
                resultsBody.appendChild(row);
            });
            
            // Update count
            resultsCount.textContent = currentSearch.results.length;
        }
        
        // Format date string
        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            try {
                // Try to parse and format the date
                // Handle different formats: YYYYMMDD, MM/DD/YYYY, etc.
                let date;
                
                if (/^\d{8}$/.test(dateStr)) {
                    // Format YYYYMMDD
                    const year = dateStr.substring(0, 4);
                    const month = dateStr.substring(4, 6);
                    const day = dateStr.substring(6, 8);
                    date = new Date(`${year}-${month}-${day}`);
                } else {
                    // Try standard date parsing
                    date = new Date(dateStr);
                }
                
                // Check if date is valid
                if (isNaN(date.getTime())) {
                    return dateStr; // Return original if parsing failed
                }
                
                // Format as MM/DD/YYYY
                return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
            } catch (e) {
                console.error('Error formatting date:', e);
                return dateStr; // Return original on error
            }
        }
        
        // Create HTML for image previews
        function createImagePreviewsHtml(imageLink, answerImageLink) {
            let html = '<div class="image-container">';
            
            if (imageLink && isUrl(imageLink)) {
                html += `<img src="${escapeHTML(imageLink)}" alt="Question Image" class="image-preview" title="Question Image" data-full-url="${escapeHTML(imageLink)}">`;
            }
            
            if (answerImageLink && isUrl(answerImageLink)) {
                html += `<img src="${escapeHTML(answerImageLink)}" alt="Answer Image" class="image-preview" title="Answer Image" data-full-url="${escapeHTML(answerImageLink)}">`;
            }
            
            html += '</div>';
            return html;
        }
        
        // Show question details in a modal
        function showQuestionDetails(result) {
            // Create modal element
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '1000';
            
            // Create modal content
            const content = document.createElement('div');
            content.style.backgroundColor = 'white';
            content.style.padding = '30px';
            content.style.borderRadius = '8px';
            content.style.maxWidth = '800px';
            content.style.width = '90%';
            content.style.maxHeight = '80vh';
            content.style.overflowY = 'auto';
            
            // Create header with close button
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.marginBottom = '20px';
            
            const title = document.createElement('h2');
            title.style.margin = '0';
            title.textContent = `Question Details`;
            
            const closeBtn = document.createElement('button');
            closeBtn.id = 'closeModal';
            closeBtn.style.background = 'none';
            closeBtn.style.border = 'none';
            closeBtn.style.fontSize = '24px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.innerHTML = '&times;';
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            header.appendChild(title);
            header.appendChild(closeBtn);
            content.appendChild(header);
            
            // Add basic info fields
            const basicInfoFields = [
                {label: 'Trivia #', value: result.triviaNumber},
                {label: 'Trivia Name', value: result.triviaName},
                {label: 'Round', value: result.round},
                {label: 'Format', value: result.format},
                {label: 'Question #', value: result.questionNum}
            ];
            
            basicInfoFields.forEach(field => {
                if (field.value) {
                    addFieldToModal(content, field.label, field.value);
                }
            });
            
            // Add all question data fields
            for (const [fieldName, fieldValue] of Object.entries(result.questionData)) {
                // Skip empty values or complex objects
                if (!fieldValue || typeof fieldValue === 'object') continue;
                
                // Skip fields we already displayed
                if (basicInfoFields.some(f => f.label === fieldName)) continue;
                
                addFieldToModal(content, fieldName, fieldValue);
            }
            
            // Add content to modal
            modal.appendChild(content);
            
            // Add close event for clicking outside the modal
            modal.addEventListener('click', e => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            // Add to document
            document.body.appendChild(modal);
        }
        
        // Helper function to add a field to the modal
        function addFieldToModal(container, label, value) {
            const wrapper = document.createElement('div');
            wrapper.style.marginBottom = '15px';
            
            const labelElem = document.createElement('strong');
            labelElem.textContent = label + ':';
            wrapper.appendChild(labelElem);
            
            const valueContainer = document.createElement('div');
            valueContainer.style.padding = '10px';
            valueContainer.style.backgroundColor = '#f9f9f9';
            valueContainer.style.borderRadius = '4px';
            valueContainer.style.marginTop = '5px';
            
            // Check if it's an image link or a music link
            if ((label.includes('Image') || label.includes('image')) && typeof value === 'string' && isUrl(value)) {
                const img = document.createElement('img');
                img.src = value;
                img.style.maxWidth = '100%';
                img.style.maxHeight = '300px';
                valueContainer.appendChild(img);
                
                // Also add the raw link
                const linkText = document.createElement('div');
                linkText.style.marginTop = '5px';
                linkText.style.fontSize = '0.8em';
                linkText.style.wordBreak = 'break-all';
                linkText.textContent = value;
                valueContainer.appendChild(linkText);
            } 
            else if ((label.includes('Music') || label.includes('Audio') || label.includes('audio')) && 
                     typeof value === 'string' && isUrl(value)) {
                const audio = document.createElement('audio');
                audio.controls = true;
                audio.src = value;
                valueContainer.appendChild(audio);
                
                // Also add the raw link
                const linkText = document.createElement('div');
                linkText.style.marginTop = '5px';
                linkText.style.fontSize = '0.8em';
                linkText.style.wordBreak = 'break-all';
                linkText.textContent = value;
                valueContainer.appendChild(linkText);
            }
            else if (typeof value === 'string' && isUrl(value)) {
                // For other URLs, make them clickable
                const link = document.createElement('a');
                link.href = value;
                link.target = '_blank';
                link.textContent = value;
                link.style.wordBreak = 'break-all';
                valueContainer.appendChild(link);
            }
            else {
                valueContainer.textContent = value;
            }
            
            wrapper.appendChild(valueContainer);
            container.appendChild(wrapper);
        }
        
        // Helper function to check if a string is a URL
        function isUrl(str) {
            try {
                return str.startsWith('http://') || str.startsWith('https://');
            } catch (e) {
                return false;
            }
        }
        
        // Helper function to escape HTML
        function escapeHTML(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }
        
        // Event listeners
        searchBtn.addEventListener('click', searchQuestions);
        searchQuery.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchQuestions();
            }
        });
        
        clearBtn.addEventListener('click', () => {
            // Clear inputs
            searchQuery.value = '';
            formatFilter.value = '';
            roundFilter.value = '';
            fieldFilter.value = '';
            sortFilter.value = 'newest';
            
            // Clear results
            resultsBody.innerHTML = '';
            noResults.classList.add('hidden');
            endResults.classList.add('hidden');
            loadMoreSection.classList.add('hidden');
            resultsCount.textContent = '0';
            
            // Reset search state
            currentSearch = {
                query: '',
                format: '',
                round: '',
                field: '',
                sort: 'newest',
                lastKey: null,
                results: [],
                hasMore: false,
                endReached: false
            };
        });
        
        loadMoreBtn.addEventListener('click', () => {
            loadQuestions(true);
        });
        
        // Event delegation for image previews
        document.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('image-preview')) {
                e.stopPropagation(); // Don't open the question details modal
                const fullUrl = e.target.getAttribute('data-full-url');
                if (fullUrl) {
                    openImageModal(fullUrl, e.target.getAttribute('title') || 'Image');
                }
            }
        });
        
        // Open a full-size image in a modal
        function openImageModal(imageUrl, title) {
            // Create modal element
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '2000';
            
            // Create image container
            const container = document.createElement('div');
            container.style.position = 'relative';
            container.style.maxWidth = '90%';
            container.style.maxHeight = '90%';
            
            // Create title
            const titleElement = document.createElement('div');
            titleElement.textContent = title;
            titleElement.style.color = 'white';
            titleElement.style.position = 'absolute';
            titleElement.style.top = '-40px';
            titleElement.style.left = '0';
            titleElement.style.fontSize = '20px';
            titleElement.style.fontWeight = 'bold';
            
            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '-40px';
            closeBtn.style.right = '0';
            closeBtn.style.backgroundColor = 'transparent';
            closeBtn.style.border = 'none';
            closeBtn.style.color = 'white';
            closeBtn.style.fontSize = '30px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            // Create image
            const img = document.createElement('img');
            img.src = imageUrl;
            img.style.maxWidth = '100%';
            img.style.maxHeight = '80vh';
            img.style.objectFit = 'contain';
            img.style.border = '2px solid white';
            
            // Add elements to container
            container.appendChild(titleElement);
            container.appendChild(closeBtn);
            container.appendChild(img);
            
            // Add container to modal
            modal.appendChild(container);
            
            // Add close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            // Add to document
            document.body.appendChild(modal);
        }
        
        console.log("Search tool loaded successfully!");
    </script>
</body>
</html> 