<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evil Trivia - Regex Tool</title>
    <script src="/js/components/autoload-banner.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #FFCC00;
            margin-top: 60px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .content-box {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .auth-container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            margin: 40px auto;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .auth-container h2 {
            margin-top: 0;
            color: #333;
        }
        
        .auth-container p {
            margin-bottom: 20px;
            color: #666;
        }
        
        .auth-btn {
            display: inline-block;
            background-color: #000;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .hidden {
            display: none;
        }
        
        /* New styles for the regex tool */
        .search-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .search-row {
            display: flex;
            gap: 10px;
        }
        
        .search-input {
            font-size: 16px;
            padding: 12px 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            flex: 1;
        }
        
        .search-button {
            font-size: 16px;
            padding: 12px 25px;
            background-color: #000;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .file-select {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .file-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        /* Manual file input styles */
        .file-input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            margin-top: 15px;
        }
        
        .manual-file-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .manual-file-list .file-checkbox {
            margin-bottom: 5px;
        }
        
        #manual-files {
            margin-top: 10px;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .results-table th {
            background-color: #f2f2f2;
            padding: 10px;
            text-align: left;
            border-bottom: 2px solid #ddd;
        }
        
        .results-table td {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .results-container {
            margin-top: 20px;
        }
        
        .load-more {
            display: block;
            margin: 20px auto;
            background-color: #000;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .no-results {
            text-align: center;
            padding: 30px;
            color: #666;
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
        }
        
        .loading:after {
            content: "";
            width: 20px;
            height: 20px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #000;
            border-radius: 50%;
            margin-left: 10px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info-message {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .wild-card-info {
            margin-top: 10px;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
        }
        
        .wild-card-info h3 {
            margin-top: 0;
        }
        
        .wild-card-info ul {
            margin-bottom: 0;
        }
        
        .error-message {
            color: #d9534f;
            background-color: #f8d7da;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .result-count {
            font-weight: bold;
            margin-bottom: 15px;
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-radius: 4px;
            display: inline-block;
        }
        
        /* Additional styles for clipboard functionality and links */
        .clipboard-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            overflow: hidden;
            border: 1px solid #ddd;
        }
        
        .clipboard-header {
            padding: 10px 15px;
            background-color: #f2f2f2;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
            cursor: pointer;
        }
        
        .clipboard-title {
            font-weight: bold;
            margin: 0;
        }
        
        .clipboard-content {
            padding: 10px 15px;
            overflow-y: auto;
            max-height: 200px;
            flex-grow: 1;
        }
        
        .clipboard-item {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .clipboard-actions {
            padding: 10px 15px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid #ddd;
        }
        
        .clipboard-btn {
            background-color: #000;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .clipboard-toggle {
            background-color: #f2f2f2;
            color: #333;
            border: 1px solid #ddd;
            min-width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .clipboard-clear {
            background-color: #d9534f;
        }
        
        .clipboard-copy {
            background-color: #5cb85c;
        }
        
        .remove-item {
            color: #d9534f;
            cursor: pointer;
            font-size: 18px;
        }
        
        .add-to-clipboard {
            background-color: #5cb85c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .collapsed {
            max-height: 50px;
            opacity: 0.9;
        }
        
        .collapsed .clipboard-content,
        .collapsed .clipboard-actions {
            display: none;
        }
        
        .dictionary-link {
            color: #007bff;
            text-decoration: none;
        }
        
        .dictionary-link:hover {
            text-decoration: underline;
        }
        
        /* Add responsive adjustments for very small screens */
        @media (max-width: 480px) {
            .clipboard-container {
                top: 60px;
                right: 10px;
                max-height: 50vh;
            }
            
            .clipboard-actions {
                flex-direction: column;
                gap: 5px;
            }
            
            .clipboard-btn {
                width: 100%;
            }
        }

        /* Filters UI */
        .filters-container {
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-top: 20px;
        }
        .filters-header {
            padding: 10px 15px;
            background-color: #f2f2f2;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
        }
        .filters-title {
            font-weight: bold;
            margin: 0;
        }
        .filters-content {
            padding: 10px 15px;
        }
        .filters-container.collapsed .filters-content {
            display: none;
        }
        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .filter-chip {
            background: #f2f2f2;
            border: 1px solid #ddd;
            border-radius: 16px;
            padding: 6px 10px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .filter-chip .remove-item {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Regex Tool</h1>
        
        <div style="background-color: #e8f5e8; border: 1px solid #4caf50; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
            <h3 style="margin-top: 0; color: #2e7d32;">⚡ Want Lightning-Fast Search?</h3>
            <p style="margin-bottom: 10px;">Try our new <strong>Ultra Fast Search Engine</strong> for instant results!</p>
            <a href="/tools/fastsearch" style="color: #2e7d32; font-weight: bold; text-decoration: none;">→ Open Ultra Fast Search</a>
        </div>
        
        <!-- Authentication Required Screen -->
        <div id="auth-screen" class="auth-container hidden">
            <h2>Access Required</h2>
            <p>You need admin privileges to access this page.</p>
            <a href="/account" class="auth-btn">Go to Account Page</a>
        </div>
        
        <!-- Tool Interface -->
        <div id="tool-screen" class="hidden">
            <div class="content-box">
                <h2>Search Terms</h2>
                
                <div class="wild-card-info">
                    <h3>Search Options:</h3>
                    <ul>
                        <li><strong>apple</strong> - Exact match (not case sensitive)</li>
                        <li><strong>*apple*</strong> - Contains "apple" anywhere in the term</li>
                        <li><strong>apple*</strong> - Begins with "apple"</li>
                        <li><strong>*apple</strong> - Ends with "apple"</li>
                        <li><strong>?</strong> - Matches any single character (e.g., "apple?" could match "apples")</li>
                        <li><strong>Crossword Mode:</strong> When enabled, ? only counts letters (A-Z) and ignores spaces/punctuation. Example: "?????" matches "Wall-E" (5 letters)</li>
                        <li><strong>Variable Mode:</strong> Each letter represents a variable that must be consistent. Example: "X Y X" matches "MOM" (M-O-M) or "DAD" (D-A-D)</li>
                        <li><strong>Variable Mode + Ignore Spaces:</strong> Same as Variable Mode but spaces are ignored. Example: "X Y X" can match "A LA" (A-L-A)</li>
                    </ul>
                </div>
                
                <div class="search-container">
                    <div class="search-row">
                        <input type="text" id="search-input" class="search-input" placeholder="Enter search term (e.g., apple, *apple*, a?ple, X Y X for Variable Mode)">
                        <button id="search-button" class="search-button">Search</button>
                    </div>
                    
                    <div class="search-row" style="margin-top: 10px; justify-content: flex-start;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="crossword-mode" style="margin: 0;">
                            <span>Crossword Mode (? only matches letters, not spaces or special characters)</span>
                        </label>
                    </div>
                    
                    <div class="search-row" style="margin-top: 10px; justify-content: flex-start;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="variable-mode" style="margin: 0;">
                            <span>Variable Mode (each letter represents a variable, e.g., "X Y X" matches patterns like "MOM")</span>
                        </label>
                    </div>
                    
                    <div id="variable-mode-options" class="search-row" style="margin-top: 5px; margin-left: 20px; justify-content: flex-start; display: none;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="ignore-spaces-mode" style="margin: 0;">
                            <span>Ignore spaces (allows "X Y X" to match "A LA")</span>
                        </label>
                    </div>
                    
                    <div>
                        <h3>Select Files:</h3>
                        <div id="file-select" class="file-select">
                            <p>Loading available files...</p>
                        </div>
                    </div>

                    <!-- Filters (optional) -->
                    <div id="filters-container" class="filters-container collapsed">
                        <div class="filters-header" id="filters-header">
                            <h3 class="filters-title">Filters (optional)</h3>
                            <button id="toggle-filters" class="clipboard-btn clipboard-toggle">▼</button>
                        </div>
                        <div class="filters-content">
                            <div class="info-message" style="margin-bottom: 10px;">
                                Add patterns to exclude from the results below. Supports wildcards: <code>*</code> (any chars) and <code>?</code> (single char). Matching is case-insensitive and uses "contains" by default.
                            </div>
                            <div class="file-input-row">
                                <input type="text" id="exclude-input" class="search-input" placeholder="Exclude pattern (e.g., the , the *, * the, *the*)">
                                <button id="add-exclude-btn" class="search-button">Add Filter</button>
                                <button id="clear-exclusions-btn" class="clipboard-btn clipboard-clear" title="Clear all filters">Clear</button>
                            </div>
                            <div id="exclude-list" class="filter-chips">
                                <!-- Filter chips will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Clipboard Container - Now between search and results -->
            <div id="clipboard-container" class="clipboard-container content-box collapsed">
                <div class="clipboard-header">
                    <h3 class="clipboard-title">Collected Terms</h3>
                    <button id="toggle-clipboard" class="clipboard-btn clipboard-toggle">▼</button>
                </div>
                <div id="clipboard-content" class="clipboard-content">
                    <p>No terms added yet.</p>
                </div>
                <div class="clipboard-actions">
                    <button id="clear-clipboard" class="clipboard-btn clipboard-clear">Clear All</button>
                    <button id="copy-clipboard" class="clipboard-btn clipboard-copy">Copy All</button>
                </div>
            </div>
            
            <div class="content-box">
                <h2>Search Results</h2>
                <div id="results-container" class="results-container">
                    <p class="no-results">Enter a search term and select files to see results.</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-functions-compat.js"></script>
    
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
            authDomain: "eviltrivia-47664.firebaseapp.com",
            databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
            projectId: "eviltrivia-47664",
            storageBucket: "eviltrivia-47664.firebasestorage.app",
            messagingSenderId: "401826818140",
            appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
            measurementId: "G-2W6RK96Y34"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();
        const functions = firebase.functions();
        
        // DOM Elements
        const authScreen = document.getElementById('auth-screen');
        const toolScreen = document.getElementById('tool-screen');
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const fileSelectContainer = document.getElementById('file-select');
        const resultsContainer = document.getElementById('results-container');
        const variableModeCheckbox = document.getElementById('variable-mode');
        const variableModeOptions = document.getElementById('variable-mode-options');
        const ignoreSpacesCheckbox = document.getElementById('ignore-spaces-mode');
        
        // Global variables
        let availableFiles = [];
        let lastLoadedItems = {};
        const resultsPerPage = 50;
        // Fetch up to this many scores per network request (reduces round-trips)
        const scoreWindowSize = 50; // Increased from 10 to reduce network requests
        // Timeout per batch before we render partial results
        const batchTimeoutMs = 30000; // Reduced to 30s for faster feedback
        // Cache for file existence checks
        const fileExistsCache = new Map();
        // Cache for search results
        const searchResultsCache = new Map();
        let userIsAdmin = false;
        // Clipboard array to store terms
        let clipboardTerms = [];
        // Exclude patterns (raw strings from UI)
        let excludePatterns = [];
        // Track search state for pagination
        let currentSearchState = {
            searchTerm: '',
            pattern: null,
            selectedFiles: [],
            fileIndex: 0,
            scoreRanges: [],
            scoreRangeIndex: 0,
            currentScore: 0,
            hasMoreResults: false,
            resultsFound: 0,
            excludeRegexes: []
        };
        
        // Check if user is admin
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                try {
                    // Get user data
                    const snapshot = await db.ref(`users/${user.uid}`).once('value');
                    const userData = snapshot.val() || {};
                    
                    // Check for admin role - in both new roles array and old role field
                    const isAdmin = 
                        (userData.roles && Array.isArray(userData.roles) && userData.roles.includes('admin')) ||
                        (userData.role === 'admin');
                    
                    if (isAdmin) {
                        // User is admin, show tool interface
                        authScreen.classList.add('hidden');
                        toolScreen.classList.remove('hidden');
                        userIsAdmin = true;
                        
                        // Try to load file names from tools branch
                        loadToolsFileNames();
                    } else {
                        // User does not have access
                        authScreen.classList.remove('hidden');
                        toolScreen.classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Error checking user role:', error);
                    authScreen.classList.remove('hidden');
                    toolScreen.classList.add('hidden');
                }
            } else {
                // User is not signed in
                authScreen.classList.remove('hidden');
                toolScreen.classList.add('hidden');
            }
        });
        
        // Load file names directly from the tools branch
        async function loadToolsFileNames() {
            // Hard-coded fallback list - using this if Firebase fails
            const knownFiles = ['RankedWiki_txt', 'RankedWiktionary_txt', 'ScrabbleDict_txt', 'jeopardy_wordlist_txt'];
            
            try {
                // Add a timeout for the file loading
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('File loading timed out')), 5000); // 5 second timeout
                });
                
                // Use the shallow option to only get the keys without any data
                const fetchPromise = db.ref('tools').shallow(true).once('value');
                
                // Race the fetch against the timeout
                const snapshot = await Promise.race([fetchPromise, timeoutPromise]);
                
                if (snapshot.exists()) {
                    // Extract just the file names (which are the direct children keys)
                    const fileNames = Object.keys(snapshot.val() || {});
                    
                    if (fileNames.length > 0) {
                        // Successfully got file names
                        console.log("Found files in database:", fileNames);
                        availableFiles = fileNames;
                        showFileSelectionInterface(fileNames);
                        return;
                    }
                }
                
                // If we can't get the files from Firebase, use the hard-coded list
                console.log("Using fallback file list");
                availableFiles = knownFiles;
                showFileSelectionInterface(knownFiles);
            } catch (error) {
                console.error('Error loading tool file names:', error);
                
                // Always fall back to the known files if there's any error
                availableFiles = knownFiles;
                showFileSelectionInterface(knownFiles);
            }
        }
        
        // Show file selection interface with checkboxes
        function showFileSelectionInterface(fileNames) {
            // Create a simple list of checkboxes, one for each file
            let html = '';
            
            fileNames.forEach(fileName => {
                html += `
                    <div class="file-checkbox">
                        <input type="checkbox" id="file-${fileName}" value="${fileName}" checked>
                        <label for="file-${fileName}">${fileName}</label>
                    </div>
                `;
            });
            
            // Update the file select container
            fileSelectContainer.innerHTML = html || '<p>No files found. Please check the database.</p>';
        }
        
        // Display manual file input
        function showManualFileInput() {
            fileSelectContainer.innerHTML = `
                <div class="info-message">
                    <strong>File Selection:</strong> Add the database files you want to search through.
                    <p>Common files: <code>RankedWiki_txt</code>, <code>RankedWiktionary_txt</code>, <code>ScrabbleDict_txt</code>, <code>jeopardy_wordlist_txt</code></p>
                </div>
                <div class="error-message" style="background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba;">
                    Could not load files automatically. Please specify file names below.
                </div>
                <div id="manual-files">
                    <div class="file-input-row">
                        <input type="text" class="search-input" placeholder="Enter file name (e.g., RankedWiki_txt)" value="RankedWiki_txt">
                        <button class="search-button add-file-btn">Add File</button>
                    </div>
                    <div class="manual-file-list">
                        <!-- Files will be added here -->
                    </div>
                </div>
            `;
            
            // Add event listener for the "Add File" button
            const addFileBtn = fileSelectContainer.querySelector('.add-file-btn');
            const fileInput = fileSelectContainer.querySelector('.file-input-row input');
            const fileList = fileSelectContainer.querySelector('.manual-file-list');
            
            addFileBtn.addEventListener('click', () => {
                const fileName = fileInput.value.trim();
                if (fileName) {
                    // Add to availableFiles array if not already there
                    if (!availableFiles.includes(fileName)) {
                        availableFiles.push(fileName);
                        
                        // Create checkbox for the file
                        const fileCheckbox = document.createElement('div');
                        fileCheckbox.className = 'file-checkbox';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `file-${fileName}`;
                        checkbox.value = fileName;
                        checkbox.checked = true; // Check it by default
                        
                        const label = document.createElement('label');
                        label.htmlFor = `file-${fileName}`;
                        label.textContent = fileName;
                        
                        fileCheckbox.appendChild(checkbox);
                        fileCheckbox.appendChild(label);
                        fileList.appendChild(fileCheckbox);
                        
                        // Clear input
                        fileInput.value = '';
                    } else {
                        alert(`File "${fileName}" is already in the list`);
                    }
                } else {
                    alert('Please enter a file name');
                }
            });
            
            // Also allow pressing Enter to add a file
            fileInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addFileBtn.click();
                }
            });
            
            // Add RankedWiki.txt as the default file if input is pre-filled
            if (fileInput.value.trim()) {
                addFileBtn.click();
            }
        }
        
        // Convert variable pattern to regex (for Variable Mode)
        function variableToRegex(pattern) {
            const ignoreSpacesElement = document.getElementById('ignore-spaces-mode');
            const ignoreSpaces = ignoreSpacesElement ? ignoreSpacesElement.checked : false;
            
            // Pre-process pattern to remove spaces if ignore spaces is enabled
            let processedPattern = pattern;
            if (ignoreSpaces) {
                processedPattern = pattern.replace(/\s+/g, '');
            }
            
            // Create a map to track variables and their corresponding regex groups
            const variableMap = new Map();
            let groupCounter = 1;
            let regexPattern = '^';
            
            for (let i = 0; i < processedPattern.length; i++) {
                const char = processedPattern[i];
                
                // Skip spaces if not ignoring them (they should match literally)
                if (!ignoreSpaces && char === ' ') {
                    regexPattern += ' ';
                    continue;
                }
                
                // Check if this character is a variable (letter)
                if (/[A-Za-z]/.test(char)) {
                    const upperChar = char.toUpperCase();
                    
                    if (variableMap.has(upperChar)) {
                        // Reference existing group
                        const groupNum = variableMap.get(upperChar);
                        regexPattern += `\\${groupNum}`;
                    } else {
                        // Create new capturing group
                        variableMap.set(upperChar, groupCounter);
                        regexPattern += '(.)';
                        groupCounter++;
                    }
                } else {
                    // Non-letter characters match literally (escaped if special regex chars)
                    regexPattern += char.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                }
            }
            
            regexPattern += '$';
            
            // If ignore spaces is enabled, we need to handle spaces in the target string
            if (ignoreSpaces) {
                // Create a special regex that ignores spaces in the target
                // We'll need a more complex approach for this
                return createSpaceIgnoringRegex(pattern, variableMap);
            }
            
            return new RegExp(regexPattern, 'i');
        }
        
        // Create a regex that ignores spaces when matching variable patterns
        function createSpaceIgnoringRegex(pattern, variableMap) {
            // For ignore spaces mode, we need to match the pattern while allowing spaces anywhere in the target
            // This is complex, so we'll use a different approach: a custom matching function
            const processedPattern = pattern.replace(/\s+/g, '');
            
            return {
                test: function(target) {
                    const cleanTarget = target.replace(/\s+/g, '');
                    
                    if (cleanTarget.length !== processedPattern.length) {
                        return false;
                    }
                    
                    const assignments = new Map();
                    
                    for (let i = 0; i < processedPattern.length; i++) {
                        const patternChar = processedPattern[i].toUpperCase();
                        const targetChar = cleanTarget[i].toLowerCase();
                        
                        if (/[A-Za-z]/.test(patternChar)) {
                            // This is a variable
                            if (assignments.has(patternChar)) {
                                // Check if it matches the previous assignment
                                if (assignments.get(patternChar) !== targetChar) {
                                    return false;
                                }
                            } else {
                                // New assignment
                                assignments.set(patternChar, targetChar);
                            }
                        } else {
                            // Literal character must match exactly
                            if (patternChar.toLowerCase() !== targetChar) {
                                return false;
                            }
                        }
                    }
                    
                    return true;
                }
            };
        }
        
        // Convert wildcard pattern to regex
        function wildcardToRegex(pattern) {
            // Check if Variable Mode is enabled
            const variableModeElement = document.getElementById('variable-mode');
            const variableMode = variableModeElement ? variableModeElement.checked : false;
            
            if (variableMode) {
                return variableToRegex(pattern);
            }
            
            // Get crossword mode state
            const crosswordModeElement = document.getElementById('crossword-mode');
            const crosswordMode = crosswordModeElement ? crosswordModeElement.checked : false;
            
            if (!crosswordMode) {
                // Standard mode - same as before
                // Escape special regex characters except * and ?
                let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                
                // Convert * to regex .*
                regexPattern = regexPattern.replace(/\*/g, '.*');
                
                // Convert ? to regex . (matches any character)
                regexPattern = regexPattern.replace(/\?/g, '.');
                
                // Create case-insensitive regex
                return new RegExp(`^${regexPattern}$`, 'i');
            } else {
                // Crossword mode - special handling where ? only counts letters
                
                // First, handle asterisks by replacing them with placeholders
                let preparedPattern = pattern.replace(/\*/g, '###ASTERISK###');
                
                // Count the number of question marks
                const questionMarkCount = (preparedPattern.match(/\?/g) || []).length;
                
                if (questionMarkCount === 0) {
                    // No ? wildcards, just handle as normal but with exact letter matching
                    let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                    regexPattern = regexPattern.replace(/\*/g, '.*');
                    return new RegExp(`^${regexPattern}$`, 'i');
                }
                
                // Special case: pattern is all question marks (e.g., "?????")
                if (preparedPattern.replace(/\?/g, '') === '') {
                    // Create regex that matches exactly questionMarkCount letters
                    // [^A-Za-z]* = match any number of non-letter characters
                    // ([A-Za-z][^A-Za-z]*){n} = match exactly n letters with any non-letter chars in between
                    // We use a lookahead to ensure the string contains exactly n letters total
                    return new RegExp(`^(?=[^A-Za-z]*([A-Za-z][^A-Za-z]*){${questionMarkCount}}$)[\\s\\S]*$`, 'i');
                }
                
                // Handle mix of ? and other characters
                // Replace sequences of ? with a special pattern
                let parts = [];
                let currentPart = '';
                let inQuestionMarkSequence = false;
                
                for (let i = 0; i < preparedPattern.length; i++) {
                    const char = preparedPattern[i];
                    
                    if (char === '?') {
                        if (!inQuestionMarkSequence) {
                            // Start of a new ? sequence
                            if (currentPart) {
                                // Add accumulated non-? part
                                parts.push({ type: 'literal', value: currentPart });
                                currentPart = '';
                            }
                            inQuestionMarkSequence = true;
                            currentPart = '?';
                        } else {
                            // Continue ? sequence
                            currentPart += '?';
                        }
                    } else {
                        if (inQuestionMarkSequence) {
                            // End of ? sequence
                            parts.push({ type: 'questionMarks', count: currentPart.length });
                            currentPart = char;
                            inQuestionMarkSequence = false;
                        } else {
                            // Continue non-? part
                            currentPart += char;
                        }
                    }
                }
                
                // Add the last part
                if (currentPart) {
                    if (inQuestionMarkSequence) {
                        parts.push({ type: 'questionMarks', count: currentPart.length });
                    } else {
                        parts.push({ type: 'literal', value: currentPart });
                    }
                }
                
                // Convert parts to regex segments
                let regexParts = [];
                
                for (const part of parts) {
                    if (part.type === 'literal') {
                        // Escape special chars except the asterisk placeholder
                        let value = part.value.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                        // Restore asterisks
                        value = value.replace(/###ASTERISK###/g, '.*');
                        regexParts.push(value);
                    } else if (part.type === 'questionMarks') {
                        // ? sequence represents exactly n letters with any non-letters in between
                        regexParts.push(`(?:[^A-Za-z]*[A-Za-z]){${part.count}}[^A-Za-z]*`);
                    }
                }
                
                // Join parts and create the final regex
                return new RegExp(`^${regexParts.join('')}$`, 'i');
            }
        }

        // Exclusion: convert wildcard to non-anchored regex ("contains" semantics)
        function wildcardToRegexForExclusion(pattern) {
            const variableModeElement = document.getElementById('variable-mode');
            const variableMode = variableModeElement ? variableModeElement.checked : false;
            const crosswordModeElement = document.getElementById('crossword-mode');
            const crosswordMode = crosswordModeElement ? crosswordModeElement.checked : false;
            
            // Variable Mode doesn't make sense for exclusions (since it's about exact patterns)
            // So we'll treat variable mode exclusions as regular wildcard exclusions
            if (variableMode) {
                console.warn('Variable Mode is not supported for exclusion patterns. Using standard wildcard matching.');
            }
            
            // Escape special regex characters except * and ?
            let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            // Convert *
            regexPattern = regexPattern.replace(/\*/g, '.*');
            // Convert ?
            if (crosswordMode) {
                regexPattern = regexPattern.replace(/\?/g, '[A-Za-z]');
            } else {
                regexPattern = regexPattern.replace(/\?/g, '.');
            }
            return new RegExp(`${regexPattern}`, 'i');
        }
        
        // Enhanced search function with option to use server-side or client-side search
        async function searchTerms(continueSearch = false) {
            if (!userIsAdmin) {
                alert('You need admin privileges to perform searches.');
                return;
            }
            
            // Check if server-side search is available
            const useServerSide = typeof firebase.functions !== 'undefined';
            
            if (useServerSide && !continueSearch) {
                // Use optimized server-side search for new searches
                await searchTermsServerSide();
            } else {
                // Fall back to client-side search for continued searches or if functions unavailable
                await searchTermsClientSide(continueSearch);
            }
        }

        // New server-side search function
        async function searchTermsServerSide() {
            const searchTerm = searchInput.value.trim();
            
            if (!searchTerm) {
                alert('Please enter a search term');
                return;
            }
            
            // Get selected files
            const selectedFiles = [];
            availableFiles.forEach(file => {
                const checkbox = document.getElementById(`file-${file}`);
                if (checkbox && checkbox.checked) {
                    // Fix file names that incorrectly use dots instead of underscores
                    let correctedFileName = file;
                    if (file.includes('.') && !file.includes('_')) {
                        correctedFileName = file.replace(/\./g, '_');
                        console.warn(`File name contains dots, attempting to use ${correctedFileName} instead`);
                    }
                    selectedFiles.push(correctedFileName);
                }
            });
            
            if (selectedFiles.length === 0) {
                alert('Please select at least one file');
                return;
            }

            // Show loading
            resultsContainer.innerHTML = '<div class="loading">Searching on server...</div>';

            try {
                // Get search options
                const crosswordMode = document.getElementById('crossword-mode')?.checked || false;
                const variableMode = document.getElementById('variable-mode')?.checked || false;
                const ignoreSpaces = document.getElementById('ignore-spaces-mode')?.checked || false;

                // Prepare data for server-side function
                const searchData = {
                    searchTerm: searchTerm,
                    files: selectedFiles,
                    excludePatterns: excludePatterns,
                    crosswordMode: crosswordMode,
                    variableMode: variableMode,
                    ignoreSpaces: ignoreSpaces,
                    maxResults: resultsPerPage
                };

                console.log('Calling server-side search function with:', searchData);

                // Call the server-side function
                const searchFunction = firebase.functions().httpsCallable('searchTerms');
                const result = await searchFunction(searchData);

                console.log('Server-side search completed:', result.data);

                // Update search state for potential client-side continuation
                currentSearchState = {
                    searchTerm: searchTerm,
                    selectedFiles: selectedFiles,
                    hasMoreResults: result.data.hasMore,
                    resultsFound: result.data.totalFound,
                    serverSideUsed: true
                };

                // Display results
                displayServerSideResults(result.data);

            } catch (error) {
                console.error('Server-side search error:', error);
                
                // Fall back to client-side search if server-side fails
                console.log('Falling back to client-side search...');
                await searchTermsClientSide(false);
            }
        }

        // Original client-side search function (kept as fallback)
        async function searchTermsClientSide(continueSearch = false) {
            // If not continuing a previous search, start a new one
            if (!continueSearch) {
                const searchTerm = searchInput.value.trim();
                
                if (!searchTerm) {
                    alert('Please enter a search term');
                    return;
                }
                
                // Get selected files
                const selectedFiles = [];
                availableFiles.forEach(file => {
                    const checkbox = document.getElementById(`file-${file}`);
                    if (checkbox && checkbox.checked) {
                        // Fix file names that incorrectly use dots instead of underscores
                        let correctedFileName = file;
                        if (file.includes('.') && !file.includes('_')) {
                            correctedFileName = file.replace(/\./g, '_');
                            console.warn(`File name contains dots, attempting to use ${correctedFileName} instead`);
                        }
                        selectedFiles.push(correctedFileName);
                    }
                });
                
                if (selectedFiles.length === 0) {
                    alert('Please select at least one file');
                    return;
                }
                
                // Define the score ranges for the search (highest to lowest)
                // Use larger ranges to reduce the number of Firebase requests
                const scoreRanges = [
                    { min: 95, max: 100 }, // Highest scores first
                    { min: 85, max: 94 },
                    { min: 70, max: 84 },
                    { min: 50, max: 69 },
                    { min: 25, max: 49 },
                    { min: 0, max: 24 }
                ];
                
                // Create regex pattern from search term
                const regexPattern = wildcardToRegex(searchTerm);
                
                // Compile exclusion regexes from current excludePatterns
                const excludeRegexes = excludePatterns
                    .map(p => p.trim())
                    .filter(p => p.length > 0)
                    .map(p => wildcardToRegexForExclusion(p));
                
                // Clear search cache for fresh results (but keep file existence cache)
                searchResultsCache.clear();
                
                // Initialize search state
                currentSearchState = {
                    searchTerm: searchTerm,
                    pattern: regexPattern,
                    selectedFiles: selectedFiles,
                    fileIndex: 0,
                    scoreRanges: scoreRanges,
                    scoreRangeIndex: 0,
                    currentScore: scoreRanges[0].max,
                    hasMoreResults: false,
                    resultsFound: 0,
                    allResults: [],
                    errors: [],
                    excludeRegexes: excludeRegexes,
                    serverSideUsed: false
                };
            }
            
            // Show loading
            if (!continueSearch) {
                resultsContainer.innerHTML = '<div class="loading">Searching (client-side)...</div>';
            } else {
                // If continuing, update or create the loading indicator for additional results
                let loadingElem = document.getElementById('loading-more');
                if (!loadingElem) {
                    loadingElem = document.createElement('div');
                    loadingElem.id = 'loading-more';
                    loadingElem.className = 'loading';
                    loadingElem.textContent = 'Loading more results...';
                    resultsContainer.appendChild(loadingElem);
                }
            }
            
            try {
                // Start or continue the search process
                const results = await searchBatch();
                
                // Display results, indicating if this is a continuation of a previous search
                displayResults(results, continueSearch);
            } catch (error) {
                console.error('Error searching terms:', error);
                
                // Set more specific error message based on the error type
                if (error.code === 'PERMISSION_DENIED') {
                    resultsContainer.innerHTML = `
                        <div class="error-message">
                            <strong>Permission denied:</strong> Your Firebase security rules do not allow reading from the 'tools' path.
                            Update your rules to allow read access to the 'tools' path for admin users.
                        </div>
                    `;
                } else {
                    resultsContainer.innerHTML = `
                        <div class="error-message">
                            <strong>Error searching terms:</strong> ${error.message || 'Unknown error'}
                        </div>
                    `;
                }
            }
        }

        // Display results from server-side search
        function displayServerSideResults(searchResult) {
            resultsContainer.innerHTML = '';
            
            const { results, totalFound, errors, hasMore } = searchResult;
            
            if (results.length === 0 && errors.length === 0) {
                resultsContainer.innerHTML = '<p class="no-results">No results found. Try a different search term.</p>';
                return;
            }

            // Show errors if any
            if (errors.length > 0) {
                const errorHtml = errors.map(err => 
                    `<div class="error-message" style="margin-bottom: 10px;">
                        <strong>Error with file ${err.filename}:</strong><br>
                        ${err.error}
                    </div>`
                ).join('');
                
                const errorContainer = document.createElement('div');
                errorContainer.innerHTML = errorHtml;
                resultsContainer.appendChild(errorContainer);
            }

            if (results.length === 0) {
                const noResults = document.createElement('p');
                noResults.className = 'no-results';
                noResults.textContent = 'No valid results found due to errors.';
                resultsContainer.appendChild(noResults);
                return;
            }

            // Add result count
            const totalCount = document.createElement('div');
            totalCount.className = 'result-count';
            totalCount.id = 'result-count';
            totalCount.textContent = `Found ${totalFound} result${totalFound !== 1 ? 's' : ''} (showing ${results.length})`;
            resultsContainer.appendChild(totalCount);

            // Create table
            const table = document.createElement('table');
            table.id = 'results-table';
            table.className = 'results-table';
            
            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            const headers = ['Score', 'Term', 'Parenthetical', 'Wikipedia Link', 'Merriam Webster Link', 'Trivia Archive Results'];
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create table body
            const tbody = document.createElement('tbody');
            tbody.id = 'results-tbody';
            
            // Add results
            for (const result of results) {
                const row = document.createElement('tr');
                
                // Score cell
                const scoreCell = document.createElement('td');
                scoreCell.textContent = result.score;
                row.appendChild(scoreCell);
                
                // Term cell with clipboard button
                const termCell = document.createElement('td');
                termCell.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span>${result.term}</span>
                        <button class="add-to-clipboard" onclick="addToClipboard('${result.term.replace(/'/g, "\\'")}')">+</button>
                    </div>
                `;
                row.appendChild(termCell);
                
                // Parenthetical cell
                const parenthesesCell = document.createElement('td');
                parenthesesCell.textContent = result.parentheses || '';
                row.appendChild(parenthesesCell);
                
                // Wikipedia Link
                const wikiCell = document.createElement('td');
                const wikiLink = getWikipediaLink(result.term);
                wikiCell.innerHTML = `<a href="${wikiLink}" class="dictionary-link" target="_blank">Wikipedia</a>`;
                row.appendChild(wikiCell);
                
                // Merriam Webster Link
                const mwCell = document.createElement('td');
                const mwLink = getMerriamWebsterLink(result.term);
                mwCell.innerHTML = `<a href="${mwLink}" class="dictionary-link" target="_blank">Merriam-Webster</a>`;
                row.appendChild(mwCell);
                
                // Trivia Archive
                const triviaCell = document.createElement('td');
                const searchLink = getSearchLink(result.term);
                triviaCell.innerHTML = `<a href="${searchLink}" class="dictionary-link" target="_blank">Search Archive</a>`;
                row.appendChild(triviaCell);
                
                tbody.appendChild(row);
            }
            
            table.appendChild(tbody);
            resultsContainer.appendChild(table);

            // Show "Load More" button if there are more results and we can continue client-side
            if (hasMore) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-button';
                loadMoreButton.className = 'load-more';
                loadMoreButton.textContent = 'Load More Results (Client-side)';
                
                loadMoreButton.addEventListener('click', () => {
                    // Continue with client-side search for additional results
                    searchTermsClientSide(true);
                });
                
                resultsContainer.appendChild(loadMoreButton);

                // Add note about client-side continuation
                const note = document.createElement('div');
                note.className = 'info-message';
                note.style.marginTop = '10px';
                note.innerHTML = '<strong>Note:</strong> Additional results will be loaded using client-side search, which may be slower.';
                resultsContainer.appendChild(note);
            }
        }
        
        // Search in batches until we find enough results or exhaust the search space
        async function searchBatch() {
            const results = [];
            const errors = [];
            // Track results returned in THIS batch only (not cumulative)
            let resultsInThisBatch = 0;
            
            // 30 second timeout for the entire batch
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error(`Search timed out`)), batchTimeoutMs);
            });
            
            try {
                const searchPromise = (async () => {
                    // Continue from where we left off
                    let {selectedFiles, fileIndex, scoreRanges, scoreRangeIndex, currentScore} = currentSearchState;
                    
                    // Loop through files
                    while (fileIndex < selectedFiles.length) {
                        const filename = selectedFiles[fileIndex];
                        
                        // Check if file exists (only on first file access)
                        if (scoreRangeIndex === 0 && currentScore === scoreRanges[0].max) {
                            try {
                                const fileExists = await checkFileExists(filename);
                                if (!fileExists) {
                                    // File doesn't exist, add error and skip to next file
                                    if (filename.includes('.')) {
                                        const correctedName = filename.replace(/\./g, '_');
                                        errors.push({
                                            term: `Error: File not found: ${filename}`,
                                            parentheses: `Files use underscores, not dots. Did you mean "${correctedName}"?`,
                                            score: 0,
                                            filename: filename,
                                            termId: 'error',
                                            isError: true
                                        });
                                    } else {
                                        errors.push({
                                            term: `Error: File not found: ${filename}`,
                                            parentheses: 'This file does not exist in the database. Available files: RankedWiki_txt, RankedWiktionary_txt, ScrabbleDict_txt, jeopardy_wordlist_txt',
                                            score: 0,
                                            filename: filename,
                                            termId: 'error',
                                            isError: true
                                        });
                                    }
                                    fileIndex++;
                                    continue;
                                }
                            } catch (error) {
                                console.error(`Error checking if file exists: ${filename}`, error);
                                errors.push({
                                    term: `Error checking file: ${filename}`,
                                    parentheses: error.message || 'Unknown error',
                                    score: 0,
                                    filename: filename,
                                    termId: 'error',
                                    isError: true
                                });
                                fileIndex++;
                                continue;
                            }
                        }
                        
                        // Loop through score ranges
                        while (scoreRangeIndex < scoreRanges.length) {
                            const range = scoreRanges[scoreRangeIndex];
                            
                            // Initialize the currentScore if we're just entering this range
                            if (typeof currentScore !== 'number' || currentScore > range.max) {
                                currentScore = range.max;
                            }
                            
                            // Loop through scores in windows within the current range
                            while (currentScore >= range.min) {
                                try {
                                    const windowMax = currentScore;
                                    const windowMin = Math.max(range.min, windowMax - scoreWindowSize + 1);
                                    const windowData = await fetchScoresWindow(filename, windowMin, windowMax);
                                    const scoreKeys = Object.keys(windowData)
                                        .map(k => parseInt(k, 10))
                                        .filter(k => !Number.isNaN(k))
                                        .sort((a, b) => b - a);
                                    
                                    for (const scoreKey of scoreKeys) {
                                        const terms = windowData[String(scoreKey)] || {};
                                        for (const termId in terms) {
                                            if (!Object.prototype.hasOwnProperty.call(terms, termId)) continue;
                                            const termData = terms[termId];
                                            if (!termData || !termData.term) continue;
                                            if (currentSearchState.pattern.test(termData.term) && !isTermExcluded(termData.term)) {
                                                results.push({
                                                    term: termData.term,
                                                    parentheses: termData.parentheses || '',
                                                    score: scoreKey,
                                                    filename: filename,
                                                    termId: termId
                                                });
                                                // Update counters
                                                currentSearchState.resultsFound += 1; // cumulative for display
                                                resultsInThisBatch += 1; // per-batch for pagination
                                                if (resultsInThisBatch >= resultsPerPage) {
                                                    // Sort results by score (highest first) before returning
                                                    results.sort((a, b) => b.score - a.score);
                                                    currentSearchState.currentScore = scoreKey - 1;
                                                    currentSearchState.hasMoreResults = true;
                                                    return results;
                                                }
                                            }
                                        }
                                        // Update progress if we finished this score
                                        currentScore = scoreKey - 1;
                                    }
                                    // If no scores existed in the window, decrement to just before windowMin
                                    if (scoreKeys.length === 0) {
                                        currentScore = windowMin - 1;
                                    }
                                } catch (error) {
                                    console.error(`Error searching scores ${currentScore}.. in ${filename}:`, error);
                                    // Skip this window and continue
                                    currentScore--;
                                }
                            }
                            
                            // Move to next range
                            scoreRangeIndex++;
                            if (scoreRangeIndex < scoreRanges.length) {
                                currentScore = scoreRanges[scoreRangeIndex].max;
                            }
                        }
                        
                        // Reset for next file
                        fileIndex++;
                        scoreRangeIndex = 0;
                        if (scoreRanges.length > 0) {
                            currentScore = scoreRanges[0].max;
                        }
                    }
                    
                    // If we get here, we've exhausted all search options
                    currentSearchState.hasMoreResults = false;
                    
                    // Sort final results by score (highest first)
                    results.sort((a, b) => b.score - a.score);
                    
                    return results;
                })();
                
                // Race the search against the timeout
                const batchResults = await Promise.race([searchPromise, timeoutPromise]);
                
                // Add any errors we encountered
                if (errors.length > 0) {
                    // Add errors to the front of the results
                    batchResults.unshift(...errors);
                    
                    // Also track them in the search state
                    if (!currentSearchState.errors) {
                        currentSearchState.errors = [];
                    }
                    currentSearchState.errors.push(...errors);
                }
                
                return batchResults;
            } catch (error) {
                console.error('Error in search batch:', error);
                
                // Return whatever results we had plus the error
                const errorResult = {
                    term: `Error during search`,
                    parentheses: error.message || 'Unknown error',
                    score: 0,
                    termId: 'error',
                    isError: true
                };
                
                results.push(errorResult);
                return results;
            }
        }

        // Fetch terms for a filename between two score bounds (inclusive) with caching
        async function fetchScoresWindow(filename, minScore, maxScore) {
            // Create cache key
            const cacheKey = `${filename}:${minScore}-${maxScore}`;
            
            // Check cache first
            if (searchResultsCache.has(cacheKey)) {
                return searchResultsCache.get(cacheKey);
            }
            
            try {
                const ref = db.ref(`tools/${filename}`)
                    .orderByKey()
                    .startAt(String(minScore))
                    .endAt(String(maxScore));
                
                const snapshot = await ref.once('value');
                const result = snapshot.val() || {};
                
                // Cache the result (limit cache size to prevent memory issues)
                if (searchResultsCache.size > 100) {
                    // Remove oldest entries if cache gets too large
                    const firstKey = searchResultsCache.keys().next().value;
                    searchResultsCache.delete(firstKey);
                }
                searchResultsCache.set(cacheKey, result);
                
                return result;
            } catch (err) {
                console.error(`Error fetching score window ${minScore}-${maxScore} for ${filename}`, err);
                // Cache empty result to avoid repeated failures
                searchResultsCache.set(cacheKey, {});
                return {};
            }
        }
        
        // Check if a file exists in the database (with caching)
        async function checkFileExists(filename) {
            // Check cache first
            if (fileExistsCache.has(filename)) {
                return fileExistsCache.get(filename);
            }
            
            try {
                const snapshot = await db.ref(`tools/${filename}`).limitToFirst(1).once('value');
                const exists = snapshot.exists();
                // Cache the result
                fileExistsCache.set(filename, exists);
                return exists;
            } catch (error) {
                console.error(`Error checking if file exists: ${filename}`, error);
                // Cache negative result to avoid repeated failures
                fileExistsCache.set(filename, false);
                throw error;
            }
        }
        
        // Determine if a term should be excluded
        function isTermExcluded(term) {
            if (!currentSearchState.excludeRegexes || currentSearchState.excludeRegexes.length === 0) {
                return false;
            }
            return currentSearchState.excludeRegexes.some(rx => rx.test(term));
        }
        
        // Search a specific score in a file
        async function searchScore(filename, score, regexPattern) {
            try {
                const snapshot = await db.ref(`tools/${filename}/${score}`).once('value');
                const terms = snapshot.val() || {};
                const results = [];
                
                // For each term ID
                for (const termId in terms) {
                    if (terms.hasOwnProperty(termId)) {
                        const termData = terms[termId];
                        
                        // Skip items without term property
                        if (!termData.term) continue;
                        
                        // Check if term matches regex pattern and is not excluded
                        if (regexPattern.test(termData.term) && !isTermExcluded(termData.term)) {
                            results.push({
                                term: termData.term,
                                parentheses: termData.parentheses || '',
                                score: score,
                                filename: filename,
                                termId: termId
                            });
                        }
                    }
                }
                
                return results;
            } catch (error) {
                console.error(`Error searching score ${score} in ${filename}:`, error);
                throw error;
            }
        }
        
        // Display search results
        function displayResults(results, isLoadMore) {
            // Remove loading more indicator if it exists
            const loadingMore = document.getElementById('loading-more');
            if (loadingMore) {
                loadingMore.remove();
            }
            
            if (!isLoadMore) {
                resultsContainer.innerHTML = '';
            }
            
            if (results.length === 0 && !isLoadMore) {
                resultsContainer.innerHTML = '<p class="no-results">No results found. Try a different search term.</p>';
                return;
            }
            
            // Check if all results are errors
            const errorResults = results.filter(r => r.isError);
            if (errorResults.length === results.length && !isLoadMore) {
                const errorHtml = errorResults.map(err => 
                    `<div class="error-message" style="margin-bottom: 10px;">
                        <strong>${err.term}</strong><br>
                        ${err.parentheses}
                    </div>`
                ).join('');
                
                resultsContainer.innerHTML = `
                    <p class="no-results">Encountered errors while searching:</p>
                    ${errorHtml}
                    <div class="info-message" style="margin-top: 20px;">
                        <strong>Suggestions:</strong>
                        <ul>
                            <li>Try using more specific search terms (e.g., use 'science' instead of '*s*')</li>
                            <li>Make sure the file name is correct and uses underscores, not dots (e.g., 'RankedWiki_txt' not 'RankedWiki.txt')</li>
                            <li>Available files: RankedWiki_txt, RankedWiktionary_txt, ScrabbleDict_txt, jeopardy_wordlist_txt</li>
                            <li>Break large searches into smaller ones</li>
                        </ul>
                    </div>
                `;
                return;
            }
            
            // Filter out error results for normal display
            const validResults = results.filter(r => !r.isError);
            
            // If we're loading more and there are only errors in this batch, show a message
            if (isLoadMore && validResults.length === 0 && errorResults.length > 0) {
                const errorWarning = document.createElement('div');
                errorWarning.className = 'error-message';
                errorWarning.style.backgroundColor = '#fff3cd';
                errorWarning.style.color = '#856404';
                errorWarning.style.border = '1px solid #ffeeba';
                errorWarning.innerHTML = `<strong>Note:</strong> No additional results found. There were errors accessing some data.`;
                resultsContainer.appendChild(errorWarning);
                return;
            }
            
            // Create table if it doesn't exist
            let table = document.getElementById('results-table');
            
            if (!table) {
                table = document.createElement('table');
                table.id = 'results-table';
                table.className = 'results-table';
                
                // Create header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                // Include all columns, including placeholders for future implementation
                const headers = ['Score', 'Term', 'Parenthetical', 'Wikipedia Link', 'Merriam Webster Link', 'Trivia Archive Results'];
                headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                tbody.id = 'results-tbody';
                table.appendChild(tbody);
                
                resultsContainer.appendChild(table);
            }
            
            // Get or create table body
            const tbody = document.getElementById('results-tbody');
            
            // If this is a continued search, we'll append to the existing table
            // If it's a new search, we've already cleared the results container above
            
            // Add count of results if this is the first batch
            if (!isLoadMore) {
                const totalCount = document.createElement('div');
                totalCount.className = 'result-count';
                totalCount.id = 'result-count';
                totalCount.textContent = `Found ${validResults.length} result${validResults.length !== 1 ? 's' : ''}`;
                resultsContainer.insertBefore(totalCount, table);
                
                // If there were errors, also show a warning
                if (errorResults.length > 0) {
                    const errorWarning = document.createElement('div');
                    errorWarning.className = 'error-message';
                    errorWarning.style.backgroundColor = '#fff3cd';
                    errorWarning.style.color = '#856404';
                    errorWarning.style.border = '1px solid #ffeeba';
                    errorWarning.innerHTML = `<strong>Note:</strong> Some files had errors and were excluded from results.`;
                    resultsContainer.insertBefore(errorWarning, table);
                }
            } else {
                // If we're loading more, update the count
                const totalCount = document.getElementById('result-count');
                if (totalCount) {
                    const currentCount = parseInt(totalCount.textContent.match(/\d+/)[0], 10);
                    const newCount = currentCount + validResults.length;
                    totalCount.textContent = `Found ${newCount} result${newCount !== 1 ? 's' : ''}`;
                }
            }
            
            // Display valid results
            for (const result of validResults) {
                const row = document.createElement('tr');
                
                // Score cell
                const scoreCell = document.createElement('td');
                scoreCell.textContent = result.score;
                row.appendChild(scoreCell);
                
                // Term cell with clipboard button
                const termCell = document.createElement('td');
                termCell.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span>${result.term}</span>
                        <button class="add-to-clipboard" onclick="addToClipboard('${result.term.replace(/'/g, "\\'")}')">+</button>
                    </div>
                `;
                row.appendChild(termCell);
                
                // Parenthetical cell
                const parenthesesCell = document.createElement('td');
                parenthesesCell.textContent = result.parentheses || '';
                row.appendChild(parenthesesCell);
                
                // Wikipedia Link
                const wikiCell = document.createElement('td');
                const wikiLink = getWikipediaLink(result.term);
                wikiCell.innerHTML = `<a href="${wikiLink}" class="dictionary-link" target="_blank">Wikipedia</a>`;
                row.appendChild(wikiCell);
                
                // Merriam Webster Link
                const mwCell = document.createElement('td');
                const mwLink = getMerriamWebsterLink(result.term);
                mwCell.innerHTML = `<a href="${mwLink}" class="dictionary-link" target="_blank">Merriam-Webster</a>`;
                row.appendChild(mwCell);
                
                // Trivia Archive (now with search link)
                const triviaCell = document.createElement('td');
                const searchLink = getSearchLink(result.term);
                triviaCell.innerHTML = `<a href="${searchLink}" class="dictionary-link" target="_blank">Search Archive</a>`;
                row.appendChild(triviaCell);
                
                tbody.appendChild(row);
            }
            
            // Show "Load More" button if there are potentially more results
            // Remove existing button first
            const existingButton = document.getElementById('load-more-button');
            if (existingButton) {
                existingButton.remove();
            }
            
            if (currentSearchState.hasMoreResults) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-button';
                loadMoreButton.className = 'load-more';
                loadMoreButton.textContent = 'Load More Results';
                
                loadMoreButton.addEventListener('click', () => {
                    // Continue the search from where we left off
                    searchTerms(true);
                });
                
                resultsContainer.appendChild(loadMoreButton);
            }
        }
        
        // Event listeners
        searchButton.addEventListener('click', searchTerms);
        
        // Allow Enter key to trigger search
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchTerms();
            }
        });
        
        // Clipboard management functions
        function addToClipboard(term) {
            // Check if the term is already in the clipboard
            if (!clipboardTerms.includes(term)) {
                clipboardTerms.push(term);
                updateClipboardDisplay();
            }
        }
        
        function removeFromClipboard(index) {
            clipboardTerms.splice(index, 1);
            updateClipboardDisplay();
        }
        
        function clearClipboard() {
            clipboardTerms = [];
            updateClipboardDisplay();
        }
        
        function copyAllTerms() {
            if (clipboardTerms.length === 0) {
                alert('No terms to copy');
                return;
            }
            
            const textToCopy = clipboardTerms.join('\n');
            navigator.clipboard.writeText(textToCopy)
                .then(() => {
                    alert('All terms copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    // Fallback for browsers that don't support clipboard API
                    const textarea = document.createElement('textarea');
                    textarea.value = textToCopy;
                    textarea.style.position = 'fixed';
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('All terms copied to clipboard!');
                });
        }
        
        function updateClipboardDisplay() {
            const clipboardContent = document.getElementById('clipboard-content');
            
            if (clipboardTerms.length === 0) {
                clipboardContent.innerHTML = '<p>No terms added yet.</p>';
                return;
            }
            
            let html = '';
            clipboardTerms.forEach((term, index) => {
                html += `
                    <div class="clipboard-item">
                        <span>${term}</span>
                        <span class="remove-item" onclick="removeFromClipboard(${index})">×</span>
                    </div>
                `;
            });
            
            clipboardContent.innerHTML = html;
        }
        
        function toggleClipboard() {
            const container = document.getElementById('clipboard-container');
            container.classList.toggle('collapsed');
            
            // Update the toggle button text
            const toggleBtn = document.getElementById('toggle-clipboard');
            if (container.classList.contains('collapsed')) {
                toggleBtn.textContent = '▼';
                toggleBtn.setAttribute('aria-label', 'Expand clipboard');
                toggleBtn.title = 'Show clipboard';
            } else {
                toggleBtn.textContent = '▲';
                toggleBtn.setAttribute('aria-label', 'Collapse clipboard');
                toggleBtn.title = 'Hide clipboard';
            }
        }

        // Generate Wikipedia link for a term
        function getWikipediaLink(term) {
            const formattedTerm = term.replace(/\s+/g, '_');
            return `https://en.wikipedia.org/wiki/${encodeURIComponent(formattedTerm)}`;
        }
        
        // Generate Merriam-Webster link for a term
        function getMerriamWebsterLink(term) {
            const formattedTerm = term.replace(/\s+/g, '%20');
            return `https://www.merriam-webster.com/dictionary/${formattedTerm}`;
        }
        
        // Generate Search link for a term
        function getSearchLink(term) {
            const wildcardedTerm = encodeURIComponent(`*${term}*`);
            const searchUrl = `/tools/search/index.html?q=${wildcardedTerm}&autosubmit=true&t=${Date.now()}`;
            return searchUrl;
        }
        
        // Filters UI functions
        function updateExcludeDisplay() {
            const list = document.getElementById('exclude-list');
            if (!list) return;
            if (excludePatterns.length === 0) {
                list.innerHTML = '<span style="color:#666;">No filters added.</span>';
                return;
            }
            list.innerHTML = '';
            excludePatterns.forEach((pat, idx) => {
                const chip = document.createElement('div');
                chip.className = 'filter-chip';
                chip.innerHTML = `<span>${pat}</span><span class="remove-item" title="Remove" onclick="removeExcludePattern(${idx})">×</span>`;
                list.appendChild(chip);
            });
        }
        function addExcludePattern() {
            const input = document.getElementById('exclude-input');
            const value = (input.value || '').trim();
            if (!value) return;
            excludePatterns.push(value);
            input.value = '';
            updateExcludeDisplay();
        }
        function removeExcludePattern(index) {
            excludePatterns.splice(index, 1);
            updateExcludeDisplay();
        }
        function clearExclusions() {
            excludePatterns = [];
            updateExcludeDisplay();
        }
        function toggleFilters() {
            const container = document.getElementById('filters-container');
            container.classList.toggle('collapsed');
            const btn = document.getElementById('toggle-filters');
            if (container.classList.contains('collapsed')) {
                btn.textContent = '▼';
                btn.setAttribute('aria-label', 'Expand filters');
                btn.title = 'Show filters';
            } else {
                btn.textContent = '▲';
                btn.setAttribute('aria-label', 'Collapse filters');
                btn.title = 'Hide filters';
            }
        }
        
        // Clipboard event listeners
        document.getElementById('toggle-clipboard').addEventListener('click', toggleClipboard);
        document.getElementById('clear-clipboard').addEventListener('click', clearClipboard);
        document.getElementById('copy-clipboard').addEventListener('click', copyAllTerms);
        
        // Make the entire header clickable
        document.querySelector('.clipboard-header').addEventListener('click', function(e) {
            // Only toggle if we clicked the header itself, not one of its children like the button
            // (the button has its own click handler)
            if (e.target === this || e.target.classList.contains('clipboard-title')) {
                toggleClipboard();
            }
        });

        // Filters event listeners
        document.getElementById('toggle-filters').addEventListener('click', toggleFilters);
        document.getElementById('filters-header').addEventListener('click', function(e) {
            if (e.target === this || e.target.classList.contains('filters-title')) {
                toggleFilters();
            }
        });
        document.getElementById('add-exclude-btn').addEventListener('click', addExcludePattern);
        document.getElementById('clear-exclusions-btn').addEventListener('click', clearExclusions);
        document.getElementById('exclude-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addExcludePattern();
        });
        
        // Variable Mode event listener
        function toggleVariableModeOptions() {
            if (variableModeCheckbox.checked) {
                variableModeOptions.style.display = 'flex';
            } else {
                variableModeOptions.style.display = 'none';
                // Also uncheck the ignore spaces option when Variable Mode is disabled
                ignoreSpacesCheckbox.checked = false;
            }
        }
        
        // Initialize clipboard on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Set initial clipboard position based on screen size
            const container = document.getElementById('clipboard-container');
            
            // Always start collapsed by default
            container.classList.add('collapsed');
            const toggleBtn = document.getElementById('toggle-clipboard');
            toggleBtn.textContent = '▼';
            toggleBtn.setAttribute('aria-label', 'Expand clipboard');
            toggleBtn.title = 'Show clipboard';

            // Initialize filters collapsed and UI paint
            const filtersContainer = document.getElementById('filters-container');
            filtersContainer.classList.add('collapsed');
            const toggleFiltersBtn = document.getElementById('toggle-filters');
            toggleFiltersBtn.textContent = '▼';
            toggleFiltersBtn.setAttribute('aria-label', 'Expand filters');
            toggleFiltersBtn.title = 'Show filters';
            updateExcludeDisplay();
            
            // Add Variable Mode event listener
            variableModeCheckbox.addEventListener('change', toggleVariableModeOptions);
        });
    </script>
</body>
</html> 