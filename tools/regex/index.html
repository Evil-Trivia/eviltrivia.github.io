<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evil Trivia - Search Tool</title>
    <script src="/js/components/autoload-banner.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #FFCC00;
            margin-top: 60px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }
        
        .search-input {
            font-size: 18px;
            padding: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            width: calc(100% - 34px);
            margin-bottom: 16px;
            box-sizing: border-box;
        }
        
        .search-button {
            background: #333;
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
        }
        
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin: 16px 0;
        }
        
        .option-group {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }
        
        .results-table th, .results-table td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
            text-align: left;
        }
        
        .results-table th {
            background: #f8f9fa;
        }
        
        .add-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .link-btn {
            color: #007bff;
            text-decoration: none;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Evil Trivia Search Tool</h1>
        
        <!-- Authentication Required -->
        <div id="auth-required" class="card hidden">
            <h2>üîí Admin Access Required</h2>
            <p>You need admin privileges to use this search tool.</p>
            <a href="/pages/account.html" class="search-button">Go to Account</a>
        </div>
        
        <!-- Main Interface -->
        <div id="main-interface" class="hidden">
            <!-- Search Section -->
            <div class="card">
                <input type="text" id="search-input" class="search-input" 
                       placeholder="Enter search term (e.g., apple, *app*, app?, X Y X for variables)">
                
                <div class="options-grid">
                    <div class="option-group">
                        <h3>üéØ Search Modes</h3>
                        <div class="checkbox-group">
                            <input type="checkbox" id="crossword-mode">
                            <label for="crossword-mode">Crossword Mode (? ignores spaces)</label>
                </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="variable-mode">
                            <label for="variable-mode">Variable Mode (X Y X pattern matching)</label>
                    </div>
                    </div>
                    
                                         <div class="option-group">
                         <h3>üîç Search Settings</h3>
                         <div id="search-engine-status" style="font-size: 12px; color: #666; margin-bottom: 8px;">
                             Initializing search engine...
                         </div>
                         <div class="checkbox-group">
                             <input type="checkbox" id="simple-mode">
                             <label for="simple-mode">Simple Mode (match whole words or word parts)</label>
                         </div>
                     </div>

                    <div class="option-group">
                        <h3>üìÅ Data Sources</h3>
                        <div id="files-container">
                            <div class="loading">Loading files...</div>
                        </div>
                            </div>
                            </div>

                <button id="search-btn" class="search-button">üîç Search</button>
            </div>
            
            <!-- Collection Box -->
            <div class="card">
                <h3>üìã Collected Terms (<span id="collection-count">0</span>)</h3>
                <div id="collection-items" style="min-height: 100px; border: 1px solid #ddd; padding: 8px; border-radius: 4px;">
                    Click the + button next to search results to add terms here
                </div>
                <div style="margin-top: 12px;">
                    <button id="copy-collection" class="search-button">üìã Copy All</button>
                    <button id="clear-collection" class="search-button" style="background: #dc3545;">üóëÔ∏è Clear</button>
                </div>
            </div>
            
            <!-- Results Section -->
            <div id="results-section" class="card hidden">
                <div id="results-count">0 results</div>
                <div id="results-container"></div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-auth.js";
        import { getFirestore, collection, query, where, orderBy, limit, getDocs, startAfter } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-firestore.js";
        import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";
        
        // Algolia Search Client
        import algoliasearch from 'https://cdn.skypack.dev/algoliasearch@4';
        
        // Algolia Configuration (embedded for security)
        const ALGOLIA_CONFIG = {
            appId: 'AHT0QUAOI5',
            searchApiKey: '1c6c5861ab250bc9c67d15625d6b2c14',  // New refreshed Search API key
            indexName: 'ET-Tools'  // New index name from fresh extension
        };

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
            authDomain: "eviltrivia-47664.firebaseapp.com",
            databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
            projectId: "eviltrivia-47664",
            storageBucket: "eviltrivia-47664.firebasestorage.app",
            messagingSenderId: "401826818140",
            appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
            measurementId: "G-2W6RK96Y34"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const firestore = getFirestore(app);
        const db = getDatabase(app);
        
        // Initialize Algolia
        let algoliaClient, algoliaIndex;
        
        try {
            algoliaClient = algoliasearch(ALGOLIA_CONFIG.appId, ALGOLIA_CONFIG.searchApiKey);
            algoliaIndex = algoliaClient.initIndex(ALGOLIA_CONFIG.indexName);
            console.log('‚úÖ Algolia initialized successfully with fresh keys');
            
            // Update status indicator
            document.addEventListener('DOMContentLoaded', () => {
                const statusEl = document.getElementById('search-engine-status');
                if (statusEl) {
                    statusEl.innerHTML = 'üöÄ <strong>Algolia Search</strong> - Lightning fast search (indexing in progress...)';
                    statusEl.style.color = '#28a745';
                }
            });
                } catch (error) {
            console.warn('‚ö†Ô∏è Algolia initialization failed, using Firestore fallback:', error);
            
            // Update status indicator for fallback
            document.addEventListener('DOMContentLoaded', () => {
                const statusEl = document.getElementById('search-engine-status');
                if (statusEl) {
                    statusEl.innerHTML = '‚ö° <strong>Firestore Search</strong> - Paginated search (Algolia error)';
                    statusEl.style.color = '#ffc107';
                }
            });
        } // For user authentication only

        // Global state
        let availableFiles = [];
        let collectedTerms = [];

        // DOM elements
        const authRequired = document.getElementById('auth-required');
        const mainInterface = document.getElementById('main-interface');
        const searchInput = document.getElementById('search-input');
        const searchBtn = document.getElementById('search-btn');
        const crosswordMode = document.getElementById('crossword-mode');
        const variableMode = document.getElementById('variable-mode');
        const filesContainer = document.getElementById('files-container');
        const resultsSection = document.getElementById('results-section');
        const resultsCount = document.getElementById('results-count');
        const resultsContainer = document.getElementById('results-container');
        const collectionItems = document.getElementById('collection-items');
        const collectionCount = document.getElementById('collection-count');
        
        // Check if user is admin
        async function checkAdminAccess(user) {
            try {
                const userSnapshot = await get(ref(db, `users/${user.uid}`));
                if (!userSnapshot.exists()) {
                    return false;
                }
                
                const userData = userSnapshot.val();
                
                // Check both legacy and new role formats
                return userData.role === 'admin' || 
                       (userData.roles && Array.isArray(userData.roles) && userData.roles.includes('admin'));
            } catch (error) {
                console.error('Error checking admin access:', error);
                return false;
            }
        }

        // Authentication check
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                console.log("User is signed in:", user.uid);
                
                const isAdmin = await checkAdminAccess(user);
                
                if (isAdmin) {
                    console.log("Admin access granted");
                    authRequired.classList.add('hidden');
                    mainInterface.classList.remove('hidden');
                    await loadAvailableFiles();
                    } else {
                    console.log("User is not admin");
                    authRequired.classList.remove('hidden');
                    mainInterface.classList.add('hidden');
                    }
                } else {
                console.log("User is not signed in");
                authRequired.classList.remove('hidden');
                mainInterface.classList.add('hidden');
            }
        });

        // Load available files from Firestore using proper discovery
        async function loadAvailableFiles() {
            try {
                console.log('Discovering all available files in Firestore...');
                
                // Use multiple sampling approaches to find all files
                const fileSet = new Set();
                const toolsCollection = collection(firestore, 'tools');
                
                // Strategy 1: Sample from different parts of the collection
                const sampleQueries = [
                    query(toolsCollection, limit(500)),
                    query(toolsCollection, where('score', '>=', 90), limit(100)),
                    query(toolsCollection, where('score', '>=', 50), limit(100)),
                    query(toolsCollection, where('score', '>=', 10), limit(100))
                ];
                
                for (const q of sampleQueries) {
                    try {
                        const snapshot = await getDocs(q);
                        snapshot.forEach(doc => {
                            const data = doc.data();
                            if (data.file) {
                                fileSet.add(data.file);
                            }
                        });
                    } catch (error) {
                        console.warn('Sample query failed:', error);
                    }
                }
                
                // Strategy 2: Known files as fallback/supplement
                const knownFiles = ['RankedWiki_txt', 'RankedWiktionary_txt', 'ScrabbleDict_txt', 'jeopardy_wordlist_txt'];
                knownFiles.forEach(file => fileSet.add(file));
                
                if (fileSet.size > 0) {
                    availableFiles = Array.from(fileSet).sort();
                    console.log(`Found ${availableFiles.length} files:`, availableFiles);
                    } else {
                    console.log('No files found, using fallback');
                availableFiles = knownFiles;
                }
                
                displayFileOptions();
            } catch (error) {
                console.error('Error loading files:', error);
                // Fallback to known files
                availableFiles = ['RankedWiki_txt', 'RankedWiktionary_txt', 'ScrabbleDict_txt', 'jeopardy_wordlist_txt'];
                displayFileOptions();
            }
        }

        function displayFileOptions() {
            filesContainer.innerHTML = '';
            availableFiles.forEach(file => {
                const div = document.createElement('div');
                div.className = 'checkbox-group';
                div.innerHTML = `
                    <input type="checkbox" id="file-${file}" value="${file}" checked>
                    <label for="file-${file}">${file.replace(/_/g, ' ')}</label>
                `;
                filesContainer.appendChild(div);
            });
        }

                // Wildcard to regex conversion
        function wildcardToRegex(pattern) {
            const crosswordMode = document.getElementById('crossword-mode');
            const variableMode = document.getElementById('variable-mode');
            const simpleMode = document.getElementById('simple-mode');
            
            // Simple mode: match whole words or word parts at boundaries
            if (simpleMode && simpleMode.checked) {
                const escapedPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                // Match at word boundaries, spaces, special chars, string edges, or capital letter transitions
                return new RegExp(`(^|\\s|[^a-zA-Z0-9]|(?<=[a-z])(?=[A-Z]))${escapedPattern}(?=\\s|[^a-zA-Z0-9]|$|(?<=[a-z])(?=[A-Z]))`, 'i');
            }
            
            // Variable mode (most specific - handle first)
            if (variableMode && variableMode.checked) {
                return createVariableRegex(pattern);
            }
            
            // Standard wildcard mode
            let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            regexPattern = regexPattern.replace(/\*/g, '.*');
            
            // Crossword mode: ? matches only letters, ignoring spaces/punctuation
            if (crosswordMode && crosswordMode.checked) {
                regexPattern = regexPattern.replace(/\?/g, '[A-Za-z]');
            } else {
                // Standard mode: ? matches any single character
                regexPattern = regexPattern.replace(/\?/g, '.');
            }
            
            return new RegExp(`^${regexPattern}$`, 'i');
        }
                
        function createVariableRegex(pattern) {
            const variables = new Map();
            let groupCounter = 1;
            let regexPattern = '^';
            
            for (let i = 0; i < pattern.length; i++) {
                const char = pattern[i];
                
                if (/[A-Za-z]/.test(char)) {
                    const upperChar = char.toUpperCase();
                    
                    if (variables.has(upperChar)) {
                        regexPattern += `\\${variables.get(upperChar)}`;
                        } else {
                        variables.set(upperChar, groupCounter);
                        regexPattern += '(.)';
                        groupCounter++;
                        }
                } else if (char === ' ' && crosswordMode.checked) {
                    continue;
                    } else {
                    regexPattern += char.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                }
            }
            
            regexPattern += '$';
            return new RegExp(regexPattern, 'i');
        }
        
        // Collection management
        function addToCollection(term) {
            if (!collectedTerms.includes(term)) {
                collectedTerms.push(term);
                updateCollectionDisplay();
            }
        }

        function updateCollectionDisplay() {
            collectionCount.textContent = collectedTerms.length;
            
            if (collectedTerms.length === 0) {
                collectionItems.innerHTML = 'Click the + button next to search results to add terms here';
                return;
            }
            
            collectionItems.innerHTML = collectedTerms.map((term, index) => 
                `<div style="display: flex; justify-content: space-between; padding: 4px 0;">
                    <span>${term}</span>
                    <button onclick="removeFromCollection(${index})" style="color: red; background: none; border: none; cursor: pointer;">√ó</button>
                </div>`
            ).join('');
        }

        function removeFromCollection(index) {
            collectedTerms.splice(index, 1);
            updateCollectionDisplay();
        }

        function copyCollection() {
            if (collectedTerms.length === 0) {
                alert('No terms to copy');
                return;
            }
            
            const text = collectedTerms.join('\n');
            navigator.clipboard.writeText(text).then(() => {
                alert(`Copied ${collectedTerms.length} terms!`);
            });
        }

        // Search functionality
        async function performSearch() {
                const searchTerm = searchInput.value.trim();
                if (!searchTerm) {
                    alert('Please enter a search term');
                    return;
                }
                
            const selectedFiles = availableFiles.filter(file => {
                    const checkbox = document.getElementById(`file-${file}`);
                return checkbox && checkbox.checked;
                });
                
                if (selectedFiles.length === 0) {
                alert('Please select at least one data source');
                    return;
                }
                
            searchBtn.textContent = 'üîç Searching...';
            searchBtn.disabled = true;
            resultsSection.classList.remove('hidden');
            resultsContainer.innerHTML = '<div class="loading">Searching...</div>';
            
            try {
                // Use Algolia if available, otherwise fall back to Firestore
                let results;
                if (algoliaIndex) {
                    console.log('üöÄ Using Algolia search (fast & comprehensive)');
                    results = await searchAlgolia(searchTerm, selectedFiles);
            } else {
                    console.log('‚ö° Using Firestore search (fallback)');
                    results = await searchFirestore(searchTerm, selectedFiles);
                }
                
                displayResults(results);
            } catch (error) {
                console.error('Search error:', error);
                resultsContainer.innerHTML = `<div style="color: red; padding: 20px;">Search error: ${error.message}</div>`;
            } finally {
                searchBtn.textContent = 'üîç Search';
                searchBtn.disabled = false;
            }
        }

                async function searchFirestore(searchTerm, selectedFiles) {
            console.log('üîç High-performance search for:', searchTerm, 'across', selectedFiles.length, 'files');
            const results = [];
            const regex = wildcardToRegex(searchTerm);
            
            // Use Promise.all for parallel file searching
            const searchPromises = selectedFiles.map(fileName => searchSingleFile(fileName, searchTerm, regex));
            
            try {
                const fileResults = await Promise.all(searchPromises);
                
                // Combine all results
                for (const fileResult of fileResults) {
                    results.push(...fileResult);
                }
                
                // Sort by score and return top results
                const sortedResults = results
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 200);
                
                console.log(`üéØ Found ${sortedResults.length} results from ${results.length} total matches`);
                return sortedResults;
                
                                } catch (error) {
                console.error('Search error:', error);
                return [];
            }
        }
        

        
        function generateScoreLevels(minScore, maxScore, quickSearch) {
            // Respect Firestore's 10K limit per query
            const limit = quickSearch ? 5000 : 10000; // Stay under 10K limit
            return [{ min: minScore, max: maxScore, limit: limit }];
        }
        
        // NEW: Algolia Search Function
        async function searchAlgolia(searchTerm, selectedFiles) {
            if (!algoliaIndex) {
                console.error('‚ùå Algolia not configured. Please add your Search API Key.');
                return [];
            }
            
            console.log('üîç Algolia search for:', searchTerm, 'across', selectedFiles.length, 'files');
            console.log('üîç Index name:', ALGOLIA_CONFIG.indexName);
            
            try {
                // First, try a simple search without filters to test if index has data
                console.log('üß™ Testing simple search...');
                const testResult = await algoliaIndex.search('', { hitsPerPage: 10 });
                console.log(`üìä Index contains ${testResult.nbHits} total documents`);
                
                if (testResult.nbHits === 0) {
                    console.warn('‚ö†Ô∏è Index is empty - still indexing or index name mismatch');
                    return [];
                }
                
                // Convert search term to Algolia query
                let algoliaQuery = searchTerm;
                
                // Handle wildcards: Convert * to empty for prefix/suffix matching
                if (searchTerm.includes('*')) {
                    algoliaQuery = searchTerm.replace(/\*/g, '');
                }
                
                // Search with filters
                console.log('üîç Searching with query:', algoliaQuery);
                const searchOptions = {
                    hitsPerPage: 1000,
                    filters: selectedFiles.length > 0 ? `file:${selectedFiles.join(' OR file:')}` : '',
                    attributesToRetrieve: ['term', 'parentheses', 'score', 'file'],
                };
                
                const { hits, nbHits } = await algoliaIndex.search(algoliaQuery, searchOptions);
                console.log(`üéØ Algolia returned ${hits.length} results out of ${nbHits} total matches`);
                
                if (hits.length > 0) {
                    console.log('üìù Sample results:', hits.slice(0, 3));
                }
                
                // Apply client-side filtering for complex patterns
                const crosswordMode = document.getElementById('crossword-mode');
                const variableMode = document.getElementById('variable-mode');
                
                const filteredResults = hits.filter(hit => {
                    if (!hit.term) return false;
                    
                    // Apply variable mode first (most specific)
                    if (variableMode && variableMode.checked) {
                        return variableMatch(searchTerm, hit.term);
                    }
                    
                    // Apply crossword mode
                    if (crosswordMode && crosswordMode.checked) {
                        const cleanTerm = hit.term.replace(/[^a-zA-Z]/g, '');
                        const cleanPattern = searchTerm.replace(/[^a-zA-Z*?]/g, '');
                        if (cleanPattern !== searchTerm) {
                            // Has wildcards - create regex for clean pattern
                            const cleanRegex = wildcardToRegex(cleanPattern);
                            return cleanRegex.test(cleanTerm);
                        }
                        // No wildcards - simple letter-only match
                        return cleanTerm.toLowerCase().includes(cleanPattern.toLowerCase());
                    }
                    
                    // Standard wildcard/simple matching
                    const regex = wildcardToRegex(searchTerm);
                    return regex.test(hit.term);
                });
                
                console.log(`‚úÖ After filtering: ${filteredResults.length} matches`);
                
                return filteredResults.map(hit => ({
                    term: hit.term,
                    parentheses: hit.parentheses || '',
                    score: hit.score || 0,
                    file: hit.file
                })).sort((a, b) => b.score - a.score);
                
            } catch (error) {
                console.error('‚ùå Algolia search error:', error);
                console.error('Error details:', error.message);
                return [];
            }
        }
        
        async function searchSingleFile(fileName, searchTerm, regex) {
            console.log(`üîç Searching ${fileName}...`);
            const results = [];
            
            // Get UI filter settings
            const minScore = parseInt(document.getElementById('minScore').value) || 0;
            const maxScore = parseInt(document.getElementById('maxScore').value) || 100;
            const quickSearch = document.getElementById('quickSearch').checked;
            
            try {
                const toolsCollection = collection(firestore, 'tools');
                
                // Generate score levels based on user range and search mode
                const scoreLevels = generateScoreLevels(minScore, maxScore, quickSearch);
                
                console.log(`üéØ Score range: ${minScore}-${maxScore}, Quick: ${quickSearch}, Levels: ${scoreLevels.length}`);
                
                // PAGINATION: Multiple 10K queries to search more data
                const level = scoreLevels[0]; // Only one level now
                const maxBatches = quickSearch ? 2 : 5; // 2-5 batches of 10K each
                let lastDoc = null;
                
                for (let batch = 0; batch < maxBatches; batch++) {
                    try {
                        console.log(`üìä Batch ${batch + 1}/${maxBatches}: Querying ${fileName} with score ${level.min}-${level.max}, limit ${level.limit}`);
                        
                        let q;
                        if (level.min > 0) {
                            q = query(
                                toolsCollection,
                                where('file', '==', fileName),
                                where('score', '>=', level.min),
                                orderBy('score', 'desc'),
                                limit(level.limit)
                            );
                        } else {
                            // For min score 0, don't use score filter to avoid index issues
                            q = query(
                                toolsCollection,
                                where('file', '==', fileName),
                                orderBy('score', 'desc'),
                                limit(level.limit)
                            );
                        }
                        
                        // Add pagination cursor if not first batch
                        if (lastDoc) {
                            q = query(q, startAfter(lastDoc));
                        }
                        
                        const snapshot = await getDocs(q);
                        console.log(`‚úÖ ${fileName} Batch ${batch + 1}: Retrieved ${snapshot.size} docs`);
                        
                        if (snapshot.empty) {
                            console.log(`üèÅ ${fileName}: No more documents, stopping pagination`);
                            break; // No more documents
                        }
                        
                        snapshot.forEach(doc => {
                            const data = doc.data();
                            // Apply score filter client-side if needed
                            if (data.score >= level.min && data.score <= level.max && data.term && regex.test(data.term)) {
                                results.push({
                                    term: data.term,
                                    parentheses: data.parentheses || '',
                                    score: data.score || 0,
                                    file: data.file
                                });
                            }
                        });
                        
                        // Set cursor for next batch
                        lastDoc = snapshot.docs[snapshot.docs.length - 1];
                        
                        console.log(`üéØ ${fileName} Batch ${batch + 1}: Found ${results.length} total matches so far`);
                        
                        // Stop if we found enough results
                        if (results.length >= 100) {
                            console.log(`üéØ ${fileName}: Found enough results (${results.length}), stopping search`);
                            break;
                        }
                        
                    } catch (error) {
                        console.error(`‚ùå Batch ${batch + 1} failed for ${fileName}:`, error);
                        break; // Stop on error
                    }
                }
                
                console.log(`‚úÖ ${fileName}: ${results.length} matches`);
                return results;
                
            } catch (error) {
                console.error(`‚ùå Error searching ${fileName}:`, error);
                return [];
            }
        }

        function displayResults(results) {
            resultsCount.textContent = `${results.length} results`;
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div>No results found</div>';
                return;
            }
            
            const table = document.createElement('table');
                table.className = 'results-table';
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Score</th>
                        <th>Term</th>
                        <th>Notes</th>
                        <th>Wikipedia</th>
                        <th>Dictionary</th>
                        <th>Google</th>
                        <th>Add</th>
                    </tr>
                </thead>
                <tbody>
                    ${results.map(result => `
                        <tr>
                            <td><strong>${result.score}</strong></td>
                            <td><strong>${result.term}</strong></td>
                            <td>${result.parentheses}</td>
                            <td><a href="https://en.wikipedia.org/wiki/${encodeURIComponent(result.term.replace(/ /g, '_'))}" target="_blank" class="link-btn">üìñ Wiki</a></td>
                            <td><a href="https://www.merriam-webster.com/dictionary/${encodeURIComponent(result.term)}" target="_blank" class="link-btn">üìö Dict</a></td>
                            <td><a href="https://www.google.com/search?q=${encodeURIComponent(result.term)}" target="_blank" class="link-btn">üîç Google</a></td>
                            <td><button class="add-btn" onclick="addToCollection('${result.term.replace(/'/g, "\\'")}')">+</button></td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            
            resultsContainer.innerHTML = '';
                resultsContainer.appendChild(table);
        }
        
        // Event listeners
        searchBtn.addEventListener('click', performSearch);
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });

        document.getElementById('copy-collection').addEventListener('click', copyCollection);
        document.getElementById('clear-collection').addEventListener('click', () => {
            collectedTerms = [];
            updateCollectionDisplay();
        });

        // Make functions global
        window.addToCollection = addToCollection;
        window.removeFromCollection = removeFromCollection;
    </script>
</body>
</html> 
