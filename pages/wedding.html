<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wedding Puzzle</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  
  <!-- Crossword Nexus CSS -->
  <link href="../crossword-solver/css/crosswordnexus.css" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #FFD34E 0%, #FFCC00 25%, #FFD34E 50%, #FFCC00 75%, #FFD34E 100%);
      background-size: 200px 200px;
      background-attachment: fixed;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 40px;
      padding-bottom: 40px;
      position: relative;
      overflow-x: hidden;
      animation: subtleBackgroundShift 20s ease-in-out infinite;
    }
    
    @keyframes subtleBackgroundShift {
      0%, 100% { background-position: 0 0; }
      50% { background-position: 20px 20px; }
    }
    
    .container {
      max-width: 800px;
      width: 90%;
      margin: 0 auto;
      position: relative;
      z-index: 2;
    }
    
    .card {
      background: linear-gradient(145deg, #ffffff, #f8f9fa);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 
        0 20px 60px rgba(0,0,0,0.15),
        0 0 0 1px rgba(255,255,255,0.9) inset,
        0 2px 0 rgba(255,255,255,0.6) inset;
      margin-bottom: 30px;
      transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
      opacity: 0;
      transform: translateY(30px) scale(0.95);
      animation: cardEntranceAnimation 0.8s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
      border: 1px solid rgba(255,255,255,0.3);
      overflow: hidden;
      position: relative;
      backdrop-filter: blur(10px);
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, #FFD700, #FFCC00, #FFD700);
      opacity: 0.7;
    }
    
    @keyframes cardEntranceAnimation {
      0% {
        opacity: 0;
        transform: translateY(30px) scale(0.95);
      }
      60% {
        opacity: 0.8;
        transform: translateY(-5px) scale(1.02);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    .card:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 
        0 30px 80px rgba(0,0,0,0.2),
        0 0 0 1px rgba(255,255,255,0.9) inset,
        0 2px 0 rgba(255,255,255,0.6) inset;
    }
    
    .card-shake {
      animation: enhancedShake 0.6s cubic-bezier(0.36, 0.07, 0.19, 0.97);
    }
    
    @keyframes enhancedShake {
      0% { transform: translateX(0) scale(1); }
      10% { transform: translateX(-15px) scale(1.02); }
      20% { transform: translateX(15px) scale(0.98); }
      30% { transform: translateX(-12px) scale(1.01); }
      40% { transform: translateX(12px) scale(0.99); }
      50% { transform: translateX(-8px) scale(1.005); }
      60% { transform: translateX(8px) scale(0.995); }
      70% { transform: translateX(-4px) scale(1.002); }
      80% { transform: translateX(4px) scale(0.998); }
      90% { transform: translateX(-2px) scale(1.001); }
      100% { transform: translateX(0) scale(1); }
    }
    
    /* Enhanced screen transition animations */
    .screen-transition {
      animation: smoothFadeSlideIn 0.8s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
    }
    
    @keyframes smoothFadeSlideIn {
      0% {
        opacity: 0;
        transform: translateY(40px) scale(0.95);
        filter: blur(5px);
      }
      60% {
        opacity: 0.8;
        filter: blur(1px);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
    }
    
    .screen-exit {
      animation: smoothFadeSlideOut 0.6s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
    }
    
    @keyframes smoothFadeSlideOut {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
      40% {
        opacity: 0.6;
        filter: blur(1px);
      }
      100% {
        opacity: 0;
        transform: translateY(-40px) scale(0.95);
        filter: blur(5px);
      }
    }
    
    h1 {
      text-align: center;
      background: linear-gradient(135deg, #333, #111, #333);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 30px;
      font-size: 2.8rem;
      font-weight: 800;
      text-shadow: 2px 2px 0px rgba(0,0,0,0.1);
      letter-spacing: -1px;
      position: relative;
    }
    
    h1::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      width: 60px;
      height: 3px;
      background: linear-gradient(90deg, #FFD700, #FFCC00);
      transform: translateX(-50%);
      border-radius: 2px;
    }
    
    h2 {
      margin-top: 0;
      font-size: 1.9rem;
      color: #222;
      border-bottom: 3px solid #FFCC00;
      padding-bottom: 15px;
      margin-bottom: 25px;
      position: relative;
      font-weight: 600;
    }
    
    h2::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 0;
      width: 40px;
      height: 3px;
      background: #FFD700;
      border-radius: 2px;
    }
    
    p {
      font-size: 1.1rem;
      line-height: 1.7;
      color: #444;
    }
    
    .form-group {
      margin-bottom: 25px;
      position: relative;
    }
    
    label {
      display: block;
      margin-bottom: 12px;
      font-weight: 600;
      color: #333;
      font-size: 1.05rem;
      transition: color 0.3s ease;
    }
    
    input[type="text"],
    input[type="email"] {
      width: 100%;
      padding: 18px 20px;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      font-size: 16px;
      background: linear-gradient(145deg, #ffffff, #f8f9fa);
      outline: none;
      transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
      box-sizing: border-box;
      box-shadow: 
        0 4px 15px rgba(0,0,0,0.05),
        0 0 0 1px rgba(255,255,255,0.9) inset;
      position: relative;
    }
    
    input[type="text"]:hover,
    input[type="email"]:hover {
      border-color: #ccc;
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(0,0,0,0.1),
        0 0 0 1px rgba(255,255,255,0.9) inset;
    }
    
    input[type="text"]:focus,
    input[type="email"]:focus {
      border-color: #FFCC00;
      transform: translateY(-3px);
      box-shadow: 
        0 12px 35px rgba(255, 204, 0, 0.2),
        0 0 0 4px rgba(255, 204, 0, 0.1),
        0 0 0 1px rgba(255,255,255,0.9) inset;
    }
    
    input[type="text"]:focus + label,
    input[type="email"]:focus + label {
      color: #FFCC00;
    }
    
    .btn {
      display: inline-block;
      padding: 18px 32px;
      background: linear-gradient(135deg, #000000, #333333, #000000);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      text-decoration: none;
      text-align: center;
      transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
      width: 100%;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      box-shadow: 
        0 8px 25px rgba(0,0,0,0.2),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn:hover {
      background: linear-gradient(135deg, #333333, #555555, #333333);
      transform: translateY(-4px);
      box-shadow: 
        0 15px 40px rgba(0,0,0,0.25),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn:active {
      transform: translateY(-2px);
      box-shadow: 
        0 8px 20px rgba(0,0,0,0.15),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn:disabled {
      background: linear-gradient(135deg, #cccccc, #e0e0e0, #cccccc);
      color: #888;
      cursor: not-allowed;
      transform: none;
      box-shadow: 
        0 2px 8px rgba(0,0,0,0.1),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn:disabled:hover {
      background: linear-gradient(135deg, #cccccc, #e0e0e0, #cccccc);
      transform: none;
      box-shadow: 
        0 2px 8px rgba(0,0,0,0.1),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn-secondary {
      background: linear-gradient(135deg, #555, #777, #555);
      margin-top: 15px;
    }
    
    .btn-secondary:hover {
      background: linear-gradient(135deg, #666, #888, #666);
    }
    
    .btn-nav {
      width: auto;
      padding: 12px 24px;
      font-size: 14px;
      background: linear-gradient(135deg, #555, #777, #555);
      text-transform: none;
      letter-spacing: 0.5px;
      min-width: 50px;
      position: relative;
      overflow: hidden;
    }
    
    .btn-nav:hover {
      background: linear-gradient(135deg, #666, #888, #666);
    }
    
    .btn-nav.current-puzzle {
      background: linear-gradient(135deg, #2E7D32, #4CAF50, #2E7D32);
      border: 2px solid #4CAF50;
      box-shadow: 
        0 4px 15px rgba(76, 175, 80, 0.4),
        0 0 0 1px rgba(255,255,255,0.2) inset;
      transform: scale(1.05);
      font-weight: 700;
    }
    
    .btn-nav.current-puzzle:hover {
      background: linear-gradient(135deg, #388E3C, #66BB6A, #388E3C);
      transform: scale(1.05);
    }
    
    .btn-nav.current-puzzle::before {
      content: '';
      position: absolute;
      bottom: 8px;
      left: 50%;
      width: 4px;
      height: 4px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      transform: translateX(-50%);
      animation: currentPuzzlePulse 2s ease-in-out infinite;
    }
    
    @keyframes currentPuzzlePulse {
      0%, 100% {
        opacity: 0.8;
        transform: translateX(-50%) scale(1);
      }
      50% {
        opacity: 1;
        transform: translateX(-50%) scale(1.5);
      }
    }
    
    .btn-nav.solved-puzzle {
      background: linear-gradient(135deg, #4CAF50, #66BB6A, #4CAF50);
      color: white;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
    
    .btn-nav.solved-puzzle:hover {
      background: linear-gradient(135deg, #66BB6A, #81C784, #66BB6A);
    }
    
    .puzzle-nav-container {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-left: auto;
      align-items: center;
    }
    
    .clue-image {
      max-width: 100%;
      border-radius: 8px;
      margin-bottom: 25px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.15);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .clue-image:hover {
      transform: scale(1.02);
      box-shadow: 0 12px 28px rgba(0,0,0,0.2);
    }
    
    .clue-gallery {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 25px;
      justify-content: center;
    }
    
    .clue-gallery img {
      max-width: calc(50% - 10px);
      max-height: 250px;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transition: all 0.3s ease;
    }
    
    .clue-gallery img:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 0 12px 24px rgba(0,0,0,0.2);
    }
    
    .clue-gallery img:only-child {
      max-width: 100%;
    }
    
    .feedback-message {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      padding: 20px 30px;
      border-radius: 16px;
      color: white;
      font-weight: 600;
      box-shadow: 
        0 20px 40px rgba(0,0,0,0.3),
        0 0 0 1px rgba(255,255,255,0.2) inset;
      z-index: 100;
      opacity: 0;
      transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
      text-align: center;
      min-width: 250px;
      max-width: 80%;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .feedback-message.success {
      background: linear-gradient(135deg, #4CAF50, #66BB6A);
    }
    
    .feedback-message.error {
      background: linear-gradient(135deg, #f44336, #ef5350);
    }
    
    .feedback-message.info {
      background: linear-gradient(135deg, #2196F3, #42A5F5);
    }
    
    .feedback-message.show {
      opacity: 1;
      transform: translate(-50%, -15px) scale(1.02);
    }
    
    .hint-toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ff9800, #ffb74d);
      color: white;
      padding: 16px 24px;
      border-radius: 16px;
      display: none;
      z-index: 100;
      animation: hintToastEntrance 0.6s cubic-bezier(0.165, 0.84, 0.44, 1), hintFloat 3s ease-in-out infinite 0.6s;
      font-weight: 600;
      box-shadow: 
        0 15px 35px rgba(255, 152, 0, 0.4),
        0 0 0 1px rgba(255,255,255,0.2) inset;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    @keyframes hintToastEntrance {
      0% {
        opacity: 0;
        transform: translateX(-50%) translateY(20px) scale(0.9);
      }
      100% {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
      }
    }
    
    @keyframes hintFloat {
      0%, 100% { transform: translateX(-50%) translateY(0px); }
      50% { transform: translateX(-50%) translateY(-8px); }
    }
    
    .hint-toast.show {
      display: block;
    }
    
    .loader {
      border: 6px solid rgba(255, 255, 255, 0.2);
      border-top: 6px solid #000000;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: smoothSpin 1.2s cubic-bezier(0.4, 0.0, 0.2, 1) infinite;
      margin: 40px auto;
      position: relative;
    }
    
    .loader::after {
      content: '';
      position: absolute;
      top: -6px;
      left: -6px;
      right: -6px;
      bottom: -6px;
      border: 6px solid transparent;
      border-top: 6px solid rgba(255, 204, 0, 0.3);
      border-radius: 50%;
      animation: smoothSpin 2s cubic-bezier(0.4, 0.0, 0.2, 1) infinite reverse;
    }
    
    @keyframes smoothSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .puzzle-transition {
      transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
    }
    
    .puzzle-content-enter {
      opacity: 0;
      transform: translateY(20px) scale(0.98);
      filter: blur(3px);
    }
    
    .puzzle-content-enter-active {
      opacity: 1;
      transform: translateY(0) scale(1);
      filter: blur(0);
      transition: all 0.8s cubic-bezier(0.165, 0.84, 0.44, 1);
    }
    
    .puzzle-content-exit {
      opacity: 1;
      transform: translateY(0) scale(1);
      filter: blur(0);
    }
    
    .puzzle-content-exit-active {
      opacity: 0;
      transform: translateY(-20px) scale(0.98);
      filter: blur(3px);
      transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
    }
    
    .hidden {
      display: none;
    }
    
    .fade-in {
      animation: fadeIn 0.5s ease-in-out;
    }
    
    .error-message {
      color: #e53935;
      background-color: #ffebee;
      padding: 12px 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: 500;
      border-left: 4px solid #e53935;
    }
    
    .navigation-controls {
      display: flex;
      justify-content: flex-start;
      margin-bottom: 25px;
    }
    
    .multi-answer-container {
      margin-bottom: 20px;
      border-left: 4px solid #e0e0e0;
      padding-left: 20px;
      transition: all 0.5s cubic-bezier(0.165, 0.84, 0.44, 1);
      position: relative;
      padding-top: 8px;
      padding-bottom: 8px;
      border-radius: 0 12px 12px 0;
      background: linear-gradient(90deg, transparent, rgba(224, 224, 224, 0.05));
    }
    
    .multi-answer-container:hover {
      border-left-color: #ccc;
      background: linear-gradient(90deg, transparent, rgba(200, 200, 200, 0.08));
      transform: translateX(3px);
    }
    
    .multi-answer-container.correct {
      border-left-color: #4CAF50;
      background: linear-gradient(90deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
      padding: 15px 20px 15px 25px;
      box-shadow: 0 4px 20px rgba(76, 175, 80, 0.2);
      animation: correctAnswerPulse 0.6s ease-out;
    }
    
    .multi-answer-container.correct::before {
      content: '✓';
      position: absolute;
      left: -30px;
      top: 50%;
      transform: translateY(-50%);
      color: #4CAF50;
      font-weight: bold;
      font-size: 18px;
      background: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
      animation: checkmarkAppear 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .multi-answer-container.incorrect {
      border-left-color: #f44336;
      background: linear-gradient(90deg, rgba(244, 67, 54, 0.1), rgba(244, 67, 54, 0.05));
      padding: 15px 20px 15px 25px;
      box-shadow: 0 4px 20px rgba(244, 67, 54, 0.2);
      animation: incorrectAnswerShake 0.6s ease-out;
    }
    
    .multi-answer-container.incorrect::before {
      content: '✗';
      position: absolute;
      left: -30px;
      top: 50%;
      transform: translateY(-50%);
      color: #f44336;
      font-weight: bold;
      font-size: 18px;
      background: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
      animation: crossAppear 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    @keyframes correctAnswerPulse {
      0% {
        background: linear-gradient(90deg, rgba(76, 175, 80, 0.0), rgba(76, 175, 80, 0.0));
        transform: scale(1);
      }
      50% {
        background: linear-gradient(90deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
        transform: scale(1.02);
      }
      100% {
        background: linear-gradient(90deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
        transform: scale(1);
      }
    }
    
    @keyframes incorrectAnswerShake {
      0%, 100% {
        transform: translateX(0);
      }
      25% {
        transform: translateX(-3px);
      }
      75% {
        transform: translateX(3px);
      }
    }
    
    @keyframes checkmarkAppear {
      0% { 
        opacity: 0; 
        transform: scale(0.3) rotate(-45deg);
      }
      70% {
        opacity: 1;
        transform: scale(1.2) rotate(0deg);
      }
      100% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg);
      }
    }
    
    @keyframes crossAppear {
      0% {
        opacity: 0;
        transform: translateY(-50%) scale(0) rotate(180deg);
      }
      70% {
        transform: translateY(-50%) scale(1.2) rotate(0deg);
      }
      100% {
        opacity: 1;
        transform: translateY(-50%) scale(1) rotate(0deg);
      }
    }
    
    .welcome-message {
      text-align: center;
      margin-bottom: 25px;
      color: #333;
      font-size: 1.2em;
      line-height: 1.5;
    }
    
    .clue-content {
      margin-bottom: 25px;
      line-height: 1.6;
      font-size: 1.05rem;
      color: #333;
    }
    
    .clue-content img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin: 15px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .clue-content ul, .clue-content ol {
      padding-left: 25px;
      margin: 15px 0;
    }
    
    .page-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.4;
      pointer-events: none;
    }
    
    .confetti-piece {
      position: absolute;
      width: 10px;
      height: 20px;
      background-color: #ffd700;
      top: -20px;
      opacity: 0;
    }
    
    .success-checkmark {
      width: 100px;
      height: 100px;
      margin: 0 auto 20px;
      position: relative;
      display: none;
      animation: checkmarkBounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .success-checkmark.show {
      display: block;
    }
    
    .success-checkmark .check-icon {
      width: 100px;
      height: 100px;
      position: relative;
      border-radius: 50%;
      box-sizing: content-box;
      border: 5px solid #4CAF50;
      background: linear-gradient(145deg, #ffffff, #f8f9fa);
      box-shadow: 
        0 10px 30px rgba(76, 175, 80, 0.3),
        0 0 0 1px rgba(255,255,255,0.9) inset;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      color: #4CAF50;
      font-weight: bold;
    }
    
    .success-checkmark .check-icon::before {
      content: '✓';
      animation: checkmarkAppear 0.5s ease 0.3s forwards;
      opacity: 0;
      transform: scale(0.3) rotate(-45deg);
    }
    
    @keyframes checkmarkBounceIn {
      0% {
      opacity: 0;
        transform: scale(0.3);
      }
      50% {
        opacity: 1;
        transform: scale(1.1);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes checkmarkAppear {
      0% { 
        opacity: 0; 
        transform: scale(0.3) rotate(-45deg);
      }
      70% {
        opacity: 1;
        transform: scale(1.2) rotate(0deg);
      }
      100% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg);
      }
    }
    
    #success-display {
      text-align: center;
      margin-bottom: 20px;
      padding: 30px;
      background: linear-gradient(145deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
      border-radius: 20px;
      border: 2px solid rgba(76, 175, 80, 0.2);
      box-shadow: 0 10px 30px rgba(76, 175, 80, 0.15);
    }
    
    #success-display h2 {
      color: #4CAF50;
      margin-bottom: 15px;
      font-size: 2rem;
      font-weight: 700;
    }
    
    #success-display p {
      color: #2E7D32;
      font-size: 1.1rem;
      margin: 0;
    }
    
    @media (max-width: 600px) {
      .container {
        width: 92%;
        padding: 0;
      }
      
      .card {
        padding: 25px 20px;
      }
      
      h1 {
        font-size: 2rem;
        margin-bottom: 20px;
      }
      
      h2 {
        font-size: 1.5rem;
      }
      
      .clue-gallery img {
        max-width: 100%;
        margin-bottom: 15px;
      }
      
      .navigation-controls {
        flex-direction: column;
        gap: 10px;
      }
      
      .btn-nav {
        width: 100%;
      }
      
      input[type="text"], 
      input[type="email"] {
        padding: 12px 14px;
        font-size: 15px;
      }
      
      .btn {
        padding: 12px 20px;
        font-size: 15px;
      }
    }
    
    .answer-input:disabled {
      background: linear-gradient(145deg, #f5f5f5, #eeeeee);
      color: #666;
      cursor: not-allowed;
      border-color: #ddd;
    }
    
    .answer-input:disabled:hover,
    .answer-input:disabled:focus {
      background: linear-gradient(145deg, #f5f5f5, #eeeeee);
      border-color: #ddd;
      transform: none;
      box-shadow: none;
    }
    
    .puzzle-solved-indicator {
      display: inline-block;
      padding: 6px 12px;
      background: linear-gradient(135deg, #4CAF50, #66BB6A);
      color: white;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      margin-left: 15px;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
    
    /* Crossword Integration Styles */
    .crossword-container {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      margin: 20px 0;
    }
    
    .crossword-instructions {
      background: #f0f8ff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      border-left: 4px solid #4CAF50;
      font-size: 14px;
      color: #333;
    }
    
    /* Anti-cheat: Hide all reveal and check buttons */
    .crossword-toolbar .check-word-btn,
    .crossword-toolbar .check-puzzle-btn,
    .crossword-toolbar .reveal-letter-btn,
    .crossword-toolbar .reveal-word-btn,
    .crossword-toolbar .reveal-puzzle-btn,
    .reveal-button,
    .check-button,
    button[onclick*="reveal"],
    button[onclick*="check"],
    input[value*="Reveal"],
    input[value*="Check"],
    .cw-check,
    .cw-reveal,
    .cw-menu-container.cw-check,
    .cw-menu-container.cw-reveal {
      display: none !important;
      visibility: hidden !important;
    }
    
    .crossword-completion-form {
      margin-top: 20px;
      padding: 20px;
      background: linear-gradient(145deg, #f8f9fa, #ffffff);
      border-radius: 12px;
      border: 2px solid #e0e0e0;
      text-align: center;
    }
    
    .crossword-completion-form.ready {
      border-color: #4CAF50;
      background: linear-gradient(145deg, #f1f8e9, #ffffff);
    }
    
    .crossword-progress {
      background: #e3f2fd;
      padding: 10px 15px;
      border-radius: 8px;
      margin: 15px 0;
      text-align: center;
      font-weight: 500;
      color: #1976d2;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Wedding Puzzle</h1>
    
    <div id="card" class="card">
      <div id="loading" class="loader"></div>
      
      <!-- Success message display -->
      <div id="success-display" class="hidden">
        <div class="success-checkmark">
          <div class="check-icon"></div>
        </div>
        <h2>Correct!</h2>
        <p id="success-message">Great job! Moving to the next puzzle...</p>
      </div>
      
      <!-- Screen 0: Name & Email Form -->
      <div id="screen-0" class="hidden">
        <h2>Welcome to the Wedding Puzzle!</h2>
        <p>Please enter your information to get started:</p>
        
        <div id="registration-error" class="error-message hidden">
          Error registering user. Please try again.
        </div>
        
        <form id="info-form">
          <div class="form-group">
            <label for="name">Your Name:</label>
            <input type="text" id="name" required>
          </div>
          
          <div class="form-group">
            <label for="email">Your Email:</label>
            <input type="email" id="email" required>
          </div>
          
          <button type="submit" class="btn">Start Puzzle</button>
        </form>
      </div>
      
      <!-- Welcome Back Screen -->
      <div id="screen-welcome-back" class="hidden">
        <h2>Welcome Back!</h2>
        <p id="welcome-back-message" class="welcome-message">It's great to see you again.</p>
        
        <button id="continue-btn" class="btn">Continue Your Progress</button>
        <button id="restart-from-beginning-btn" class="btn btn-secondary">Start from Beginning</button>
      </div>
      
      <!-- Screens 1-10: Puzzles -->
      <div id="screen-puzzle" class="hidden">
        <div class="navigation-controls">
          <button id="prev-puzzle-btn" class="btn btn-nav">← Previous</button>
          <div id="puzzle-nav" class="puzzle-nav-container">
            <!-- Puzzle navigation buttons will be inserted here -->
          </div>
        </div>
        
        <h2 id="puzzle-name">Puzzle #1</h2>
        
        <div id="puzzle-error" class="error-message hidden">
          Error loading puzzle. Please refresh the page to try again.
        </div>
        
        <div id="clue-container">
          <div id="clue-content" class="clue-content"></div>
          <div id="clue-gallery" class="clue-gallery hidden"></div>
        </div>
        
        <form id="answer-form">
          <div id="answers-container">
            <!-- Dynamic answer fields will be inserted here -->
          </div>
          
          <button type="submit" class="btn">Submit Answer</button>
        </form>
      </div>
      
      <!-- Screen 11: Completion -->
      <div id="screen-complete" class="hidden">
        <div id="ending-page-content">
          <!-- Custom ending page content will be loaded here -->
        </div>
        
        <button id="restart-btn" class="btn">Start Over</button>
      </div>
    </div>
  </div>
  
  <div id="hint-toast" class="hint-toast">Need a hint? Ask the puzzle master!</div>
  <div id="feedback-message" class="feedback-message"></div>
  
  <!-- Canvas for confetti -->
  <canvas id="confetti-canvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:99;"></canvas>
  
  <!-- Crossword Nexus JavaScript -->
  <script src="../crossword-solver/js/puz.js"></script>
  <script src="../crossword-solver/js/jpz.js"></script>
  <script src="../crossword-solver/js/crosswords.js"></script>
  
  <script>
    // Firebase database URL - Using only direct REST API
    const DB_URL = "https://eviltrivia-47664-default-rtdb.firebaseio.com";
    
    // DOM Elements
    const loading = document.getElementById('loading');
    const card = document.getElementById('card');
    const screen0 = document.getElementById('screen-0');
    const screenWelcomeBack = document.getElementById('screen-welcome-back');
    const screenPuzzle = document.getElementById('screen-puzzle');
    const screenComplete = document.getElementById('screen-complete');
    
    const infoForm = document.getElementById('info-form');
    const answerForm = document.getElementById('answer-form');
    const puzzleName = document.getElementById('puzzle-name');
    const clueText = document.getElementById('clue-text');
    const clueImage = document.getElementById('clue-image');
    const completionMessage = document.getElementById('completion-message');
    const endingPageContent = document.getElementById('ending-page-content');
    const restartBtn = document.getElementById('restart-btn');
    const hintToast = document.getElementById('hint-toast');
    const registrationError = document.getElementById('registration-error');
    const puzzleError = document.getElementById('puzzle-error');
    const welcomeBackMessage = document.getElementById('welcome-back-message');
    const continueBtn = document.getElementById('continue-btn');
    const restartFromBeginningBtn = document.getElementById('restart-from-beginning-btn');
    const prevPuzzleBtn = document.getElementById('prev-puzzle-btn');
    const nextPuzzleBtn = document.getElementById('next-puzzle-btn');
    const answersContainer = document.getElementById('answers-container');
    
    // Game state
    let currentScreen = 0;
    let totalPuzzles = 10; // Default
    let wrongAttempts = 0;
    let puzzleData = null;
    let userId = null;
    let userName = '';
    let userEmail = '';
    let solvedPuzzles = [];
    
    // Global variables to store custom messages
    let customSuccessMessages = {
      puzzleSolved: 'Correct! Moving to Puzzle {nextPuzzle}...',
      lastPuzzle: 'Congratulations! You\'ve solved all the puzzles!',
      allComplete: 'Amazing work! All puzzles completed!'
    };
    
    // Fetch custom success messages from database
    async function fetchSuccessMessages() {
      try {
        const paths = [
          `wedding/successMessages`,
          `publicAnswers/wedding/successMessages`
        ];
        
        for (const path of paths) {
          try {
            const response = await fetch(`${DB_URL}/${path}.json`);
            if (response.ok) {
              const data = await response.json();
              if (data) {
                customSuccessMessages = {
                  puzzleSolved: data.puzzleSolved || customSuccessMessages.puzzleSolved,
                  lastPuzzle: data.lastPuzzle || customSuccessMessages.lastPuzzle,
                  allComplete: data.allComplete || customSuccessMessages.allComplete
                };
                console.log('Loaded custom success messages:', customSuccessMessages);
                return;
              }
            }
          } catch (error) {
            console.error(`Error fetching success messages from ${path}:`, error);
          }
        }
      } catch (error) {
        console.warn('Could not load custom success messages:', error);
      }
    }
    
    // Show the loading spinner initially
    loading.style.display = 'block';
    
    // Generate a unique anonymous user ID if needed
    function getOrCreateUserId() {
      const storedId = localStorage.getItem('weddingPuzzleId');
      if (storedId) return storedId;
      
      // Generate a new anonymous ID - completely local, no Firebase auth
      const newId = 'anon_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('weddingPuzzleId', newId);
      return newId;
    }
    
    // Fetch and apply welcome page content (title, heading, intro)
    async function applyWelcomePageContent() {
      try {
        const paths = [
          `wedding/welcomePage`,
          `publicAnswers/wedding/welcomePage`
        ];
        let content = null;

        for (const path of paths) {
          try {
            const response = await fetch(`${DB_URL}/${path}.json`);
            if (response.ok) {
              const data = await response.json();
              if (data) {
                content = data;
                break; // Found content, stop checking other paths
              }
            }
          } catch (error) {
            console.warn(`Could not load welcome page content from ${path}:`, error);
          }
        }

        const mainHeader = document.querySelector('h1'); // First H1 for site header
        const screen0WelcomeHeader = screen0.querySelector('h2');
        const screen0WelcomePara = screen0.querySelector('p');
        const nameLabel = screen0.querySelector('label[for="name"]');
        const emailLabel = screen0.querySelector('label[for="email"]');
        const startButton = screen0.querySelector('#info-form button[type="submit"]');

        // Default texts
        const defaults = {
          title: 'Wedding Puzzle',
          siteHeader: 'Wedding Puzzle',
          heading: 'Welcome to the Wedding Puzzle!',
          intro: 'Please enter your information to get started:',
          nameLabel: 'Your Name:',
          emailLabel: 'Your Email:',
          startButton: 'Start Puzzle'
        };

        if (content) {
          document.title = content.title || defaults.title;
          if (mainHeader) mainHeader.textContent = content.siteHeader || defaults.siteHeader;
          if (screen0WelcomeHeader) screen0WelcomeHeader.textContent = content.heading || defaults.heading;
          if (screen0WelcomePara) screen0WelcomePara.textContent = content.intro || defaults.intro;
          if (nameLabel) nameLabel.textContent = content.nameLabel || defaults.nameLabel;
          if (emailLabel) emailLabel.textContent = content.emailLabel || defaults.emailLabel;
          if (startButton) startButton.textContent = content.startButton || defaults.startButton;
          console.log('Loaded custom welcome page content:', content);
        } else {
          // Apply defaults if nothing is found
          document.title = defaults.title;
          if (mainHeader) mainHeader.textContent = defaults.siteHeader;
          if (screen0WelcomeHeader) screen0WelcomeHeader.textContent = defaults.heading;
          if (screen0WelcomePara) screen0WelcomePara.textContent = defaults.intro;
          if (nameLabel) nameLabel.textContent = defaults.nameLabel;
          if (emailLabel) emailLabel.textContent = defaults.emailLabel;
          if (startButton) startButton.textContent = defaults.startButton;
          console.log('Applied default welcome page content.');
        }
      } catch (error) {
        console.warn('Error applying welcome page content:', error);
        // Ensure defaults are set even on unexpected error
        const defaultsOnError = {
          title: 'Wedding Puzzle',
          siteHeader: 'Wedding Puzzle',
          heading: 'Welcome to the Wedding Puzzle!',
          intro: 'Please enter your information to get started:',
          nameLabel: 'Your Name:',
          emailLabel: 'Your Email:',
          startButton: 'Start Puzzle'
        };
        document.title = defaultsOnError.title;
        const mainHeaderOnError = document.querySelector('h1');
        const screen0WelcomeHeaderOnError = screen0.querySelector('h2');
        const screen0WelcomeParaOnError = screen0.querySelector('p');
        const nameLabelOnError = screen0.querySelector('label[for="name"]');
        const emailLabelOnError = screen0.querySelector('label[for="email"]');
        const startButtonOnError = screen0.querySelector('#info-form button[type="submit"]');

        if (mainHeaderOnError) mainHeaderOnError.textContent = defaultsOnError.siteHeader;
        if (screen0WelcomeHeaderOnError) screen0WelcomeHeaderOnError.textContent = defaultsOnError.heading;
        if (screen0WelcomeParaOnError) screen0WelcomeParaOnError.textContent = defaultsOnError.intro;
        if (nameLabelOnError) nameLabelOnError.textContent = defaultsOnError.nameLabel;
        if (emailLabelOnError) emailLabelOnError.textContent = defaultsOnError.emailLabel;
        if (startButtonOnError) startButtonOnError.textContent = defaultsOnError.startButton;
      }
    }
    
    // Switch screens with animation
    function switchScreen(fromScreen, toScreen) {
      if (fromScreen) {
        // Animate exit of current screen
        fromScreen.classList.add('screen-exit');
        setTimeout(() => {
          fromScreen.classList.add('hidden');
          fromScreen.classList.remove('screen-exit');
          
          // Animate entrance of new screen
          toScreen.classList.remove('hidden');
          toScreen.classList.add('screen-transition');
          setTimeout(() => {
            toScreen.classList.remove('screen-transition');
          }, 800); // Adjusted from 600ms to match 0.8s screen-transition animation
        }, 600); // Adjusted from 500ms to match 0.6s screen-exit animation
      } else {
        // No previous screen, just show new screen
        toScreen.classList.remove('hidden');
        toScreen.classList.add('screen-transition');
        setTimeout(() => {
          toScreen.classList.remove('screen-transition');
        }, 600);
      }
    }
    
    // Initialize - Check for existing progress in localStorage
    document.addEventListener('DOMContentLoaded', async function() {
      // Ensure we have a user ID even for anonymous users
      userId = getOrCreateUserId();
      
      // Apply custom welcome page content first
      await applyWelcomePageContent();
      
      // Load total puzzles count first
      await loadTotalPuzzles();
      
      // Load custom success messages
      await fetchSuccessMessages();
      
      const storedName = localStorage.getItem('weddingPuzzleName');
      const storedEmail = localStorage.getItem('weddingPuzzleEmail');
      const storedScreen = localStorage.getItem('weddingPuzzleScreen');
      
      if (storedName && storedEmail && storedScreen) {
        // Restore saved state
        userName = storedName;
        userEmail = storedEmail;
        currentScreen = parseInt(storedScreen);
        
        // Check if this is a fresh page load (not a form submission)
        const isPageRefresh = !document.referrer || (document.referrer && document.referrer.split('?')[0] === window.location.href.split('?')[0]);
        
        if (isPageRefresh && currentScreen > 0) {
          // Load solved puzzles before showing welcome back
          await loadSolvedPuzzles();
          // Show welcome back screen
          showWelcomeBack();
        } else if (currentScreen >= 1 && currentScreen <= totalPuzzles) {
          // Load solved puzzles before continuing with puzzle
          await loadSolvedPuzzles();
          // Continue with a puzzle
          loadPuzzle(currentScreen);
        } else if (currentScreen > totalPuzzles) {
          // Load solved puzzles before showing completion
          await loadSolvedPuzzles();
          // Show completion screen instead of trying to load non-existent puzzle
          console.log(`📊 Requested puzzle ${currentScreen} is beyond totalPuzzles (${totalPuzzles}), going to completion`);
          showCompletion();
        } else {
          // Default to registration
          showScreen0();
        }
      } else {
        // No saved state, show registration
        showScreen0();
      }
    });
    
    // Load the total number of puzzles from the database
    async function loadTotalPuzzles() {
      try {
        // Try primary path
        let response = await fetch(`${DB_URL}/wedding/totalPuzzles.json`);
        
        // If primary failed, try backup path
        if (!response || !response.ok) {
          response = await fetch(`${DB_URL}/publicAnswers/wedding/totalPuzzles.json`);
        }
        
        if (response && response.ok) {
          const count = await response.json();
          if (count && !isNaN(count)) {
            totalPuzzles = count;
            console.log(`📊 Loaded totalPuzzles from database: ${totalPuzzles}`);
          }
        }
        
        console.log(`📊 Final totalPuzzles: ${totalPuzzles}`);
      } catch (error) {
        console.warn('Could not load total puzzles count, using default:', error);
      }
    }
    
    // Load the solved puzzles array from localStorage AND database
    async function loadSolvedPuzzles() {
      try {
        // Try to fetch progress from database first
        const result = await fetchUserProgressFromDatabase();
        
        if (result.data && result.data.solved && Array.isArray(result.data.solved)) {
          solvedPuzzles = [...result.data.solved]; // Create a copy
          
          // Load user answers from database
          if (result.data.userAnswers && typeof result.data.userAnswers === 'object') {
            window.userCorrectAnswers = { ...result.data.userAnswers }; // Create a copy
            console.log('📥 Loaded user answers from database:', window.userCorrectAnswers);
            
            // Verify the data structure
            Object.keys(window.userCorrectAnswers).forEach(puzzleNum => {
              const answers = window.userCorrectAnswers[puzzleNum];
              if (!Array.isArray(answers)) {
                console.warn(`⚠ Puzzle ${puzzleNum} answers are not an array:`, answers);
              } else {
                console.log(`✓ Puzzle ${puzzleNum} has ${answers.length} answers:`, answers);
              }
            });
          } else {
            window.userCorrectAnswers = {};
            console.log('📥 No user answers found in database');
          }
          
          // Update localStorage to match database
          const localProgress = {
            solved: [...solvedPuzzles],
            userAnswers: { ...window.userCorrectAnswers },
            currentScreen: result.data.currentScreen || currentScreen,
            name: result.data.name || userName,
            email: result.data.email || userEmail,
            timestamp: new Date().toISOString()
          };
          localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
          
          console.log('📥 Loaded progress from database:', { 
            solved: solvedPuzzles, 
            currentScreen: result.data.currentScreen,
            userAnswersCount: Object.keys(window.userCorrectAnswers).length 
          });
          return;
        }
      } catch (error) {
        console.warn('Could not load progress from database:', error);
      }
      
      // Fallback to localStorage if database unavailable
      const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
      if (localProgress.solved && Array.isArray(localProgress.solved)) {
        solvedPuzzles = [...localProgress.solved];
      } else {
        // Initialize with default
        solvedPuzzles = Array(totalPuzzles + 1).fill(false);
      }
      
      // Also load user's correct answers for pre-filling
      if (localProgress.userAnswers && typeof localProgress.userAnswers === 'object') {
        window.userCorrectAnswers = { ...localProgress.userAnswers };
        console.log('📥 Loaded user answers from localStorage:', window.userCorrectAnswers);
      } else {
        window.userCorrectAnswers = {};
        console.log('📥 No user answers found in localStorage');
      }
      
      console.log('📥 Loaded progress from localStorage:', { solved: solvedPuzzles });
    }
    
    // Fetch user progress from database
    async function fetchUserProgressFromDatabase() {
      if (!userId) return { data: null, path: null };
      
      const paths = [
        `wedding/progress/${userId}`,
        `publicAnswers/wedding/progress/${userId}`
      ];
      
      for (const path of paths) {
        try {
          const response = await fetch(`${DB_URL}/${path}.json`);
          if (response.ok) {
            const data = await response.json();
            if (data) {
              return { data, path: path.split('/').slice(0, -2).join('/') };
            }
          }
        } catch (error) {
          console.error(`Error fetching from ${path}:`, error);
        }
      }
      return { data: null, path: null };
    }
    
    // Display registration screen
    function showScreen0() {
      loading.style.display = 'none';
      switchScreen(null, screen0);
      
      // Pre-fill if we have data
      if (userName) document.getElementById('name').value = userName;
      if (userEmail) document.getElementById('email').value = userEmail;
    }
    
    // Fetch the custom welcome back message from the database
    async function fetchWelcomeBackMessage() {
      try {
        // Try primary path
        let response = await fetch(`${DB_URL}/wedding/welcomeBackMessage.json`);
        
        // If primary failed, try backup path
        if (!response || !response.ok) {
          response = await fetch(`${DB_URL}/publicAnswers/wedding/welcomeBackMessage.json`);
        }
        
        if (response && response.ok) {
          const message = await response.json();
          if (message && typeof message === 'string') {
            return message;
          }
        }
        return null;
      } catch (error) {
        console.warn('Could not load welcome back message:', error);
        return null;
      }
    }
    
    // Display welcome back screen
    async function showWelcomeBack() {
      loading.style.display = 'none';
      
      // Refresh progress from database before showing welcome message
      await loadSolvedPuzzles();
      
      // Update current screen from database if available
      const result = await fetchUserProgressFromDatabase();
      if (result.data && result.data.currentScreen) {
        currentScreen = result.data.currentScreen;
        localStorage.setItem('weddingPuzzleScreen', currentScreen);
      }
      
      // Fetch custom welcome back message if available
      const customMessage = await fetchWelcomeBackMessage();
      if (customMessage) {
        // Replace {{name}} placeholder with actual user name
        welcomeBackMessage.innerHTML = customMessage.replace(/\{\{name\}\}/g, userName || 'there');
      } else {
        const solvedCount = solvedPuzzles.filter(Boolean).length;
        welcomeBackMessage.textContent = `Welcome back, ${userName}! You've solved ${solvedCount} puzzles and are currently on puzzle ${currentScreen} of ${totalPuzzles}.`;
      }
      
      switchScreen(null, screenWelcomeBack);
    }
    
    // Display puzzle screen
    async function loadPuzzle(puzzleNum) {
      try {
        const isInitialLoadOrScreenSwitch = 
          loading.style.display === 'block' || 
          !screenPuzzle.classList.contains('hidden') && 
            (screen0.classList.contains('hidden') && screenWelcomeBack.classList.contains('hidden') && screenComplete.classList.contains('hidden'));

        const puzzleNameEl = document.getElementById('puzzle-name');
        const clueContainerEl = document.getElementById('clue-container');
        const answerFormEl = document.getElementById('answer-form');

        // 1. Graceful Exit for Old Content (if any)
        if (!isInitialLoadOrScreenSwitch && !screenPuzzle.classList.contains('hidden')) {
          puzzleNameEl.classList.add('puzzle-content-exit-active');
          clueContainerEl.classList.add('puzzle-content-exit-active');
          answerFormEl.classList.add('puzzle-content-exit-active');
          await new Promise(resolve => setTimeout(resolve, 600)); // Wait for exit animation (0.6s)
        }

        // 2. Immediate Loading State
        loading.style.display = 'block';
        document.getElementById('success-display').classList.add('hidden');
        answerFormEl.style.display = 'block'; // Ensure form is ready for content

        // Hide other main screens if puzzle screen is being shown
        const currentlyVisibleScreen = 
          !screen0.classList.contains('hidden') ? screen0 :
          !screenWelcomeBack.classList.contains('hidden') ? screenWelcomeBack :
          !screenComplete.classList.contains('hidden') ? screenComplete : null;

        if (currentlyVisibleScreen && currentlyVisibleScreen !== screenPuzzle) {
          switchScreen(currentlyVisibleScreen, screenPuzzle);
          // switchScreen handles showing screenPuzzle, so we wait for its animation
          await new Promise(resolve => setTimeout(resolve, 800)); 
        } else if (screenPuzzle.classList.contains('hidden')) {
          // If screenPuzzle was hidden (e.g. initial load), make it visible without full switchScreen animation
          screenPuzzle.classList.remove('hidden');
        }
        
        puzzleError.classList.add('hidden');

        // Reset classes for entrance animation preparation
        puzzleNameEl.classList.remove('puzzle-content-exit-active', 'puzzle-content-enter-active');
        clueContainerEl.classList.remove('puzzle-content-exit-active', 'puzzle-content-enter-active');
        answerFormEl.classList.remove('puzzle-content-exit-active', 'puzzle-content-enter-active');
        puzzleNameEl.classList.add('puzzle-content-enter');
        clueContainerEl.classList.add('puzzle-content-enter');
        answerFormEl.classList.add('puzzle-content-enter');

        // 3. Data Fetching
        await loadSolvedPuzzles(); // Load solved status first
        
        console.log(`🎯 Loading puzzle ${puzzleNum} - State check:`, {
          solved: solvedPuzzles[puzzleNum],
          userAnswersForPuzzle: window.userCorrectAnswers ? window.userCorrectAnswers[puzzleNum] : undefined,
        });

        let puzzleResponse = null;
        try {
          puzzleResponse = await fetch(`${DB_URL}/wedding/answers/${puzzleNum}.json`);
        } catch (error) {
          console.error('Error with primary puzzle path:', error);
        }
        if (!puzzleResponse || !puzzleResponse.ok) {
          try {
            puzzleResponse = await fetch(`${DB_URL}/publicAnswers/wedding/${puzzleNum}.json`);
          } catch (error) {
            console.error('Error with backup puzzle path:', error);
          }
        }

        if (puzzleResponse && puzzleResponse.ok) {
          puzzleData = await puzzleResponse.json();
        } else {
          puzzleData = null; // Explicitly nullify if fetch failed
        }

        if (!puzzleData && puzzleNum > totalPuzzles) {
          console.log(`📊 No puzzle data for puzzle ${puzzleNum}, going to completion`);
          currentScreen = totalPuzzles + 1;
          localStorage.setItem('weddingPuzzleScreen', currentScreen);
          loading.style.display = 'none'; // Hide loader before calling showCompletion
          showCompletion();
          return;
        }

        if (!puzzleData) {
          puzzleData = {
            name: `Puzzle ${puzzleNum}`,
            clue: `Puzzle ${puzzleNum} - Unable to load data. Please try again later.`,
            clueHtml: '',
            imageUrls: [],
            answers: [{ text: "answer", questionText: "Your Answer:" }],
            wrongAnswerMessage: "That's not right. Try again!",
            partialCorrectMessage: "Some answers are wrong. Keep trying!"
          };
          puzzleError.classList.remove('hidden');
        }

        if (!puzzleData.answers) {
          puzzleData.answers = [{ text: puzzleData.answer || "answer", questionText: "Your Answer:" }];
          delete puzzleData.answer;
        }
        if (!puzzleData.wrongAnswerMessage) puzzleData.wrongAnswerMessage = "That's not right. Try again!";
        if (!puzzleData.partialCorrectMessage) puzzleData.partialCorrectMessage = "Some answers are wrong. Keep trying!";
        if (puzzleData.imageUrl && !puzzleData.imageUrls) {
          puzzleData.imageUrls = puzzleData.imageUrl ? [puzzleData.imageUrl] : [];
        }
        puzzleData.imageUrls = puzzleData.imageUrls || []; // Ensure imageUrls is always an array
        
        // Check if this is a crossword puzzle
        const isCrosswordPuzzle = puzzleData.crossword && puzzleData.crossword.enabled;
        
        if (isCrosswordPuzzle) {
          console.log(`🧩 Loading crossword puzzle ${puzzleNum}:`, puzzleData.crossword);
          
          // Handle crossword puzzle
          loading.style.display = 'none';
          await renderCrosswordPuzzle(puzzleNum, puzzleData);
          return; // Exit early for crossword puzzles
        }

        // 3.1 Image Preloading
        if (puzzleData.imageUrls.length > 0) {
          const imagePromises = puzzleData.imageUrls.map(url => {
            return new Promise((resolve, reject) => {
              if (!url || !url.trim()) {
                resolve(); // Resolve empty URLs immediately
                return;
              }
              const img = new Image();
              img.onload = resolve;
              img.onerror = () => {
                console.warn('Failed to load image:', url); 
                resolve(); // Resolve even on error to not block loading
              };
              img.src = url.trim();
            });
          });
          await Promise.all(imagePromises);
          console.log('🖼️ All puzzle images preloaded (or failed gracefully).');
        }

        // 4. Content Population (Behind Loader)
        puzzleNameEl.textContent = puzzleData.name || `Puzzle #${puzzleNum}`;
        const clueContentEl = document.getElementById('clue-content');
        if (puzzleData.clueHtml) {
          clueContentEl.innerHTML = puzzleData.clueHtml;
        } else {
          clueContentEl.textContent = puzzleData.clue || 'No clue provided';
        }

        const clueGalleryEl = document.getElementById('clue-gallery');
        clueGalleryEl.innerHTML = ''; // Clear previous images
        if (puzzleData.imageUrls.length > 0) {
          puzzleData.imageUrls.forEach(url => {
            if (url && url.trim()) {
              const imgEl = document.createElement('img');
              imgEl.src = url.trim();
              imgEl.alt = "Puzzle Clue";
              clueGalleryEl.appendChild(imgEl);
            }
          });
          clueGalleryEl.classList.remove('hidden');
        } else {
          clueGalleryEl.classList.add('hidden');
        }

        answersContainer.innerHTML = '';
        puzzleData.answers.forEach((answer, index) => {
          const multiAnswerDiv = document.createElement('div');
          multiAnswerDiv.className = 'multi-answer-container';
          multiAnswerDiv.id = `answer-container-${index}`;
          const formGroup = document.createElement('div');
          formGroup.className = 'form-group';
          const label = document.createElement('label');
          label.setAttribute('for', `answer-${index}`);
          label.textContent = answer.questionText || `Answer ${index + 1}:`;
          const input = document.createElement('input');
          input.type = 'text';
          input.id = `answer-${index}`;
          input.className = 'answer-input';
          input.required = true;
          formGroup.appendChild(label);
          formGroup.appendChild(input);
          multiAnswerDiv.appendChild(formGroup);
          answersContainer.appendChild(multiAnswerDiv);

          if (solvedPuzzles[puzzleNum]) {
            const userAnswers = window.userCorrectAnswers && window.userCorrectAnswers[puzzleNum];
            if (userAnswers && Array.isArray(userAnswers) && index < userAnswers.length && userAnswers[index] !== undefined && userAnswers[index] !== null && userAnswers[index] !== '') {
              input.value = userAnswers[index];
            } else {
              input.value = answer.text || '';
            }
            input.disabled = true;
            input.style.fontWeight = 'bold';
            input.style.color = '#2E7D32';
            input.style.backgroundColor = '#f1f8e9';
            multiAnswerDiv.classList.add('correct');
          }
        });

        const submitBtn = document.querySelector('#answer-form button[type="submit"]');
        const existingIndicator = puzzleNameEl.querySelector('.puzzle-solved-indicator');
        if (existingIndicator) existingIndicator.remove();

        if (solvedPuzzles[puzzleNum]) {
          submitBtn.disabled = true;
          submitBtn.textContent = 'Puzzle Solved ✓';
          const solvedIndicator = document.createElement('span');
          solvedIndicator.className = 'puzzle-solved-indicator';
          solvedIndicator.textContent = 'Solved ✓';
          puzzleNameEl.appendChild(solvedIndicator);
        } else {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Submit Answer';
        }

        wrongAttempts = 0;
        updateNavigation(puzzleNum);

        // 5. Smooth Entrance for New Content
        loading.style.display = 'none'; // Hide loader NOW

        puzzleNameEl.classList.remove('puzzle-content-enter');
        clueContainerEl.classList.remove('puzzle-content-enter');
        answerFormEl.classList.remove('puzzle-content-enter');

        puzzleNameEl.classList.add('puzzle-content-enter-active');
        clueContainerEl.classList.add('puzzle-content-enter-active');
        answerFormEl.classList.add('puzzle-content-enter-active');
        
        // 6. Focus and Cleanup
        setTimeout(() => {
          puzzleNameEl.classList.remove('puzzle-content-enter-active');
          clueContainerEl.classList.remove('puzzle-content-enter-active');
          answerFormEl.classList.remove('puzzle-content-enter-active');
        }, 800); // Duration of enter animation

        const firstAnswerInput = answersContainer.querySelector('.answer-input:not([disabled])');
        if (firstAnswerInput) {
          firstAnswerInput.value = ''; // Clear it before focusing
          setTimeout(() => firstAnswerInput.focus(), 100); // Short delay for animation
        }
        
        // Delayed pre-fill verification (if needed for debugging, otherwise can be removed)
        // setTimeout(async () => {
        //   console.log('🕐 Delayed pre-fill verification...');
        //   if (solvedPuzzles[puzzleNum]) {
        //     const answerInputs = document.querySelectorAll('.answer-input');
        //     const emptyInputs = Array.from(answerInputs).filter(input => !input.value && input.disabled);
        //     if (emptyInputs.length > 0) {
        //       console.warn('⚠️ Found empty disabled inputs in solved puzzle after load, forcing pre-fill again...');
        //       await window.forcePrefill(); // Ensure forcePrefill is robust
        //     } else {
        //       console.log('✅ All inputs properly filled after load.');
        //     }
        //   }
        // }, 1000);

      } catch (error) {
        console.error('Error loading puzzle:', error);
        loading.style.display = 'none';
        puzzleError.textContent = `Error loading puzzle: ${error.message}. Please refresh.`;
        puzzleError.classList.remove('hidden');
        // Optionally, show a generic error state within screenPuzzle if it's too broken
        document.getElementById('puzzle-name').textContent = `Puzzle ${puzzleNum}`;
        document.getElementById('clue-content').textContent = 'Could not load puzzle content.';
        document.getElementById('clue-gallery').classList.add('hidden');
        answersContainer.innerHTML = '<p>Could not load answer fields.</p>';
        updateNavigation(puzzleNum); // Still update nav so user isn't stuck
        if (screenPuzzle.classList.contains('hidden')) {
            switchScreen(null, screenPuzzle); // Show puzzle screen even on error
        }
      }
    }
    
    // Update navigation buttons and puzzle navigation based on current puzzle and progress
    function updateNavigation(puzzleNum) {
      // Previous button is always visible except on first puzzle
      prevPuzzleBtn.classList.toggle('hidden', puzzleNum <= 1);
      
      // Update puzzle navigation buttons
      const puzzleNav = document.getElementById('puzzle-nav');
      puzzleNav.innerHTML = '';
      
      // Show all unlocked puzzles: all solved puzzles + the next available one
      for (let i = 1; i <= totalPuzzles; i++) {
        const isSolved = solvedPuzzles[i];
        const isNextAvailable = i === 1 || solvedPuzzles[i - 1]; // First puzzle or previous is solved
        
        // Show puzzle if it's solved OR if it's the next available puzzle
        if (isSolved || isNextAvailable) {
          const navBtn = document.createElement('button');
          
          // Base classes
          navBtn.className = 'btn btn-nav';
          
          // Add status classes
          if (i === puzzleNum) {
            navBtn.classList.add('current-puzzle');
          } else if (isSolved) {
            navBtn.classList.add('solved-puzzle');
          }
          
          navBtn.textContent = `${i}`;
          navBtn.style.minWidth = '50px';
          navBtn.style.padding = '10px 8px';
          
          navBtn.addEventListener('click', async () => {
            if (i !== puzzleNum) {
              // Refresh state from database before navigating
              await loadSolvedPuzzles();
              
              // Re-verify this puzzle is still available after database refresh
              const stillSolved = solvedPuzzles[i];
              const stillNextAvailable = i === 1 || solvedPuzzles[i - 1];
              
              if (stillSolved || stillNextAvailable) {
                currentScreen = i;
                localStorage.setItem('weddingPuzzleScreen', currentScreen);
              loadPuzzle(i);
              } else {
                console.warn(`Puzzle ${i} is no longer available`);
                showFeedback(`Puzzle ${i} is not available yet. Complete the previous puzzles first.`, 'error');
              }
            }
          });
          
          puzzleNav.appendChild(navBtn);
        }
      }
      
      console.log('Navigation updated:', {
        totalPuzzles,
        solvedPuzzles,
        currentPuzzle: puzzleNum,
        buttonsShown: puzzleNav.children.length
      });
    }
    
    // Fetch ending page content from database
    async function fetchEndingPageContent() {
      try {
        const paths = [
          `wedding/endingPageContent`,
          `publicAnswers/wedding/endingPageContent`
        ];
        
        for (const path of paths) {
          try {
            const response = await fetch(`${DB_URL}/${path}.json`);
            if (response.ok) {
              const data = await response.json();
              if (data && typeof data === 'string') {
                return data;
              }
            }
          } catch (error) {
            console.error(`Error fetching ending page content from ${path}:`, error);
          }
        }
        
        // Return default content if nothing found
        return '<h2>Congratulations!</h2><p>You\'ve completed all the puzzles!</p>';
      } catch (error) {
        console.warn('Could not load ending page content:', error);
        return '<h2>Congratulations!</h2><p>You\'ve completed all the puzzles!</p>';
      }
    }
    
    // Display completion screen
    async function showCompletion() {
      loading.style.display = 'none';
      
      const currentlyVisibleScreen = 
        !screen0.classList.contains('hidden') ? screen0 :
        !screenWelcomeBack.classList.contains('hidden') ? screenWelcomeBack :
        !screenPuzzle.classList.contains('hidden') ? screenPuzzle : null;
      
      // Load custom ending page content
      const endingContent = await fetchEndingPageContent();
      endingPageContent.innerHTML = endingContent;
      
      switchScreen(currentlyVisibleScreen, screenComplete);
      
      // Trigger confetti
      startConfetti();
    }
    
    // Registration form submission - completely rebuilt without any Firebase Auth
    infoForm.addEventListener('submit', function(e) {
      e.preventDefault();
      
      // Get user info
      userName = document.getElementById('name').value.trim();
      userEmail = document.getElementById('email').value.trim();
      
      if (!userName || !userEmail) {
        alert('Please enter both name and email.');
        return;
      }
      
      // Show loading
      loading.style.display = 'block';
      screen0.classList.add('hidden');
      registrationError.classList.add('hidden');
      
      // Generate unique ID locally (no Firebase auth)
      userId = 'anon_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('weddingPuzzleId', userId);
      
      // Set initial progress
      currentScreen = 1;
      
      // Save to localStorage first (most important)
      localStorage.setItem('weddingPuzzleName', userName);
      localStorage.setItem('weddingPuzzleEmail', userEmail);
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      
      // Initialize solved puzzles array
      solvedPuzzles = Array(totalPuzzles + 1).fill(false);
      
      // Initialize user correct answers
      window.userCorrectAnswers = {};
      
      // Debug function to reset progress (can be called from browser console)
      window.resetPuzzleProgress = function() {
        // Clear all local storage
        localStorage.removeItem('weddingPuzzleName');
        localStorage.removeItem('weddingPuzzleEmail');
        localStorage.removeItem('weddingPuzzleScreen');
        localStorage.removeItem('weddingPuzzleLocalProgress');
        localStorage.removeItem('weddingPuzzleLocalAttempts');
        localStorage.removeItem('weddingPuzzleId');
        localStorage.removeItem('weddingPuzzleSuccessPath');
        
        // Reset in-memory state
        solvedPuzzles = Array(totalPuzzles + 1).fill(false);
        window.userCorrectAnswers = {};
        
        // Clear database if possible
        if (userId && successPath) {
          fetch(`${DB_URL}/${successPath}/${userId}.json`, {
            method: 'DELETE'
          }).then(() => {
            console.log('Database progress cleared');
          }).catch(err => {
            console.warn('Could not clear database:', err);
          });
        }
        
        console.log('Puzzle progress reset completely. Refresh the page to start over.');
      };
      
      // Debug function to view current progress
      window.viewProgress = async function() {
        await loadSolvedPuzzles();
        console.log('📊 Current progress:', {
          currentScreen,
          solvedPuzzles,
          userCorrectAnswers: window.userCorrectAnswers,
          userId,
          successPath
        });
        
        // Show detailed breakdown of each puzzle
        for (let i = 1; i <= totalPuzzles; i++) {
          console.log(`Puzzle ${i}:`, {
            solved: solvedPuzzles[i],
            userAnswers: window.userCorrectAnswers[i],
            answersType: Array.isArray(window.userCorrectAnswers[i]) ? 'array' : typeof window.userCorrectAnswers[i]
          });
        }
      };
      
      // Debug function to inspect specific puzzle
      window.inspectPuzzle = function(puzzleNum) {
        console.log(`🔍 Inspecting Puzzle ${puzzleNum}:`, {
          solved: solvedPuzzles[puzzleNum],
          userAnswers: window.userCorrectAnswers[puzzleNum],
          localStorage: JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}')
        });
      };
      
      // Debug function to unlock a specific puzzle (can be called from browser console)
      window.unlockPuzzle = function(puzzleNum) {
        if (puzzleNum > 1) {
          // Mark previous puzzle as solved to unlock this one
          solvedPuzzles[puzzleNum - 1] = true;
          const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
          localProgress.solved = solvedPuzzles;
          localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
          console.log(`Unlocked puzzle ${puzzleNum} by marking puzzle ${puzzleNum - 1} as solved`);
          location.reload();
        }
      };
      
      // Debug function to mark a puzzle as unsolved
      window.unsolveCurrentPuzzle = function() {
        solvedPuzzles[currentScreen] = false;
        if (window.userCorrectAnswers) {
          delete window.userCorrectAnswers[currentScreen];
        }
        const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
        localProgress.solved = solvedPuzzles;
        localProgress.userAnswers = window.userCorrectAnswers;
        localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
        console.log(`Marked puzzle ${currentScreen} as unsolved`);
        location.reload();
      };
      
      // Prepare progress data
      const progressData = {
        name: userName,
        email: userEmail,
        currentScreen: currentScreen,
        solved: solvedPuzzles,
        userAnswers: {},
        timestamp: new Date().toISOString()
      };
      
      // Store locally regardless of what happens with remote saves
      localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(progressData));
      
      // Try saving to primary DB path first, then fallback
      const attemptSave = async () => {
        try {
          // Try primary path
          const primaryResponse = await fetch(`${DB_URL}/wedding/progress/${userId}.json`, {
        method: 'PUT',
        body: JSON.stringify(progressData)
          });
          
          if (primaryResponse.ok) {
          localStorage.setItem('weddingPuzzleSuccessPath', 'wedding/progress');
            successPath = 'wedding/progress';
            console.log('Successfully saved to primary database path');
          return true;
        }
          
          // Try fallback path
          const fallbackResponse = await fetch(`${DB_URL}/publicAnswers/wedding/progress/${userId}.json`, {
          method: 'PUT',
          body: JSON.stringify(progressData)
        });
          
          if (fallbackResponse.ok) {
          localStorage.setItem('weddingPuzzleSuccessPath', 'publicAnswers/wedding/progress');
            successPath = 'publicAnswers/wedding/progress';
            console.log('Successfully saved to fallback database path');
            return true;
          }
          
          return false;
        } catch (error) {
        console.warn('Error saving progress to database:', error);
          return false;
        }
      };
      
      // Attempt save and then load first puzzle
      attemptSave().then((saveSuccessful) => {
        if (saveSuccessful) {
          console.log('User registration saved to database successfully');
        } else {
          console.warn('Could not save to database, continuing with localStorage only');
        }
        
        // Load first puzzle regardless of database save outcome
        loadPuzzle(currentScreen);
      });
    });
    
    // Welcome back buttons
    continueBtn.addEventListener('click', async function() {
      await loadSolvedPuzzles();
      loadPuzzle(currentScreen);
    });
    
    restartFromBeginningBtn.addEventListener('click', async function() {
      await loadSolvedPuzzles();
      currentScreen = 1;
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      loadPuzzle(currentScreen);
    });
    
    // Navigation buttons
    if (prevPuzzleBtn) {
      prevPuzzleBtn.addEventListener('click', function() {
        if (currentScreen > 1) {
          currentScreen--;
          localStorage.setItem('weddingPuzzleScreen', currentScreen);
          loadPuzzle(currentScreen);
        }
      });
    }
    
    if (nextPuzzleBtn) {
      nextPuzzleBtn.addEventListener('click', function() {
        if (currentScreen < totalPuzzles && solvedPuzzles[currentScreen]) {
          currentScreen++;
          localStorage.setItem('weddingPuzzleScreen', currentScreen);
          loadPuzzle(currentScreen);
        }
      });
    }
    
    // Show a feedback message
    function showFeedback(message, type) {
      const feedbackEl = document.getElementById('feedback-message');
      feedbackEl.textContent = message;
      feedbackEl.className = 'feedback-message ' + type;
      
      // Show the message
      setTimeout(() => {
        feedbackEl.classList.add('show');
        
        // Hide after 3 seconds
        setTimeout(() => {
          feedbackEl.classList.remove('show');
        }, 3000);
      }, 10);
    }
    
    // Show a success message and transition to the next screen after a delay
    function showSuccessAndTransition(message, nextFunction) {
      // Hide the answer form
      document.getElementById('answer-form').style.display = 'none';
      
      // Show success display
      const successDisplay = document.getElementById('success-display');
      const successMessage = document.getElementById('success-message');
      successMessage.textContent = message || 'Great job! Moving to the next puzzle...';
      successDisplay.classList.remove('hidden');
      
      // Show the checkmark with animation
      const checkmark = document.querySelector('.success-checkmark');
      if (checkmark) {
      checkmark.style.display = 'block';
        checkmark.classList.add('show');
        
        // Reset any previous animations
        setTimeout(() => {
          checkmark.style.animation = 'none';
          checkmark.offsetHeight; // Trigger reflow
          checkmark.style.animation = 'checkmarkBounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
        }, 50);
      }
      
      // Transition after delay
      setTimeout(() => {
        if (typeof nextFunction === 'function') {
          nextFunction();
        }
      }, 2000);
    }
    
    // Function to normalize answers for flexible matching
    function normalizeAnswer(answer) {
      if (!answer) return '';
      return answer.toLowerCase().replace(/\s+/g, '');
    }
    
    // Function to check if an answer matches any acceptable variations
    function isAnswerCorrect(userAnswer, expectedAnswer, alternateSpellings = []) {
      const normalizedUser = normalizeAnswer(userAnswer);
      
      // Check main answer
      if (normalizedUser === normalizeAnswer(expectedAnswer)) {
        return true;
      }
      
      // Check alternate spellings if provided
      if (alternateSpellings && Array.isArray(alternateSpellings)) {
        for (const alternate of alternateSpellings) {
          if (normalizedUser === normalizeAnswer(alternate)) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    // Answer submission
    answerForm.addEventListener('submit', async (e) => {
      e.preventDefault(); // Prevent the default form submission
      
      // Check if this puzzle is already solved - prevent re-submission
      if (solvedPuzzles[currentScreen]) {
        console.log('Puzzle', currentScreen, 'marked as solved:', solvedPuzzles);
        console.log('User correct answers:', window.userCorrectAnswers);
        showFeedback('This puzzle is already solved!', 'info');
        return;
      }
      
      // Collect all answers
      const answerInputs = document.querySelectorAll('.answer-input');
      const answers = Array.from(answerInputs).map(input => input.value.trim());
      
      if (answers.some(a => !a)) {
        showFeedback('Please fill in all answer fields.', 'error');
        return;
      }
      
      try {
        // Check if all answers are correct
        let allCorrect = true;
        let correctAnswers = 0;
        
        // For each answer, check if it matches
        answers.forEach((answer, index) => {
          const expectedAnswer = puzzleData.answers[index]?.text || '';
          const alternateSpellings = puzzleData.answers[index]?.alternateSpellings || [];
          const isCorrect = isAnswerCorrect(answer, expectedAnswer, alternateSpellings);
          
          // Mark the answer container as correct if it's right
          const answerContainer = document.getElementById(`answer-container-${index}`);
          if (answerContainer) {
            if (isCorrect) {
              answerContainer.classList.add('correct');
              answerContainer.classList.remove('incorrect');
              correctAnswers++;
            } else {
              answerContainer.classList.remove('correct');
              answerContainer.classList.add('incorrect');
              allCorrect = false;
            }
          }
        });
        
        // Track attempt in localStorage first
        const attemptData = {
          answers: answers,
          correct: allCorrect,
          timestamp: new Date().toISOString()
        };
        
        // Always store locally first
        const localAttempts = JSON.parse(localStorage.getItem('weddingPuzzleLocalAttempts') || '{}');
        if (!localAttempts[currentScreen]) localAttempts[currentScreen] = [];
        localAttempts[currentScreen].push(attemptData);
        localStorage.setItem('weddingPuzzleLocalAttempts', JSON.stringify(localAttempts));
        
        // Try to save attempt to database (non-blocking)
        const successPath = localStorage.getItem('weddingPuzzleSuccessPath');
        if (successPath === 'wedding/progress') {
          fetch(`${DB_URL}/wedding/attempts/${currentScreen}/${userId}.json`, {
            method: 'POST',
            body: JSON.stringify(attemptData)
          }).catch(err => console.warn('Could not save attempt to primary path:', err));
        } else if (successPath === 'publicAnswers/wedding/progress') {
          fetch(`${DB_URL}/publicAnswers/wedding/attempts/${currentScreen}/${userId}.json`, {
            method: 'POST',
            body: JSON.stringify(attemptData)
          }).catch(err => console.warn('Could not save attempt to fallback path:', err));
        }
        
        if (allCorrect) {
          // Mark current puzzle as solved
          solvedPuzzles[currentScreen] = true;
          
          // Store user's correct answers for pre-filling later
          if (!window.userCorrectAnswers) {
            window.userCorrectAnswers = {};
          }
          window.userCorrectAnswers[currentScreen] = [...answers]; // Create a copy of the answers array
          console.log(`✓ Storing user answers for puzzle ${currentScreen}:`, window.userCorrectAnswers[currentScreen]);
          
          // Determine what the next puzzle should be
          const justSolvedPuzzle = currentScreen;
          const nextPuzzle = currentScreen < totalPuzzles ? currentScreen + 1 : null;
          
          // Check if we just solved the last puzzle
          const isLastPuzzleSolved = justSolvedPuzzle === totalPuzzles;
          
          console.log(`📊 Completion check:`, {
            justSolvedPuzzle,
            totalPuzzles,
            nextPuzzle,
            isLastPuzzleSolved
          });
          
          // Update current screen to next puzzle if there is one, otherwise go to completion
          if (isLastPuzzleSolved) {
            currentScreen = totalPuzzles + 1; // Set to completion screen
            localStorage.setItem('weddingPuzzleScreen', currentScreen);
          } else if (nextPuzzle) {
            currentScreen = nextPuzzle;
            localStorage.setItem('weddingPuzzleScreen', currentScreen);
          }
          
          // Update solved status and user answers in localStorage immediately
          const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
          localProgress.solved = [...solvedPuzzles]; // Create a copy
          localProgress.userAnswers = { ...window.userCorrectAnswers }; // Create a copy
          localProgress.currentScreen = currentScreen;
          localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
          console.log('✓ Updated localStorage with:', localProgress);
          
          // Try to update Firebase using the known successful path
          const updateData = {
            currentScreen: currentScreen,
            solved: [...solvedPuzzles], // Create a copy
            userAnswers: { ...window.userCorrectAnswers }, // Create a copy
            name: userName,
            email: userEmail,
            timestamp: new Date().toISOString()
          };
          
          console.log('📤 Saving to database:', updateData);
          
          // Save to database immediately and wait for confirmation
          const savePromise = new Promise((resolve) => {
          if (successPath === 'wedding/progress') {
            fetch(`${DB_URL}/wedding/progress/${userId}.json`, {
                method: 'PUT',
              body: JSON.stringify(updateData)
              }).then(response => {
                if (response.ok) {
                  console.log('Progress saved to database successfully');
                }
                resolve();
              }).catch(err => {
                console.warn('Could not update progress in primary path:', err);
                resolve();
              });
          } else if (successPath === 'publicAnswers/wedding/progress') {
            fetch(`${DB_URL}/publicAnswers/wedding/progress/${userId}.json`, {
                method: 'PUT',
              body: JSON.stringify(updateData)
              }).then(response => {
                if (response.ok) {
                  console.log('Progress saved to database successfully');
                }
                resolve();
              }).catch(err => {
                console.warn('Could not update progress in fallback path:', err);
                resolve();
              });
            } else {
              resolve();
            }
          });
          
          // Check if all puzzles completed
          const allPuzzlesSolved = solvedPuzzles.slice(1, totalPuzzles + 1).every(Boolean);
          
          if (isLastPuzzleSolved || allPuzzlesSolved) {
            // All puzzles completed - show completion
            showSuccessAndTransition(customSuccessMessages.allComplete, () => {
              savePromise.then(() => {
                showCompletion();
              });
            });
          } else if (nextPuzzle) {
            // Show success message and automatically move to next puzzle
            const message = customSuccessMessages.puzzleSolved.replace('{nextPuzzle}', nextPuzzle);
            showSuccessAndTransition(message, () => {
              // Wait for database save then load next puzzle
              savePromise.then(() => {
              loadPuzzle(nextPuzzle);
              });
            });
          } else {
            // Fallback case (shouldn't happen with current logic)
            showSuccessAndTransition(customSuccessMessages.lastPuzzle, () => {
              // Reset the success display
              document.getElementById('success-display').classList.add('hidden');
              document.getElementById('answer-form').style.display = 'block';
              const checkmark = document.querySelector('.success-checkmark');
              if (checkmark) {
                checkmark.style.display = 'none';
                checkmark.classList.remove('show');
              }
            });
          }
          
        } else {
          // Wrong answer
          wrongAttempts++;
          
          // Shake the card
          card.classList.add('card-shake');
          setTimeout(() => {
            card.classList.remove('card-shake');
          }, 500);
          
          // Show error feedback
          if (correctAnswers > 0) {
            showFeedback(puzzleData.partialCorrectMessage || "Some answers are wrong. Keep trying!", 'error');
          } else {
            showFeedback(puzzleData.wrongAnswerMessage || "That's not right. Try again!", 'error');
          }
          
          // Show hint after 3 wrong attempts
          if (wrongAttempts >= 3) {
            hintToast.classList.add('show');
            setTimeout(() => {
              hintToast.classList.remove('show');
            }, 5000);
          }
          
          // If some answers are correct, keep them highlighted
          if (correctAnswers > 0) {
            // Focus the first incorrect answer
            for (let i = 0; i < answerInputs.length; i++) {
              if (answers[i].toLowerCase() !== (puzzleData.answers[i]?.text || '').toLowerCase()) {
                answerInputs[i].focus();
                break;
              }
            }
          } else {
            // Clear all answer fields if none are correct
            answerInputs[0].focus();
          }
        }
        
      } catch (error) {
        console.error('Error processing answer:', error);
        showFeedback('There was a problem processing your answer. Please try again.', 'error');
      }
    });
    
    // Restart button
    restartBtn.addEventListener('click', () => {
      currentScreen = 1;
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      loadPuzzle(currentScreen);
    });
    
    // Confetti effect on completion
    function startConfetti() {
      const canvas = document.getElementById('confetti-canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      const pieces = [];
      const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', 
                     '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50',
                     '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', 
                     '#FFD700', '#FFA500', '#FF6347', '#FF4500', '#FF1493'];
      
      class Piece {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * -100;
          this.rotation = Math.random() * 360;
          this.size = Math.random() * 25 + 5; // Bigger pieces
          this.weight = Math.random() * 1 + 0.5; // Varied weights for natural movement
          this.speed = Math.random() * 6 + 2; // Faster movement
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.shape = Math.random() > 0.5 ? 'circle' : 'rect';
          this.opacity = Math.random() * 0.5 + 0.5; // Varied opacity
          this.rotationSpeed = (Math.random() - 0.5) * 5; // Some rotate clockwise, some counter-clockwise
        }
        
        update() {
          this.y += this.speed;
          this.x += Math.sin(this.y * this.weight * 0.01) * 2; // Wavy horizontal movement
          this.rotation += this.rotationSpeed;
          
          if (this.y > canvas.height) {
            this.y = Math.random() * -100;
            this.x = Math.random() * canvas.width;
          }
        }
        
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation * Math.PI / 180);
          ctx.globalAlpha = this.opacity;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          
          if (this.shape === 'circle') {
            ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
          } else {
            ctx.rect(-this.size / 2, -this.size / 2, this.size, this.size);
          }
          
          ctx.fill();
          ctx.restore();
        }
      }
      
      // Create more pieces
      for (let i = 0; i < 250; i++) {
        pieces.push(new Piece());
      }
      
      // Animation loop
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        pieces.forEach(piece => {
          piece.update();
          piece.draw();
        });
        
        requestAnimationFrame(animate);
      }
      
      animate();
    }
    
    // Debug function to manually force pre-filling for current puzzle
    window.forcePrefill = async function() {
      console.log('🔄 Forcing pre-fill check...');
      await loadSolvedPuzzles();
      
      const puzzleNum = currentScreen;
      const puzzleIsSolved = solvedPuzzles[puzzleNum];
      const userAnswers = window.userCorrectAnswers[puzzleNum];
      
      console.log(`🔄 Force pre-fill for puzzle ${puzzleNum}:`, {
        puzzleIsSolved,
        userAnswers,
        currentScreen,
        allSolvedPuzzles: solvedPuzzles,
        allUserAnswers: window.userCorrectAnswers
      });
      
      if (puzzleIsSolved && userAnswers && Array.isArray(userAnswers)) {
        const answerInputs = document.querySelectorAll('.answer-input');
        console.log(`🔄 Found ${answerInputs.length} answer inputs to fill`);
        
        answerInputs.forEach((input, index) => {
          if (index < userAnswers.length && userAnswers[index]) {
            input.value = userAnswers[index];
            input.disabled = true;
            input.style.fontWeight = 'bold';
            input.style.color = '#2E7D32';
            input.style.backgroundColor = '#f1f8e9';
            
            const container = input.closest('.multi-answer-container');
            if (container) {
              container.classList.add('correct');
            }
            
            console.log(`🔄 Force filled answer ${index}: "${userAnswers[index]}"`);
          }
        });
        
        // Also update submit button
        const submitBtn = document.querySelector('#answer-form button[type="submit"]');
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.textContent = 'PUZZLE SOLVED ✓';
        }
      } else {
        console.log('🔄 Cannot force pre-fill - puzzle not solved or no user answers');
      }
    };
    
    // Debug function to check what puzzle data exists in database
    window.checkDatabasePuzzles = async function() {
      console.log('🔍 Checking database for puzzle data...');
      
      const paths = [
        'wedding/answers',
        'publicAnswers/wedding'
      ];
      
      for (const path of paths) {
        try {
          const response = await fetch(`${DB_URL}/${path}.json`);
          if (response.ok) {
            const data = await response.json();
            console.log(`📊 Data from ${path}:`, data);
            
            if (data) {
              const puzzleNumbers = Object.keys(data).filter(key => !isNaN(parseInt(key))).map(Number).sort((a, b) => a - b);
              console.log(`📊 Found puzzles: ${puzzleNumbers.join(', ')}`);
              
              // Check specifically for puzzle 11
              if (data['11']) {
                console.warn('⚠️ Found puzzle 11 data:', data['11']);
              }
            }
          }
        } catch (error) {
          console.error(`❌ Error checking ${path}:`, error);
        }
      }
      
      // Also check totalPuzzles
      for (const basePath of ['wedding', 'publicAnswers/wedding']) {
        try {
          const response = await fetch(`${DB_URL}/${basePath}/totalPuzzles.json`);
          if (response.ok) {
            const count = await response.json();
            console.log(`📊 totalPuzzles from ${basePath}: ${count}`);
          }
        } catch (error) {
          console.log(`📊 No totalPuzzles found in ${basePath}`);
        }
      }
    };
    
    // Debug function to clean up puzzle 11
    window.cleanupPuzzle11 = async function() {
      console.log('🧹 Cleaning up puzzle 11 data...');
      
      const paths = [
        'wedding/answers/11',
        'publicAnswers/wedding/11'
      ];
      
      for (const path of paths) {
        try {
          const response = await fetch(`${DB_URL}/${path}.json`, {
            method: 'DELETE'
          });
          if (response.ok) {
            console.log(`✅ Deleted ${path}`);
          } else {
            console.log(`ℹ️ ${path} might not exist`);
          }
        } catch (error) {
          console.error(`❌ Error deleting ${path}:`, error);
        }
      }
      
      // Set totalPuzzles to 10
      for (const basePath of ['wedding', 'publicAnswers/wedding']) {
        try {
          const response = await fetch(`${DB_URL}/${basePath}/totalPuzzles.json`, {
            method: 'PUT',
            body: JSON.stringify(10)
          });
          if (response.ok) {
            console.log(`✅ Set totalPuzzles to 10 in ${basePath}`);
          }
        } catch (error) {
          console.error(`❌ Error setting totalPuzzles in ${basePath}:`, error);
        }
      }
      
      console.log('🧹 Cleanup complete! Refresh the page to test.');
    };
    
    // Render crossword puzzle
    async function renderCrosswordPuzzle(puzzleNum, puzzleData) {
      try {
        const puzzleNameEl = document.getElementById('puzzle-name');
        const clueContainerEl = document.getElementById('clue-container');
        const answerFormEl = document.getElementById('answer-form');
        
        const crosswordConfig = puzzleData.crossword;
        
        // Set puzzle name
        puzzleNameEl.textContent = crosswordConfig.title || puzzleData.name || `Crossword Puzzle #${puzzleNum}`;
        
        // Clear standard puzzle content
        clueContainerEl.innerHTML = '';
        answerFormEl.style.display = 'none';
        
        // Create crossword container
        const crosswordContainer = document.createElement('div');
        crosswordContainer.className = 'crossword-container';
        crosswordContainer.innerHTML = `
          <div class="crossword-instructions">
            🧩 <strong>Crossword Puzzle:</strong> Complete the crossword below. All answers relate to the puzzle theme!
            <br><em>Note: You cannot check or reveal answers - solve it the traditional way!</em>
          </div>
          <div class="crossword-progress" id="crossword-progress-${puzzleNum}">
            Loading crossword puzzle...
          </div>
          <div id="crossword-solver-${puzzleNum}" style="min-height: 400px; background: #f9f9f9; border-radius: 8px; padding: 20px;">
            <div style="text-align: center; padding: 40px; color: #666;">
              <div>🧩 Loading crossword...</div>
              <div style="margin-top: 10px; font-size: 14px;">CFP File: ${crosswordConfig.fileUrl ? crosswordConfig.fileUrl.split('/').pop() : 'Not specified'}</div>
            </div>
          </div>
        `;
        
        // Add completion form if needed
        if (crosswordConfig.completionTrigger === 'manual') {
          const completionForm = document.createElement('div');
          completionForm.className = 'crossword-completion-form';
          completionForm.id = `crossword-completion-${puzzleNum}`;
          completionForm.innerHTML = `
            <h4>🎯 Ready to Submit?</h4>
            <p>When you've completed the crossword (or as much as you can), click submit to continue.</p>
            <button type="button" class="btn" onclick="submitCrosswordCompletion(${puzzleNum})">Submit Crossword</button>
          `;
          crosswordContainer.appendChild(completionForm);
        }
        
        clueContainerEl.appendChild(crosswordContainer);
        
        // Load the actual crossword
        if (crosswordConfig.fileUrl) {
          await loadCrosswordFile(puzzleNum, crosswordConfig.fileUrl, crosswordConfig);
        } else {
          // Show error if no file URL
          document.getElementById(`crossword-solver-${puzzleNum}`).innerHTML = `
            <div style="text-align: center; padding: 40px; color: #e53935;">
              <h4>❌ Crossword Configuration Error</h4>
              <p>No crossword file specified. Please contact the puzzle administrator.</p>
            </div>
          `;
        }
        
        // Setup completion detection based on trigger type
        if (crosswordConfig.completionTrigger === 'fully-solved') {
          setupCrosswordCompletionDetection(puzzleNum, crosswordConfig);
        } else if (crosswordConfig.completionTrigger === 'percentage') {
          setupCrosswordPercentageDetection(puzzleNum, crosswordConfig);
        }
        
        // Update navigation
        updateNavigation(puzzleNum);
        
        // Apply solved state if already completed
        applyCrosswordSolvedState(puzzleNum);
        
        // Smooth entrance animation
        const puzzleNameEl2 = document.getElementById('puzzle-name');
        const clueContainerEl2 = document.getElementById('clue-container');
        
        puzzleNameEl2.classList.remove('puzzle-content-enter');
        clueContainerEl2.classList.remove('puzzle-content-enter');
        puzzleNameEl2.classList.add('puzzle-content-enter-active');
        clueContainerEl2.classList.add('puzzle-content-enter-active');
        
        setTimeout(() => {
          puzzleNameEl2.classList.remove('puzzle-content-enter-active');
          clueContainerEl2.classList.remove('puzzle-content-enter-active');
        }, 800);
        
      } catch (error) {
        console.error('Error rendering crossword puzzle:', error);
        showFeedback('Error loading crossword puzzle. Please try again.', 'error');
      }
    }
    
    // Load crossword file
    async function loadCrosswordFile(puzzleNum, fileUrl, crosswordConfig) {
      try {
        const progressEl = document.getElementById(`crossword-progress-${puzzleNum}`);
        const solverEl = document.getElementById(`crossword-solver-${puzzleNum}`);
        
        progressEl.textContent = 'Loading crossword file...';
        
        // Fetch the crossword file
        const response = await fetch(fileUrl);
        if (!response.ok) {
          throw new Error(`Failed to load crossword file: ${response.status}`);
        }
        
        const fileContent = await response.text();
        progressEl.textContent = 'Parsing crossword data...';
        
        // For demo purposes, show a placeholder since the full crossword integration
        // would require more complex parsing of CFP files
        setTimeout(() => {
          solverEl.innerHTML = `
            <div style="text-align: center; padding: 40px; border: 2px dashed #ccc; border-radius: 8px; background: white;">
              <h4 style="margin: 0 0 15px 0; color: #333;">🧩 Interactive Crossword</h4>
              <p style="margin: 0 0 10px 0; color: #666;">Crossword puzzle would render here</p>
              <div style="font-size: 14px; color: #999; margin: 15px 0;">
                <div><strong>File:</strong> ${fileUrl.split('/').pop()}</div>
                <div><strong>Trigger:</strong> ${crosswordConfig.completionTrigger}</div>
                ${crosswordConfig.completionPercentage ? `<div><strong>Threshold:</strong> ${crosswordConfig.completionPercentage}%</div>` : ''}
              </div>
              <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 1px solid #ddd;">
                <div style="font-size: 12px; color: #333; font-weight: 500;">✓ Cheat Protection Active:</div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                  No reveal buttons • No answer checking • Traditional solving only
                </div>
              </div>
              <button type="button" class="btn" style="margin-top: 15px;" onclick="simulateCrosswordCompletion(${puzzleNum})">
                🎯 Simulate Completion (Demo)
              </button>
            </div>
          `;
          
          progressEl.textContent = '🧩 Crossword ready! Start solving...';
          
          // Remove cheat buttons aggressively
          setTimeout(() => removeCrosswordCheatButtons(), 500);
          
        }, 1000);
        
      } catch (error) {
        console.error('Error loading crossword file:', error);
        const solverEl = document.getElementById(`crossword-solver-${puzzleNum}`);
        solverEl.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #e53935;">
            <h4>❌ Error Loading Crossword</h4>
            <p>Could not load the crossword file: ${fileUrl}</p>
            <p style="font-size: 14px; color: #666;">Please check the file URL and try again.</p>
          </div>
        `;
      }
    }
    
    // Remove cheat buttons from crossword solver
    function removeCrosswordCheatButtons() {
      const cheatingSelectors = [
        '.check-word-btn', '.check-puzzle-btn', '.reveal-letter-btn', 
        '.reveal-word-btn', '.reveal-puzzle-btn', '.reveal-button',
        '.check-button', 'button[onclick*="reveal"]', 'button[onclick*="check"]',
        'input[value*="Reveal"]', 'input[value*="Check"]', '.reveal', '.check',
        '.cw-check', '.cw-reveal'
      ];
      
      cheatingSelectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(el => {
          el.style.display = 'none';
          el.style.visibility = 'hidden';
          el.remove();
        });
      });
    }
    
    // Setup crossword completion detection
    function setupCrosswordCompletionDetection(puzzleNum, crosswordConfig) {
      // This would integrate with the actual crossword solver library
      // For now, we'll simulate it
      console.log(`Setting up completion detection for puzzle ${puzzleNum}`);
    }
    
    // Setup crossword percentage-based completion detection
    function setupCrosswordPercentageDetection(puzzleNum, crosswordConfig) {
      console.log(`Setting up percentage detection for puzzle ${puzzleNum}: ${crosswordConfig.completionPercentage}%`);
    }
    
    // Apply solved state to crossword
    function applyCrosswordSolvedState(puzzleNum) {
      if (solvedPuzzles[puzzleNum]) {
        const progressEl = document.getElementById(`crossword-progress-${puzzleNum}`);
        if (progressEl) {
          progressEl.innerHTML = '✅ <strong>Crossword Completed!</strong> Excellent work!';
          progressEl.style.background = '#e8f5e8';
          progressEl.style.color = '#2e7d32';
        }
        
        // Add solved indicator to puzzle name
        const puzzleNameEl = document.getElementById('puzzle-name');
        const existingIndicator = puzzleNameEl.querySelector('.puzzle-solved-indicator');
        if (!existingIndicator) {
          const solvedIndicator = document.createElement('span');
          solvedIndicator.className = 'puzzle-solved-indicator';
          solvedIndicator.textContent = 'Solved ✓';
          puzzleNameEl.appendChild(solvedIndicator);
        }
      }
    }
    
    // Manual crossword completion submission
    window.submitCrosswordCompletion = function(puzzleNum) {
      completeCrosswordPuzzle(puzzleNum);
    };
    
    // Simulate crossword completion (for demo)
    window.simulateCrosswordCompletion = function(puzzleNum) {
      completeCrosswordPuzzle(puzzleNum);
    };
    
    // Complete crossword puzzle
    async function completeCrosswordPuzzle(puzzleNum) {
      try {
        // Mark puzzle as solved
        solvedPuzzles[puzzleNum] = true;
        
        // Store completion (no specific answers for crosswords)
        if (!window.userCorrectAnswers) {
          window.userCorrectAnswers = {};
        }
        window.userCorrectAnswers[puzzleNum] = ['CROSSWORD_COMPLETED'];
        
        // Update localStorage
        const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
        localProgress.solved = [...solvedPuzzles];
        localProgress.userAnswers = { ...window.userCorrectAnswers };
        
        // Determine next puzzle
        const nextPuzzle = puzzleNum < totalPuzzles ? puzzleNum + 1 : null;
        const isLastPuzzle = puzzleNum === totalPuzzles;
        
        if (isLastPuzzle) {
          currentScreen = totalPuzzles + 1;
          localProgress.currentScreen = currentScreen;
        } else if (nextPuzzle) {
          currentScreen = nextPuzzle;
          localProgress.currentScreen = currentScreen;
        }
        
        localStorage.setItem('weddingPuzzleScreen', currentScreen);
        localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
        
        // Save to database if possible
        const successPath = localStorage.getItem('weddingPuzzleSuccessPath');
        const updateData = {
          currentScreen: currentScreen,
          solved: [...solvedPuzzles],
          userAnswers: { ...window.userCorrectAnswers },
          name: userName,
          email: userEmail,
          timestamp: new Date().toISOString()
        };
        
        if (successPath && userId) {
          const dbPath = successPath === 'wedding/progress' ? 
            `${DB_URL}/wedding/progress/${userId}.json` :
            `${DB_URL}/publicAnswers/wedding/progress/${userId}.json`;
            
          fetch(dbPath, {
            method: 'PUT',
            body: JSON.stringify(updateData)
          }).catch(err => console.warn('Could not save crossword completion:', err));
        }
        
        // Show completion message and transition
        if (isLastPuzzle || solvedPuzzles.slice(1, totalPuzzles + 1).every(Boolean)) {
          showSuccessAndTransition(customSuccessMessages.allComplete, () => {
            showCompletion();
          });
        } else if (nextPuzzle) {
          const message = customSuccessMessages.puzzleSolved.replace('{nextPuzzle}', nextPuzzle);
          showSuccessAndTransition(message, () => {
            loadPuzzle(nextPuzzle);
          });
        }
        
      } catch (error) {
        console.error('Error completing crossword puzzle:', error);
        showFeedback('Error saving crossword completion. Please try again.', 'error');
      }
    }
  </script>
</body>
</html> 