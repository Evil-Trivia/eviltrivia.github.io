<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wedding Puzzle</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #FFCC00;
      background-image: linear-gradient(135deg, #FFD34E 25%, #FFCC00 25%, #FFCC00 50%, #FFD34E 50%, #FFD34E 75%, #FFCC00 75%, #FFCC00 100%);
      background-size: 40px 40px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 40px;
      padding-bottom: 40px;
      position: relative;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 800px;
      width: 90%;
      margin: 0 auto;
      position: relative;
      z-index: 2;
    }
    
    .card {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      margin-bottom: 30px;
      transition: all 0.5s cubic-bezier(0.165, 0.84, 0.44, 1);
      opacity: 0;
      transform: translateY(20px);
      animation: fadeInUp 0.7s forwards;
      border: 1px solid rgba(0,0,0,0.05);
      overflow: hidden;
    }
    
    @keyframes fadeInUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .card-shake {
      animation: shake 0.5s;
    }
    
    @keyframes shake {
      0% { transform: translateX(0); }
      10% { transform: translateX(-10px); }
      20% { transform: translateX(10px); }
      30% { transform: translateX(-10px); }
      40% { transform: translateX(10px); }
      50% { transform: translateX(-5px); }
      60% { transform: translateX(5px); }
      70% { transform: translateX(-3px); }
      80% { transform: translateX(3px); }
      90% { transform: translateX(-1px); }
      100% { transform: translateX(0); }
    }
    
    h1 {
      text-align: center;
      color: #111;
      margin-bottom: 30px;
      font-size: 2.5rem;
      font-weight: bold;
      text-shadow: 2px 2px 0px rgba(0,0,0,0.1);
      letter-spacing: -0.5px;
    }
    
    h2 {
      margin-top: 0;
      font-size: 1.8rem;
      color: #222;
      border-bottom: 2px solid #FFCC00;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }
    
    p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #444;
    }
    
    .form-group {
      margin-bottom: 25px;
    }
    
    label {
      display: block;
      margin-bottom: 10px;
      font-weight: 600;
      color: #333;
      font-size: 1.05rem;
    }
    
    input[type="text"],
    input[type="email"] {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      background-color: white;
      outline: none;
      transition: all 0.3s ease;
      box-sizing: border-box;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
    }
    
    input[type="text"]:focus,
    input[type="email"]:focus {
      border-color: #FFCC00;
      box-shadow: 0 0 0 3px rgba(255, 204, 0, 0.2), inset 0 1px 3px rgba(0,0,0,0.05);
    }
    
    .btn {
      display: inline-block;
      padding: 14px 24px;
      background-color: #000000;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      text-decoration: none;
      text-align: center;
      transition: all 0.3s ease;
      width: 100%;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .btn:hover {
      background-color: #333333;
      transform: translateY(-3px);
      box-shadow: 0 7px 14px rgba(0,0,0,0.15), 0 5px 5px rgba(0,0,0,0.12);
    }
    
    .btn:active {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0,0,0,0.1), 0 2px 3px rgba(0,0,0,0.08);
    }
    
    .btn::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 5px;
      height: 5px;
      background: rgba(255, 255, 255, 0.5);
      opacity: 0;
      border-radius: 100%;
      transform: scale(1, 1) translate(-50%);
      transform-origin: 50% 50%;
    }
    
    .btn:focus:not(:active)::after {
      animation: ripple 1s ease-out;
    }
    
    @keyframes ripple {
      0% {
        transform: scale(0, 0);
        opacity: 0.5;
      }
      20% {
        transform: scale(25, 25);
        opacity: 0.3;
      }
      100% {
        opacity: 0;
        transform: scale(40, 40);
      }
    }
    
    .btn-secondary {
      background-color: #555;
      margin-top: 15px;
    }
    
    .btn-nav {
      width: auto;
      padding: 10px 20px;
      font-size: 14px;
      background-color: #555;
      text-transform: none;
      letter-spacing: 0;
    }
    
    .btn-nav:hover {
      background-color: #666;
    }
    
    .clue-image {
      max-width: 100%;
      border-radius: 8px;
      margin-bottom: 25px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.15);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .clue-image:hover {
      transform: scale(1.02);
      box-shadow: 0 12px 28px rgba(0,0,0,0.2);
    }
    
    .clue-gallery {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 25px;
      justify-content: center;
    }
    
    .clue-gallery img {
      max-width: calc(50% - 10px);
      max-height: 250px;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transition: all 0.3s ease;
    }
    
    .clue-gallery img:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 0 12px 24px rgba(0,0,0,0.2);
    }
    
    .clue-gallery img:only-child {
      max-width: 100%;
    }
    
    .feedback-message {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 25px;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      z-index: 100;
      opacity: 0;
      transition: all 0.5s ease;
      text-align: center;
      min-width: 200px;
      max-width: 80%;
    }
    
    .feedback-message.success {
      background-color: #4CAF50;
    }
    
    .feedback-message.error {
      background-color: #f44336;
    }
    
    .feedback-message.info {
      background-color: #2196F3;
    }
    
    .feedback-message.show {
      opacity: 1;
      transform: translate(-50%, -10px);
    }
    
    .hint-toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #ff9800;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      display: none;
      z-index: 100;
      animation: fadeIn 0.3s, float 2.5s ease-in-out infinite;
      font-weight: 600;
      box-shadow: 0 5px 15px rgba(0,0,0,0.15);
    }
    
    @keyframes float {
      0% { transform: translateX(-50%) translateY(0px); }
      50% { transform: translateX(-50%) translateY(-5px); }
      100% { transform: translateX(-50%) translateY(0px); }
    }
    
    .hint-toast.show {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .loader {
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-top: 5px solid #000000;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 30px auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .hidden {
      display: none;
    }
    
    .fade-in {
      animation: fadeIn 0.5s ease-in-out;
    }
    
    .error-message {
      color: #e53935;
      background-color: #ffebee;
      padding: 12px 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: 500;
      border-left: 4px solid #e53935;
    }
    
    .navigation-controls {
      display: flex;
      justify-content: flex-start;
      margin-bottom: 25px;
    }
    
    .multi-answer-container {
      margin-bottom: 20px;
      border-left: 4px solid #f0f0f0;
      padding-left: 20px;
      transition: all 0.3s ease;
      position: relative;
      padding-top: 5px;
      padding-bottom: 5px;
    }
    
    .multi-answer-container.correct {
      border-left-color: #4CAF50;
      background-color: rgba(76, 175, 80, 0.05);
      padding: 10px 15px 10px 20px;
      border-radius: 0 8px 8px 0;
    }
    
    .multi-answer-container.correct::before {
      content: '✓';
      position: absolute;
      left: -25px;
      top: 50%;
      transform: translateY(-50%);
      color: #4CAF50;
      font-weight: bold;
      font-size: 16px;
    }
    
    .multi-answer-container.incorrect {
      border-left-color: #f44336;
      background-color: rgba(244, 67, 54, 0.05);
      padding: 10px 15px 10px 20px;
      border-radius: 0 8px 8px 0;
    }
    
    .multi-answer-container.incorrect::before {
      content: '✗';
      position: absolute;
      left: -25px;
      top: 50%;
      transform: translateY(-50%);
      color: #f44336;
      font-weight: bold;
      font-size: 16px;
    }
    
    .welcome-message {
      text-align: center;
      margin-bottom: 25px;
      color: #333;
      font-size: 1.2em;
      line-height: 1.5;
    }
    
    .clue-content {
      margin-bottom: 25px;
      line-height: 1.6;
      font-size: 1.05rem;
      color: #333;
    }
    
    .clue-content img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin: 15px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .clue-content ul, .clue-content ol {
      padding-left: 25px;
      margin: 15px 0;
    }
    
    .page-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.4;
      pointer-events: none;
    }
    
    .confetti-piece {
      position: absolute;
      width: 10px;
      height: 20px;
      background-color: #ffd700;
      top: -20px;
      opacity: 0;
    }
    
    .success-checkmark {
      width: 80px;
      height: 80px;
      margin: 0 auto 15px;
      position: relative;
      display: none;
    }
    
    .success-checkmark .check-icon {
      width: 80px;
      height: 80px;
      position: relative;
      border-radius: 50%;
      box-sizing: content-box;
      border: 4px solid #4CAF50;
    }
    
    .success-checkmark .check-icon::before {
      top: 3px;
      left: -2px;
      transform: rotate(45deg);
      transform-origin: 100% 50%;
      width: 3px;
      height: 30px;
      position: absolute;
      content: '';
      background-color: #4CAF50;
      animation: success-checkmark-icon-stem 0.3s ease 0.2s forwards;
      opacity: 0;
    }
    
    .success-checkmark .check-icon::after {
      top: 0;
      left: 18px;
      transform: rotate(45deg);
      transform-origin: 0% 50%;
      width: 60px;
      height: 3px;
      position: absolute;
      content: '';
      background-color: #4CAF50;
      animation: success-checkmark-icon-kick 0.3s ease 0.25s forwards;
      opacity: 0;
    }
    
    @keyframes success-checkmark-icon-stem {
      0% { opacity: 0; height: 0; }
      25% { opacity: 1; height: 15px; }
      100% { opacity: 1; height: 30px; }
    }
    
    @keyframes success-checkmark-icon-kick {
      0% { opacity: 0; width: 0; }
      25% { opacity: 1; width: 30px; }
      100% { opacity: 1; width: 60px; }
    }
    
    @media (max-width: 600px) {
      .container {
        width: 92%;
        padding: 0;
      }
      
      .card {
        padding: 25px 20px;
      }
      
      h1 {
        font-size: 2rem;
        margin-bottom: 20px;
      }
      
      h2 {
        font-size: 1.5rem;
      }
      
      .clue-gallery img {
        max-width: 100%;
        margin-bottom: 15px;
      }
      
      .navigation-controls {
        flex-direction: column;
        gap: 10px;
      }
      
      .btn-nav {
        width: 100%;
      }
      
      input[type="text"], 
      input[type="email"] {
        padding: 12px 14px;
        font-size: 15px;
      }
      
      .btn {
        padding: 12px 20px;
        font-size: 15px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Wedding Puzzle</h1>
    
    <div id="card" class="card">
      <div id="loading" class="loader"></div>
      
      <!-- Success message display -->
      <div id="success-display" class="hidden" style="text-align: center; margin-bottom: 20px;">
        <div class="success-checkmark">
          <div class="check-icon"></div>
        </div>
        <h2 style="margin-bottom: 10px;">Correct!</h2>
        <p id="success-message">Great job! Moving to the next puzzle...</p>
      </div>
      
      <!-- Screen 0: Name & Email Form -->
      <div id="screen-0" class="hidden">
        <h2>Welcome to the Wedding Puzzle!</h2>
        <p>Please enter your information to get started:</p>
        
        <div id="registration-error" class="error-message hidden">
          Error registering user. Please try again.
        </div>
        
        <form id="info-form">
          <div class="form-group">
            <label for="name">Your Name:</label>
            <input type="text" id="name" required>
          </div>
          
          <div class="form-group">
            <label for="email">Your Email:</label>
            <input type="email" id="email" required>
          </div>
          
          <button type="submit" class="btn">Start Puzzle</button>
        </form>
      </div>
      
      <!-- Welcome Back Screen -->
      <div id="screen-welcome-back" class="hidden">
        <h2>Welcome Back!</h2>
        <p id="welcome-back-message" class="welcome-message">It's great to see you again.</p>
        
        <button id="continue-btn" class="btn">Continue Your Progress</button>
        <button id="restart-from-beginning-btn" class="btn btn-secondary">Start from Beginning</button>
      </div>
      
      <!-- Screens 1-10: Puzzles -->
      <div id="screen-puzzle" class="hidden">
        <div class="navigation-controls">
          <button id="prev-puzzle-btn" class="btn btn-nav">← Previous</button>
        </div>
        
        <h2 id="puzzle-name">Puzzle #1</h2>
        
        <div id="puzzle-error" class="error-message hidden">
          Error loading puzzle. Please refresh the page to try again.
        </div>
        
        <div id="clue-container">
          <div id="clue-content" class="clue-content"></div>
          <div id="clue-gallery" class="clue-gallery hidden"></div>
        </div>
        
        <form id="answer-form">
          <div id="answers-container">
            <!-- Dynamic answer fields will be inserted here -->
          </div>
          
          <button type="submit" class="btn">Submit Answer</button>
        </form>
      </div>
      
      <!-- Screen 11: Completion -->
      <div id="screen-complete" class="hidden">
        <h2>Congratulations!</h2>
        <p>You've completed all the puzzles!</p>
        <p id="completion-message"></p>
        
        <button id="restart-btn" class="btn">Start Over</button>
      </div>
    </div>
  </div>
  
  <div id="hint-toast" class="hint-toast">Need a hint? Ask the puzzle master!</div>
  <div id="feedback-message" class="feedback-message"></div>
  
  <!-- Canvas for confetti -->
  <canvas id="confetti-canvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:99;"></canvas>
  
  <script>
    // Firebase database URL - Using only direct REST API
    const DB_URL = "https://eviltrivia-47664-default-rtdb.firebaseio.com";
    
    // DOM Elements
    const loading = document.getElementById('loading');
    const card = document.getElementById('card');
    const screen0 = document.getElementById('screen-0');
    const screenWelcomeBack = document.getElementById('screen-welcome-back');
    const screenPuzzle = document.getElementById('screen-puzzle');
    const screenComplete = document.getElementById('screen-complete');
    
    const infoForm = document.getElementById('info-form');
    const answerForm = document.getElementById('answer-form');
    const puzzleName = document.getElementById('puzzle-name');
    const clueText = document.getElementById('clue-text');
    const clueImage = document.getElementById('clue-image');
    const completionMessage = document.getElementById('completion-message');
    const restartBtn = document.getElementById('restart-btn');
    const hintToast = document.getElementById('hint-toast');
    const registrationError = document.getElementById('registration-error');
    const puzzleError = document.getElementById('puzzle-error');
    const welcomeBackMessage = document.getElementById('welcome-back-message');
    const continueBtn = document.getElementById('continue-btn');
    const restartFromBeginningBtn = document.getElementById('restart-from-beginning-btn');
    const prevPuzzleBtn = document.getElementById('prev-puzzle-btn');
    const nextPuzzleBtn = document.getElementById('next-puzzle-btn');
    const answersContainer = document.getElementById('answers-container');
    
    // Game state
    let currentScreen = 0;
    let totalPuzzles = 10; // Default
    let wrongAttempts = 0;
    let puzzleData = null;
    let userId = null;
    let userName = '';
    let userEmail = '';
    let solvedPuzzles = [];
    
    // Show the loading spinner initially
    loading.style.display = 'block';
    
    // Generate a unique anonymous user ID if needed
    function getOrCreateUserId() {
      const storedId = localStorage.getItem('weddingPuzzleId');
      if (storedId) return storedId;
      
      // Generate a new anonymous ID - completely local, no Firebase auth
      const newId = 'anon_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('weddingPuzzleId', newId);
      return newId;
    }
    
    // Initialize - Check for existing progress in localStorage
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure we have a user ID even for anonymous users
      userId = getOrCreateUserId();
      
      const storedName = localStorage.getItem('weddingPuzzleName');
      const storedEmail = localStorage.getItem('weddingPuzzleEmail');
      const storedScreen = localStorage.getItem('weddingPuzzleScreen');
      
      if (storedName && storedEmail && storedScreen) {
        // Restore saved state
        userName = storedName;
        userEmail = storedEmail;
        currentScreen = parseInt(storedScreen);
        
        // Check if this is a fresh page load (not a form submission)
        const isPageRefresh = !document.referrer || (document.referrer && document.referrer.split('?')[0] === window.location.href.split('?')[0]);
        
        if (isPageRefresh && currentScreen > 0) {
          // Show welcome back screen
          showWelcomeBack();
        } else if (currentScreen >= 1 && currentScreen <= 10) {
          // Continue with a puzzle
          loadPuzzle(currentScreen);
        } else if (currentScreen === 11) {
          // Show completion screen
          showCompletion();
        } else {
          // Default to registration
          showScreen0();
        }
      } else {
        // No saved state, show registration
        showScreen0();
      }
      
      // Load total puzzles count
      loadTotalPuzzles();
    });
    
    // Load the total number of puzzles from the database
    async function loadTotalPuzzles() {
      try {
        // Try primary path
        let response = await fetch(`${DB_URL}/wedding/totalPuzzles.json`);
        
        // If primary failed, try backup path
        if (!response || !response.ok) {
          response = await fetch(`${DB_URL}/publicAnswers/wedding/totalPuzzles.json`);
        }
        
        if (response && response.ok) {
          const count = await response.json();
          if (count && !isNaN(count)) {
            totalPuzzles = count;
          }
        }
      } catch (error) {
        console.warn('Could not load total puzzles count, using default:', error);
      }
    }
    
    // Load the solved puzzles array from localStorage
    function loadSolvedPuzzles() {
      const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
      if (localProgress.solved && Array.isArray(localProgress.solved)) {
        solvedPuzzles = localProgress.solved;
      } else {
        // Initialize with default (first puzzle is 1, so we need 11 elements and ignore index 0)
        solvedPuzzles = Array(11).fill(false);
      }
    }
    
    // Display registration screen
    function showScreen0() {
      loading.style.display = 'none';
      screen0.classList.remove('hidden');
      screenWelcomeBack.classList.add('hidden');
      screenPuzzle.classList.add('hidden');
      screenComplete.classList.add('hidden');
      registrationError.classList.add('hidden');
      
      // Pre-fill if we have data
      if (userName) document.getElementById('name').value = userName;
      if (userEmail) document.getElementById('email').value = userEmail;
    }
    
    // Display welcome back screen
    function showWelcomeBack() {
      loading.style.display = 'none';
      screen0.classList.add('hidden');
      screenWelcomeBack.classList.remove('hidden');
      screenPuzzle.classList.add('hidden');
      screenComplete.classList.add('hidden');
      
      welcomeBackMessage.textContent = `Welcome back, ${userName}! You were on puzzle ${currentScreen} of ${totalPuzzles}.`;
    }
    
    // Display puzzle screen
    async function loadPuzzle(puzzleNum) {
      try {
        // Show loading
        loading.style.display = 'block';
        screen0.classList.add('hidden');
        screenWelcomeBack.classList.add('hidden');
        screenPuzzle.classList.add('hidden');
        screenComplete.classList.add('hidden');
        puzzleError.classList.add('hidden');
        
        // Load solved puzzles data
        loadSolvedPuzzles();
        
        // Fetch puzzle data - try multiple paths with fallbacks
        let puzzleResponse = null;
        
        // First try primary path
        try {
          puzzleResponse = await fetch(`${DB_URL}/wedding/answers/${puzzleNum}.json`);
        } catch (error) {
          console.error('Error with primary puzzle path:', error);
        }
        
        // If primary failed, try backup path
        if (!puzzleResponse || !puzzleResponse.ok) {
          try {
            puzzleResponse = await fetch(`${DB_URL}/publicAnswers/wedding/${puzzleNum}.json`);
          } catch (error) {
            console.error('Error with backup puzzle path:', error);
          }
        }
        
        // Parse the data if we have a valid response
        if (puzzleResponse && puzzleResponse.ok) {
          puzzleData = await puzzleResponse.json();
        }
        
        // Apply fallback content if needed
        if (!puzzleData) {
          puzzleData = {
            name: `Puzzle ${puzzleNum}`,
            clue: `Puzzle ${puzzleNum} - Unable to load data. Please try again later.`,
            clueHtml: '',
            imageUrls: [],
            answers: [{ 
              text: "answer",
              questionText: "Your Answer:"
            }]
          };
          puzzleError.classList.remove('hidden');
        }
        
        // Ensure puzzleData has the expected structure
        if (!puzzleData.answers) {
          // Convert old format to new format
          puzzleData.answers = [{
            text: puzzleData.answer || "answer",
            questionText: "Your Answer:"
          }];
          delete puzzleData.answer;
        }
        
        // Convert single imageUrl to imageUrls array if needed
        if (puzzleData.imageUrl && !puzzleData.imageUrls) {
          puzzleData.imageUrls = puzzleData.imageUrl ? [puzzleData.imageUrl] : [];
        }
        
        // Update puzzle name or use default
        puzzleName.textContent = puzzleData.name || `Puzzle #${puzzleNum}`;
        
        // Display clue content - prefer HTML content if available
        const clueContent = document.getElementById('clue-content');
        if (puzzleData.clueHtml) {
          clueContent.innerHTML = puzzleData.clueHtml;
        } else {
          clueContent.textContent = puzzleData.clue || 'No clue provided';
        }
        
        // Handle images
        const clueGallery = document.getElementById('clue-gallery');
        if (puzzleData.imageUrls && puzzleData.imageUrls.length > 0) {
          // Clear gallery
          clueGallery.innerHTML = '';
          
          // Add all images
          puzzleData.imageUrls.forEach(url => {
            if (url && url.trim()) {
              const img = document.createElement('img');
              img.src = url.trim();
              img.alt = "Puzzle Clue";
              clueGallery.appendChild(img);
            }
          });
          
          clueGallery.classList.remove('hidden');
        } else {
          clueGallery.classList.add('hidden');
        }
        
        // Generate answer fields
        answersContainer.innerHTML = '';
        puzzleData.answers.forEach((answer, index) => {
          const multiAnswerDiv = document.createElement('div');
          multiAnswerDiv.className = 'multi-answer-container';
          multiAnswerDiv.id = `answer-container-${index}`;
          
          const formGroup = document.createElement('div');
          formGroup.className = 'form-group';
          
          const label = document.createElement('label');
          label.setAttribute('for', `answer-${index}`);
          label.textContent = answer.questionText || `Answer ${index + 1}:`;
          
          const input = document.createElement('input');
          input.type = 'text';
          input.id = `answer-${index}`;
          input.className = 'answer-input';
          input.required = true;
          
          formGroup.appendChild(label);
          formGroup.appendChild(input);
          multiAnswerDiv.appendChild(formGroup);
          answersContainer.appendChild(multiAnswerDiv);
        });
        
        // Reset wrong attempts
        wrongAttempts = 0;
        
        // Update navigation buttons
        updateNavigationButtons(puzzleNum);
        
        // Display puzzle screen
        loading.style.display = 'none';
        screenPuzzle.classList.remove('hidden');
        
        // Focus first answer field
        const firstAnswerInput = document.querySelector('.answer-input');
        if (firstAnswerInput) {
          firstAnswerInput.value = '';
          firstAnswerInput.focus();
        }
        
      } catch (error) {
        console.error('Error loading puzzle:', error);
        // Show error and fallback content
        puzzleData = {
          name: `Puzzle ${puzzleNum}`,
          clue: `Puzzle ${puzzleNum} - Unable to load data. Please try again later.`,
          imageUrls: [],
          answers: [{
            text: "answer",
            questionText: "Your Answer:"
          }]
        };
        
        puzzleName.textContent = puzzleData.name;
        document.getElementById('clue-content').textContent = puzzleData.clue;
        document.getElementById('clue-gallery').classList.add('hidden');
        
        // Generate single answer field
        answersContainer.innerHTML = '';
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        
        const label = document.createElement('label');
        label.setAttribute('for', 'answer-0');
        label.textContent = 'Your Answer:';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.id = 'answer-0';
        input.className = 'answer-input';
        input.required = true;
        
        formGroup.appendChild(label);
        formGroup.appendChild(input);
        answersContainer.appendChild(formGroup);
        
        // Update navigation
        updateNavigationButtons(puzzleNum);
        
        loading.style.display = 'none';
        screenPuzzle.classList.remove('hidden');
        puzzleError.classList.remove('hidden');
      }
    }
    
    // Update navigation buttons based on current puzzle
    function updateNavigationButtons(puzzleNum) {
      // Previous button is always visible except on first puzzle
      prevPuzzleBtn.classList.toggle('hidden', puzzleNum <= 1);
    }
    
    // Display completion screen
    function showCompletion() {
      loading.style.display = 'none';
      screen0.classList.add('hidden');
      screenWelcomeBack.classList.add('hidden');
      screenPuzzle.classList.add('hidden');
      screenComplete.classList.remove('hidden');
      
      completionMessage.textContent = `Congrats ${userName || 'friend'}! You've solved all the puzzles!`;
      
      // Trigger confetti
      startConfetti();
    }
    
    // Registration form submission - completely rebuilt without any Firebase Auth
    infoForm.addEventListener('submit', function(e) {
      e.preventDefault();
      
      // Get user info
      userName = document.getElementById('name').value.trim();
      userEmail = document.getElementById('email').value.trim();
      
      if (!userName || !userEmail) {
        alert('Please enter both name and email.');
        return;
      }
      
      // Show loading
      loading.style.display = 'block';
      screen0.classList.add('hidden');
      registrationError.classList.add('hidden');
      
      // Generate unique ID locally (no Firebase auth)
      userId = 'anon_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('weddingPuzzleId', userId);
      
      // Set initial progress
      currentScreen = 1;
      
      // Save to localStorage first (most important)
      localStorage.setItem('weddingPuzzleName', userName);
      localStorage.setItem('weddingPuzzleEmail', userEmail);
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      
      // Initialize solved puzzles array
      solvedPuzzles = Array(11).fill(false);
      
      // Prepare progress data
      const progressData = {
        name: userName,
        email: userEmail,
        currentScreen: currentScreen,
        solved: solvedPuzzles,
        timestamp: new Date().toISOString()
      };
      
      // Store locally regardless of what happens with remote saves
      localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(progressData));
      
      // Try saving to primary DB path
      fetch(`${DB_URL}/wedding/progress/${userId}.json`, {
        method: 'PUT',
        body: JSON.stringify(progressData)
      })
      .then(response => {
        if (response.ok) {
          localStorage.setItem('weddingPuzzleSuccessPath', 'wedding/progress');
          return true;
        }
        // Try fallback if primary fails
        return fetch(`${DB_URL}/publicAnswers/wedding/progress/${userId}.json`, {
          method: 'PUT',
          body: JSON.stringify(progressData)
        });
      })
      .then(response => {
        if (response && response !== true && response.ok) {
          localStorage.setItem('weddingPuzzleSuccessPath', 'publicAnswers/wedding/progress');
        }
        // Regardless of DB save outcome, continue to first puzzle
        loadPuzzle(currentScreen);
      })
      .catch(error => {
        console.warn('Error saving progress to database:', error);
        // Continue anyway with local storage data
        loadPuzzle(currentScreen);
      });
    });
    
    // Welcome back buttons
    continueBtn.addEventListener('click', function() {
      loadPuzzle(currentScreen);
    });
    
    restartFromBeginningBtn.addEventListener('click', function() {
      currentScreen = 1;
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      loadPuzzle(currentScreen);
    });
    
    // Navigation buttons
    prevPuzzleBtn.addEventListener('click', function() {
      if (currentScreen > 1) {
        currentScreen--;
        localStorage.setItem('weddingPuzzleScreen', currentScreen);
        loadPuzzle(currentScreen);
      }
    });
    
    nextPuzzleBtn.addEventListener('click', function() {
      if (currentScreen < totalPuzzles && solvedPuzzles[currentScreen]) {
        currentScreen++;
        localStorage.setItem('weddingPuzzleScreen', currentScreen);
        loadPuzzle(currentScreen);
      }
    });
    
    // Show a feedback message
    function showFeedback(message, type) {
      const feedbackEl = document.getElementById('feedback-message');
      feedbackEl.textContent = message;
      feedbackEl.className = 'feedback-message ' + type;
      
      // Show the message
      setTimeout(() => {
        feedbackEl.classList.add('show');
        
        // Hide after 3 seconds
        setTimeout(() => {
          feedbackEl.classList.remove('show');
        }, 3000);
      }, 10);
    }
    
    // Show a success message and transition to the next screen after a delay
    function showSuccessAndTransition(message, nextFunction) {
      // Hide the answer form
      document.getElementById('answer-form').style.display = 'none';
      
      // Show success display
      const successDisplay = document.getElementById('success-display');
      const successMessage = document.getElementById('success-message');
      successMessage.textContent = message || 'Great job! Moving to the next puzzle...';
      successDisplay.classList.remove('hidden');
      
      // Show the checkmark
      const checkmark = document.querySelector('.success-checkmark');
      checkmark.style.display = 'block';
      
      // Transition after delay
      setTimeout(() => {
        if (typeof nextFunction === 'function') {
          nextFunction();
        }
      }, 2000);
    }
    
    // Answer submission
    answerForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      // Collect all answers
      const answerInputs = document.querySelectorAll('.answer-input');
      const answers = Array.from(answerInputs).map(input => input.value.trim());
      
      if (answers.some(a => !a)) {
        showFeedback('Please fill in all answer fields.', 'error');
        return;
      }
      
      try {
        // Check if all answers are correct
        let allCorrect = true;
        let correctAnswers = 0;
        
        // For each answer, check if it matches
        answers.forEach((answer, index) => {
          const expectedAnswer = puzzleData.answers[index]?.text || '';
          const isCorrect = answer.toLowerCase() === expectedAnswer.toLowerCase();
          
          // Mark the answer container as correct if it's right
          const answerContainer = document.getElementById(`answer-container-${index}`);
          if (answerContainer) {
            if (isCorrect) {
              answerContainer.classList.add('correct');
              answerContainer.classList.remove('incorrect');
              correctAnswers++;
            } else {
              answerContainer.classList.remove('correct');
              answerContainer.classList.add('incorrect');
              allCorrect = false;
            }
          }
        });
        
        // Track attempt in localStorage first
        const attemptData = {
          answers: answers,
          correct: allCorrect,
          timestamp: new Date().toISOString()
        };
        
        // Always store locally first
        const localAttempts = JSON.parse(localStorage.getItem('weddingPuzzleLocalAttempts') || '{}');
        if (!localAttempts[currentScreen]) localAttempts[currentScreen] = [];
        localAttempts[currentScreen].push(attemptData);
        localStorage.setItem('weddingPuzzleLocalAttempts', JSON.stringify(localAttempts));
        
        // Try to save attempt to database (non-blocking)
        const successPath = localStorage.getItem('weddingPuzzleSuccessPath');
        if (successPath === 'wedding/progress') {
          fetch(`${DB_URL}/wedding/attempts/${currentScreen}/${userId}.json`, {
            method: 'POST',
            body: JSON.stringify(attemptData)
          }).catch(err => console.warn('Could not save attempt to primary path:', err));
        } else if (successPath === 'publicAnswers/wedding/progress') {
          fetch(`${DB_URL}/publicAnswers/wedding/attempts/${currentScreen}/${userId}.json`, {
            method: 'POST',
            body: JSON.stringify(attemptData)
          }).catch(err => console.warn('Could not save attempt to fallback path:', err));
        }
        
        if (allCorrect) {
          // Update progress
          solvedPuzzles[currentScreen] = true;
          
          // If this is the current puzzle in sequence, move to next
          if (currentScreen >= parseInt(localStorage.getItem('weddingPuzzleScreen'))) {
            currentScreen++;
            localStorage.setItem('weddingPuzzleScreen', currentScreen);
          }
          
          // Update solved status in localStorage
          const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
          if (localProgress.solved) {
            localProgress.solved = solvedPuzzles;
            localProgress.currentScreen = currentScreen;
            localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
          }
          
          // Try to update Firebase using the known successful path (non-blocking)
          const updateData = {
            currentScreen: currentScreen,
            solved: solvedPuzzles
          };
          
          if (successPath === 'wedding/progress') {
            fetch(`${DB_URL}/wedding/progress/${userId}.json`, {
              method: 'PATCH',
              body: JSON.stringify(updateData)
            }).catch(err => console.warn('Could not update progress in primary path:', err));
          } else if (successPath === 'publicAnswers/wedding/progress') {
            fetch(`${DB_URL}/publicAnswers/wedding/progress/${userId}.json`, {
              method: 'PATCH',
              body: JSON.stringify(updateData)
            }).catch(err => console.warn('Could not update progress in fallback path:', err));
          }
          
          // Check if all puzzles completed
          if (currentScreen > totalPuzzles) {
            // All puzzles completed
            showSuccessAndTransition('All puzzles completed! Great job!', showCompletion);
          } else {
            // Show success message and then load next puzzle
            showSuccessAndTransition('Correct! Moving to the next puzzle...', () => {
              // Reset the card styles
              document.getElementById('success-display').classList.add('hidden');
              document.getElementById('answer-form').style.display = 'block';
              document.querySelector('.success-checkmark').style.display = 'none';
              
              // Load the next puzzle with a card animation
              card.style.animation = 'none';
              setTimeout(() => {
                card.style.animation = 'fadeInUp 0.7s forwards';
                loadPuzzle(currentScreen);
              }, 10);
            });
          }
          
        } else {
          // Wrong answer
          wrongAttempts++;
          
          // Shake the card
          card.classList.add('card-shake');
          setTimeout(() => {
            card.classList.remove('card-shake');
          }, 500);
          
          // Show error feedback
          if (correctAnswers > 0) {
            showFeedback(`Some answers are wrong. Keep trying!`, 'error');
          } else {
            showFeedback(`That's not right. Try again!`, 'error');
          }
          
          // Show hint after 3 wrong attempts
          if (wrongAttempts >= 3) {
            hintToast.classList.add('show');
            setTimeout(() => {
              hintToast.classList.remove('show');
            }, 5000);
          }
          
          // If some answers are correct, keep them highlighted
          if (correctAnswers > 0) {
            // Focus the first incorrect answer
            for (let i = 0; i < answerInputs.length; i++) {
              if (answers[i].toLowerCase() !== (puzzleData.answers[i]?.text || '').toLowerCase()) {
                answerInputs[i].focus();
                break;
              }
            }
          } else {
            // Clear all answer fields if none are correct
            answerInputs[0].focus();
          }
        }
        
      } catch (error) {
        console.error('Error processing answer:', error);
        showFeedback('There was a problem processing your answer. Please try again.', 'error');
      }
    });
    
    // Restart button
    restartBtn.addEventListener('click', () => {
      currentScreen = 1;
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      loadPuzzle(currentScreen);
    });
    
    // Confetti effect on completion
    function startConfetti() {
      const canvas = document.getElementById('confetti-canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      const pieces = [];
      const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', 
                     '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50',
                     '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', 
                     '#FFD700', '#FFA500', '#FF6347', '#FF4500', '#FF1493'];
      
      class Piece {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * -100;
          this.rotation = Math.random() * 360;
          this.size = Math.random() * 25 + 5; // Bigger pieces
          this.weight = Math.random() * 1 + 0.5; // Varied weights for natural movement
          this.speed = Math.random() * 6 + 2; // Faster movement
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.shape = Math.random() > 0.5 ? 'circle' : 'rect';
          this.opacity = Math.random() * 0.5 + 0.5; // Varied opacity
          this.rotationSpeed = (Math.random() - 0.5) * 5; // Some rotate clockwise, some counter-clockwise
        }
        
        update() {
          this.y += this.speed;
          this.x += Math.sin(this.y * this.weight * 0.01) * 2; // Wavy horizontal movement
          this.rotation += this.rotationSpeed;
          
          if (this.y > canvas.height) {
            this.y = Math.random() * -100;
            this.x = Math.random() * canvas.width;
          }
        }
        
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation * Math.PI / 180);
          ctx.globalAlpha = this.opacity;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          
          if (this.shape === 'circle') {
            ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
          } else {
            ctx.rect(-this.size / 2, -this.size / 2, this.size, this.size);
          }
          
          ctx.fill();
          ctx.restore();
        }
      }
      
      // Create more pieces
      for (let i = 0; i < 250; i++) {
        pieces.push(new Piece());
      }
      
      // Animation loop
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        pieces.forEach(piece => {
          piece.update();
          piece.draw();
        });
        
        requestAnimationFrame(animate);
      }
      
      animate();
    }
  </script>
</body>
</html> 