<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wedding Puzzle</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #FFD34E 0%, #FFCC00 25%, #FFD34E 50%, #FFCC00 75%, #FFD34E 100%);
      background-size: 200px 200px;
      background-attachment: fixed;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 40px;
      padding-bottom: 40px;
      position: relative;
      overflow-x: hidden;
      animation: subtleBackgroundShift 20s ease-in-out infinite;
    }
    
    @keyframes subtleBackgroundShift {
      0%, 100% { background-position: 0 0; }
      50% { background-position: 20px 20px; }
    }
    
    .container {
      max-width: 800px;
      width: 90%;
      margin: 0 auto;
      position: relative;
      z-index: 2;
    }
    
    .card {
      background: linear-gradient(145deg, #ffffff, #f8f9fa);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 
        0 20px 60px rgba(0,0,0,0.15),
        0 0 0 1px rgba(255,255,255,0.9) inset,
        0 2px 0 rgba(255,255,255,0.6) inset;
      margin-bottom: 30px;
      transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
      opacity: 0;
      transform: translateY(30px) scale(0.95);
      animation: cardEntranceAnimation 0.8s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
      border: 1px solid rgba(255,255,255,0.3);
      overflow: hidden;
      position: relative;
      backdrop-filter: blur(10px);
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, #FFD700, #FFCC00, #FFD700);
      opacity: 0.7;
    }
    
    @keyframes cardEntranceAnimation {
      0% {
        opacity: 0;
        transform: translateY(30px) scale(0.95);
      }
      60% {
        opacity: 0.8;
        transform: translateY(-5px) scale(1.02);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    .card:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 
        0 30px 80px rgba(0,0,0,0.2),
        0 0 0 1px rgba(255,255,255,0.9) inset,
        0 2px 0 rgba(255,255,255,0.6) inset;
    }
    
    .card-shake {
      animation: enhancedShake 0.6s cubic-bezier(0.36, 0.07, 0.19, 0.97);
    }
    
    @keyframes enhancedShake {
      0% { transform: translateX(0) scale(1); }
      10% { transform: translateX(-15px) scale(1.02); }
      20% { transform: translateX(15px) scale(0.98); }
      30% { transform: translateX(-12px) scale(1.01); }
      40% { transform: translateX(12px) scale(0.99); }
      50% { transform: translateX(-8px) scale(1.005); }
      60% { transform: translateX(8px) scale(0.995); }
      70% { transform: translateX(-4px) scale(1.002); }
      80% { transform: translateX(4px) scale(0.998); }
      90% { transform: translateX(-2px) scale(1.001); }
      100% { transform: translateX(0) scale(1); }
    }
    
    /* Enhanced screen transition animations */
    .screen-transition {
      animation: smoothFadeSlideIn 0.8s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
    }
    
    @keyframes smoothFadeSlideIn {
      0% {
        opacity: 0;
        transform: translateY(40px) scale(0.95);
        filter: blur(5px);
      }
      60% {
        opacity: 0.8;
        filter: blur(1px);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
    }
    
    .screen-exit {
      animation: smoothFadeSlideOut 0.6s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
    }
    
    @keyframes smoothFadeSlideOut {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
      40% {
        opacity: 0.6;
        filter: blur(1px);
      }
      100% {
        opacity: 0;
        transform: translateY(-40px) scale(0.95);
        filter: blur(5px);
      }
    }
    
    h1 {
      text-align: center;
      background: linear-gradient(135deg, #333, #111, #333);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 30px;
      font-size: 2.8rem;
      font-weight: 800;
      text-shadow: 2px 2px 0px rgba(0,0,0,0.1);
      letter-spacing: -1px;
      position: relative;
    }
    
    h1::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      width: 60px;
      height: 3px;
      background: linear-gradient(90deg, #FFD700, #FFCC00);
      transform: translateX(-50%);
      border-radius: 2px;
    }
    
    h2 {
      margin-top: 0;
      font-size: 1.9rem;
      color: #222;
      border-bottom: 3px solid #FFCC00;
      padding-bottom: 15px;
      margin-bottom: 25px;
      position: relative;
      font-weight: 600;
    }
    
    h2::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 0;
      width: 40px;
      height: 3px;
      background: #FFD700;
      border-radius: 2px;
    }
    
    p {
      font-size: 1.1rem;
      line-height: 1.7;
      color: #444;
    }
    
    .form-group {
      margin-bottom: 25px;
      position: relative;
    }
    
    label {
      display: block;
      margin-bottom: 12px;
      font-weight: 600;
      color: #333;
      font-size: 1.05rem;
      transition: color 0.3s ease;
    }
    
    input[type="text"],
    input[type="email"] {
      width: 100%;
      padding: 18px 20px;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      font-size: 16px;
      background: linear-gradient(145deg, #ffffff, #f8f9fa);
      outline: none;
      transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
      box-sizing: border-box;
      box-shadow: 
        0 4px 15px rgba(0,0,0,0.05),
        0 0 0 1px rgba(255,255,255,0.9) inset;
      position: relative;
    }
    
    input[type="text"]:hover,
    input[type="email"]:hover {
      border-color: #ccc;
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(0,0,0,0.1),
        0 0 0 1px rgba(255,255,255,0.9) inset;
    }
    
    input[type="text"]:focus,
    input[type="email"]:focus {
      border-color: #FFCC00;
      transform: translateY(-3px);
      box-shadow: 
        0 12px 35px rgba(255, 204, 0, 0.2),
        0 0 0 4px rgba(255, 204, 0, 0.1),
        0 0 0 1px rgba(255,255,255,0.9) inset;
    }
    
    input[type="text"]:focus + label,
    input[type="email"]:focus + label {
      color: #FFCC00;
    }
    
    .btn {
      display: inline-block;
      padding: 18px 32px;
      background: linear-gradient(135deg, #000000, #333333, #000000);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      text-decoration: none;
      text-align: center;
      transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
      width: 100%;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      box-shadow: 
        0 8px 25px rgba(0,0,0,0.2),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn:hover {
      background: linear-gradient(135deg, #333333, #555555, #333333);
      transform: translateY(-4px);
      box-shadow: 
        0 15px 40px rgba(0,0,0,0.25),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn:active {
      transform: translateY(-2px);
      box-shadow: 
        0 8px 20px rgba(0,0,0,0.15),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn:disabled {
      background: linear-gradient(135deg, #cccccc, #e0e0e0, #cccccc);
      color: #888;
      cursor: not-allowed;
      transform: none;
      box-shadow: 
        0 2px 8px rgba(0,0,0,0.1),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn:disabled:hover {
      background: linear-gradient(135deg, #cccccc, #e0e0e0, #cccccc);
      transform: none;
      box-shadow: 
        0 2px 8px rgba(0,0,0,0.1),
        0 0 0 1px rgba(255,255,255,0.1) inset;
    }
    
    .btn-secondary {
      background: linear-gradient(135deg, #555, #777, #555);
      margin-top: 15px;
    }
    
    .btn-secondary:hover {
      background: linear-gradient(135deg, #666, #888, #666);
    }
    
    .btn-nav {
      width: auto;
      padding: 12px 24px;
      font-size: 14px;
      background: linear-gradient(135deg, #555, #777, #555);
      text-transform: none;
      letter-spacing: 0.5px;
      min-width: 50px;
      position: relative;
      overflow: hidden;
    }
    
    .btn-nav:hover {
      background: linear-gradient(135deg, #666, #888, #666);
    }
    
    .btn-nav.current-puzzle {
      background: linear-gradient(135deg, #2E7D32, #4CAF50, #2E7D32);
      border: 2px solid #4CAF50;
      box-shadow: 
        0 4px 15px rgba(76, 175, 80, 0.4),
        0 0 0 1px rgba(255,255,255,0.2) inset;
      transform: scale(1.05);
      font-weight: 700;
    }
    
    .btn-nav.current-puzzle:hover {
      background: linear-gradient(135deg, #388E3C, #66BB6A, #388E3C);
      transform: scale(1.05);
    }
    
    .btn-nav.current-puzzle::before {
      content: '';
      position: absolute;
      bottom: 8px;
      left: 50%;
      width: 4px;
      height: 4px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      transform: translateX(-50%);
      animation: currentPuzzlePulse 2s ease-in-out infinite;
    }
    
    @keyframes currentPuzzlePulse {
      0%, 100% {
        opacity: 0.8;
        transform: translateX(-50%) scale(1);
      }
      50% {
        opacity: 1;
        transform: translateX(-50%) scale(1.5);
      }
    }
    
    .btn-nav.solved-puzzle {
      background: linear-gradient(135deg, #4CAF50, #66BB6A, #4CAF50);
      color: white;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
    
    .btn-nav.solved-puzzle:hover {
      background: linear-gradient(135deg, #66BB6A, #81C784, #66BB6A);
    }
    
    .puzzle-nav-container {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-left: auto;
      align-items: center;
    }
    
    .clue-image {
      max-width: 100%;
      border-radius: 8px;
      margin-bottom: 25px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.15);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .clue-image:hover {
      transform: scale(1.02);
      box-shadow: 0 12px 28px rgba(0,0,0,0.2);
    }
    
    .clue-gallery {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 25px;
      justify-content: center;
    }
    
    .clue-gallery img {
      max-width: calc(50% - 10px);
      max-height: 250px;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transition: all 0.3s ease;
    }
    
    .clue-gallery img:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 0 12px 24px rgba(0,0,0,0.2);
    }
    
    .clue-gallery img:only-child {
      max-width: 100%;
    }
    
    .feedback-message {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      padding: 20px 30px;
      border-radius: 16px;
      color: white;
      font-weight: 600;
      box-shadow: 
        0 20px 40px rgba(0,0,0,0.3),
        0 0 0 1px rgba(255,255,255,0.2) inset;
      z-index: 100;
      opacity: 0;
      transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
      text-align: center;
      min-width: 250px;
      max-width: 80%;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .feedback-message.success {
      background: linear-gradient(135deg, #4CAF50, #66BB6A);
    }
    
    .feedback-message.error {
      background: linear-gradient(135deg, #f44336, #ef5350);
    }
    
    .feedback-message.info {
      background: linear-gradient(135deg, #2196F3, #42A5F5);
    }
    
    .feedback-message.show {
      opacity: 1;
      transform: translate(-50%, -15px) scale(1.02);
    }
    
    .hint-toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ff9800, #ffb74d);
      color: white;
      padding: 16px 24px;
      border-radius: 16px;
      display: none;
      z-index: 100;
      animation: hintToastEntrance 0.6s cubic-bezier(0.165, 0.84, 0.44, 1), hintFloat 3s ease-in-out infinite 0.6s;
      font-weight: 600;
      box-shadow: 
        0 15px 35px rgba(255, 152, 0, 0.4),
        0 0 0 1px rgba(255,255,255,0.2) inset;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    @keyframes hintToastEntrance {
      0% {
        opacity: 0;
        transform: translateX(-50%) translateY(20px) scale(0.9);
      }
      100% {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
      }
    }
    
    @keyframes hintFloat {
      0%, 100% { transform: translateX(-50%) translateY(0px); }
      50% { transform: translateX(-50%) translateY(-8px); }
    }
    
    .hint-toast.show {
      display: block;
    }
    
    .loader {
      border: 6px solid rgba(255, 255, 255, 0.2);
      border-top: 6px solid #000000;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: smoothSpin 1.2s cubic-bezier(0.4, 0.0, 0.2, 1) infinite;
      margin: 40px auto;
      position: relative;
    }
    
    .loader::after {
      content: '';
      position: absolute;
      top: -6px;
      left: -6px;
      right: -6px;
      bottom: -6px;
      border: 6px solid transparent;
      border-top: 6px solid rgba(255, 204, 0, 0.3);
      border-radius: 50%;
      animation: smoothSpin 2s cubic-bezier(0.4, 0.0, 0.2, 1) infinite reverse;
    }
    
    @keyframes smoothSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .puzzle-transition {
      transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
    }
    
    .puzzle-content-enter {
      opacity: 0;
      transform: translateY(20px) scale(0.98);
      filter: blur(3px);
    }
    
    .puzzle-content-enter-active {
      opacity: 1;
      transform: translateY(0) scale(1);
      filter: blur(0);
      transition: all 0.8s cubic-bezier(0.165, 0.84, 0.44, 1);
    }
    
    .puzzle-content-exit {
      opacity: 1;
      transform: translateY(0) scale(1);
      filter: blur(0);
    }
    
    .puzzle-content-exit-active {
      opacity: 0;
      transform: translateY(-20px) scale(0.98);
      filter: blur(3px);
      transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
    }
    
    .hidden {
      display: none;
    }
    
    .fade-in {
      animation: fadeIn 0.5s ease-in-out;
    }
    
    .error-message {
      color: #e53935;
      background-color: #ffebee;
      padding: 12px 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: 500;
      border-left: 4px solid #e53935;
    }
    
    .navigation-controls {
      display: flex;
      justify-content: flex-start;
      margin-bottom: 25px;
    }
    
    .multi-answer-container {
      margin-bottom: 20px;
      border-left: 4px solid #e0e0e0;
      padding-left: 20px;
      transition: all 0.5s cubic-bezier(0.165, 0.84, 0.44, 1);
      position: relative;
      padding-top: 8px;
      padding-bottom: 8px;
      border-radius: 0 12px 12px 0;
      background: linear-gradient(90deg, transparent, rgba(224, 224, 224, 0.05));
    }
    
    .multi-answer-container:hover {
      border-left-color: #ccc;
      background: linear-gradient(90deg, transparent, rgba(200, 200, 200, 0.08));
      transform: translateX(3px);
    }
    
    .multi-answer-container.correct {
      border-left-color: #4CAF50;
      background: linear-gradient(90deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
      padding: 15px 20px 15px 25px;
      box-shadow: 0 4px 20px rgba(76, 175, 80, 0.2);
      animation: correctAnswerPulse 0.6s ease-out;
    }
    
    .multi-answer-container.correct::before {
      content: '✓';
      position: absolute;
      left: -30px;
      top: 50%;
      transform: translateY(-50%);
      color: #4CAF50;
      font-weight: bold;
      font-size: 18px;
      background: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
      animation: checkmarkAppear 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .multi-answer-container.incorrect {
      border-left-color: #f44336;
      background: linear-gradient(90deg, rgba(244, 67, 54, 0.1), rgba(244, 67, 54, 0.05));
      padding: 15px 20px 15px 25px;
      box-shadow: 0 4px 20px rgba(244, 67, 54, 0.2);
      animation: incorrectAnswerShake 0.6s ease-out;
    }
    
    .multi-answer-container.incorrect::before {
      content: '✗';
      position: absolute;
      left: -30px;
      top: 50%;
      transform: translateY(-50%);
      color: #f44336;
      font-weight: bold;
      font-size: 18px;
      background: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
      animation: crossAppear 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    @keyframes correctAnswerPulse {
      0% {
        background: linear-gradient(90deg, rgba(76, 175, 80, 0.0), rgba(76, 175, 80, 0.0));
        transform: scale(1);
      }
      50% {
        background: linear-gradient(90deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
        transform: scale(1.02);
      }
      100% {
        background: linear-gradient(90deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
        transform: scale(1);
      }
    }
    
    @keyframes incorrectAnswerShake {
      0%, 100% {
        transform: translateX(0);
      }
      25% {
        transform: translateX(-3px);
      }
      75% {
        transform: translateX(3px);
      }
    }
    
    @keyframes checkmarkAppear {
      0% { 
        opacity: 0; 
        transform: scale(0.3) rotate(-45deg);
      }
      70% {
        opacity: 1;
        transform: scale(1.2) rotate(0deg);
      }
      100% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg);
      }
    }
    
    @keyframes crossAppear {
      0% {
        opacity: 0;
        transform: translateY(-50%) scale(0) rotate(180deg);
      }
      70% {
        transform: translateY(-50%) scale(1.2) rotate(0deg);
      }
      100% {
        opacity: 1;
        transform: translateY(-50%) scale(1) rotate(0deg);
      }
    }
    
    .welcome-message {
      text-align: center;
      margin-bottom: 25px;
      color: #333;
      font-size: 1.2em;
      line-height: 1.5;
    }
    
    .clue-content {
      margin-bottom: 25px;
      line-height: 1.6;
      font-size: 1.05rem;
      color: #333;
    }
    
    .clue-content img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin: 15px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .clue-content ul, .clue-content ol {
      padding-left: 25px;
      margin: 15px 0;
    }
    
    .page-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.4;
      pointer-events: none;
    }
    
    .confetti-piece {
      position: absolute;
      width: 10px;
      height: 20px;
      background-color: #ffd700;
      top: -20px;
      opacity: 0;
    }
    
    .success-checkmark {
      width: 100px;
      height: 100px;
      margin: 0 auto 20px;
      position: relative;
      display: none;
      animation: checkmarkBounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .success-checkmark.show {
      display: block;
    }
    
    .success-checkmark .check-icon {
      width: 100px;
      height: 100px;
      position: relative;
      border-radius: 50%;
      box-sizing: content-box;
      border: 5px solid #4CAF50;
      background: linear-gradient(145deg, #ffffff, #f8f9fa);
      box-shadow: 
        0 10px 30px rgba(76, 175, 80, 0.3),
        0 0 0 1px rgba(255,255,255,0.9) inset;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      color: #4CAF50;
      font-weight: bold;
    }
    
    .success-checkmark .check-icon::before {
      content: '✓';
      animation: checkmarkAppear 0.5s ease 0.3s forwards;
      opacity: 0;
      transform: scale(0.3) rotate(-45deg);
    }
    
    @keyframes checkmarkBounceIn {
      0% {
      opacity: 0;
        transform: scale(0.3);
      }
      50% {
        opacity: 1;
        transform: scale(1.1);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes checkmarkAppear {
      0% { 
        opacity: 0; 
        transform: scale(0.3) rotate(-45deg);
      }
      70% {
        opacity: 1;
        transform: scale(1.2) rotate(0deg);
      }
      100% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg);
      }
    }
    
    #success-display {
      text-align: center;
      margin-bottom: 20px;
      padding: 30px;
      background: linear-gradient(145deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
      border-radius: 20px;
      border: 2px solid rgba(76, 175, 80, 0.2);
      box-shadow: 0 10px 30px rgba(76, 175, 80, 0.15);
    }
    
    #success-display h2 {
      color: #4CAF50;
      margin-bottom: 15px;
      font-size: 2rem;
      font-weight: 700;
    }
    
    #success-display p {
      color: #2E7D32;
      font-size: 1.1rem;
      margin: 0;
    }
    
    @media (max-width: 600px) {
      .container {
        width: 92%;
        padding: 0;
      }
      
      .card {
        padding: 25px 20px;
      }
      
      h1 {
        font-size: 2rem;
        margin-bottom: 20px;
      }
      
      h2 {
        font-size: 1.5rem;
      }
      
      .clue-gallery img {
        max-width: 100%;
        margin-bottom: 15px;
      }
      
      .navigation-controls {
        flex-direction: column;
        gap: 10px;
      }
      
      .btn-nav {
        width: 100%;
      }
      
      input[type="text"], 
      input[type="email"] {
        padding: 12px 14px;
        font-size: 15px;
      }
      
      .btn {
        padding: 12px 20px;
        font-size: 15px;
      }
    }
    
    .answer-input:disabled {
      background: linear-gradient(145deg, #f5f5f5, #eeeeee);
      color: #666;
      cursor: not-allowed;
      border-color: #ddd;
    }
    
    .answer-input:disabled:hover,
    .answer-input:disabled:focus {
      background: linear-gradient(145deg, #f5f5f5, #eeeeee);
      border-color: #ddd;
      transform: none;
      box-shadow: none;
    }
    
    .puzzle-solved-indicator {
      display: inline-block;
      padding: 6px 12px;
      background: linear-gradient(135deg, #4CAF50, #66BB6A);
      color: white;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      margin-left: 15px;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Wedding Puzzle</h1>
    
    <div id="card" class="card">
      <div id="loading" class="loader"></div>
      
      <!-- Success message display -->
      <div id="success-display" class="hidden">
        <div class="success-checkmark">
          <div class="check-icon"></div>
        </div>
        <h2>Correct!</h2>
        <p id="success-message">Great job! Moving to the next puzzle...</p>
      </div>
      
      <!-- Screen 0: Name & Email Form -->
      <div id="screen-0" class="hidden">
        <h2>Welcome to the Wedding Puzzle!</h2>
        <p>Please enter your information to get started:</p>
        
        <div id="registration-error" class="error-message hidden">
          Error registering user. Please try again.
        </div>
        
        <form id="info-form">
          <div class="form-group">
            <label for="name">Your Name:</label>
            <input type="text" id="name" required>
          </div>
          
          <div class="form-group">
            <label for="email">Your Email:</label>
            <input type="email" id="email" required>
          </div>
          
          <button type="submit" class="btn">Start Puzzle</button>
        </form>
      </div>
      
      <!-- Welcome Back Screen -->
      <div id="screen-welcome-back" class="hidden">
        <h2>Welcome Back!</h2>
        <p id="welcome-back-message" class="welcome-message">It's great to see you again.</p>
        
        <button id="continue-btn" class="btn">Continue Your Progress</button>
        <button id="restart-from-beginning-btn" class="btn btn-secondary">Start from Beginning</button>
      </div>
      
      <!-- Screens 1-10: Puzzles -->
      <div id="screen-puzzle" class="hidden">
        <div class="navigation-controls">
          <button id="prev-puzzle-btn" class="btn btn-nav">← Previous</button>
          <div id="puzzle-nav" class="puzzle-nav-container">
            <!-- Puzzle navigation buttons will be inserted here -->
          </div>
        </div>
        
        <h2 id="puzzle-name">Puzzle #1</h2>
        
        <div id="puzzle-error" class="error-message hidden">
          Error loading puzzle. Please refresh the page to try again.
        </div>
        
        <div id="clue-container">
          <div id="clue-content" class="clue-content"></div>
          <div id="clue-gallery" class="clue-gallery hidden"></div>
        </div>
        
        <form id="answer-form">
          <div id="answers-container">
            <!-- Dynamic answer fields will be inserted here -->
          </div>
          
          <button type="submit" class="btn">Submit Answer</button>
        </form>
      </div>
      
      <!-- Screen 11: Completion -->
      <div id="screen-complete" class="hidden">
        <div id="ending-page-content">
          <!-- Custom ending page content will be loaded here -->
        </div>
        
        <button id="restart-btn" class="btn">Start Over</button>
      </div>
    </div>
  </div>
  
  <div id="hint-toast" class="hint-toast">Need a hint? Ask the puzzle master!</div>
  <div id="feedback-message" class="feedback-message"></div>
  
  <!-- Canvas for confetti -->
  <canvas id="confetti-canvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:99;"></canvas>
  
  <script>
    // Firebase database URL - Using only direct REST API
    const DB_URL = "https://eviltrivia-47664-default-rtdb.firebaseio.com";
    
    // DOM Elements
    const loading = document.getElementById('loading');
    const card = document.getElementById('card');
    const screen0 = document.getElementById('screen-0');
    const screenWelcomeBack = document.getElementById('screen-welcome-back');
    const screenPuzzle = document.getElementById('screen-puzzle');
    const screenComplete = document.getElementById('screen-complete');
    
    const infoForm = document.getElementById('info-form');
    const answerForm = document.getElementById('answer-form');
    const puzzleName = document.getElementById('puzzle-name');
    const clueText = document.getElementById('clue-text');
    const clueImage = document.getElementById('clue-image');
    const completionMessage = document.getElementById('completion-message');
    const endingPageContent = document.getElementById('ending-page-content');
    const restartBtn = document.getElementById('restart-btn');
    const hintToast = document.getElementById('hint-toast');
    const registrationError = document.getElementById('registration-error');
    const puzzleError = document.getElementById('puzzle-error');
    const welcomeBackMessage = document.getElementById('welcome-back-message');
    const continueBtn = document.getElementById('continue-btn');
    const restartFromBeginningBtn = document.getElementById('restart-from-beginning-btn');
    const prevPuzzleBtn = document.getElementById('prev-puzzle-btn');
    const nextPuzzleBtn = document.getElementById('next-puzzle-btn');
    const answersContainer = document.getElementById('answers-container');
    
    // Game state
    let currentScreen = 0;
    let totalPuzzles = 10; // Default
    let wrongAttempts = 0;
    let puzzleData = null;
    let userId = null;
    let userName = '';
    let userEmail = '';
    let solvedPuzzles = [];
    
    // Global variables to store custom messages
    let customSuccessMessages = {
      puzzleSolved: 'Correct! Moving to Puzzle {nextPuzzle}...',
      lastPuzzle: 'Congratulations! You\'ve solved all the puzzles!',
      allComplete: 'Amazing work! All puzzles completed!'
    };
    
    // Fetch custom success messages from database
    async function fetchSuccessMessages() {
      try {
        const paths = [
          `wedding/successMessages`,
          `publicAnswers/wedding/successMessages`
        ];
        
        for (const path of paths) {
          try {
            const response = await fetch(`${DB_URL}/${path}.json`);
            if (response.ok) {
              const data = await response.json();
              if (data) {
                customSuccessMessages = {
                  puzzleSolved: data.puzzleSolved || customSuccessMessages.puzzleSolved,
                  lastPuzzle: data.lastPuzzle || customSuccessMessages.lastPuzzle,
                  allComplete: data.allComplete || customSuccessMessages.allComplete
                };
                console.log('Loaded custom success messages:', customSuccessMessages);
                return;
              }
            }
          } catch (error) {
            console.error(`Error fetching success messages from ${path}:`, error);
          }
        }
      } catch (error) {
        console.warn('Could not load custom success messages:', error);
      }
    }
    
    // Show the loading spinner initially
    loading.style.display = 'block';
    
    // Generate a unique anonymous user ID if needed
    function getOrCreateUserId() {
      const storedId = localStorage.getItem('weddingPuzzleId');
      if (storedId) return storedId;
      
      // Generate a new anonymous ID - completely local, no Firebase auth
      const newId = 'anon_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('weddingPuzzleId', newId);
      return newId;
    }
    
    // Switch screens with animation
    function switchScreen(fromScreen, toScreen) {
      if (fromScreen) {
        // Animate exit of current screen
        fromScreen.classList.add('screen-exit');
        setTimeout(() => {
          fromScreen.classList.add('hidden');
          fromScreen.classList.remove('screen-exit');
          
          // Animate entrance of new screen
          toScreen.classList.remove('hidden');
          toScreen.classList.add('screen-transition');
          setTimeout(() => {
            toScreen.classList.remove('screen-transition');
          }, 600);
        }, 500);
      } else {
        // No previous screen, just show new screen
        toScreen.classList.remove('hidden');
        toScreen.classList.add('screen-transition');
        setTimeout(() => {
          toScreen.classList.remove('screen-transition');
        }, 600);
      }
    }
    
    // Initialize - Check for existing progress in localStorage
    document.addEventListener('DOMContentLoaded', async function() {
      // Ensure we have a user ID even for anonymous users
      userId = getOrCreateUserId();
      
      // Load total puzzles count first
      await loadTotalPuzzles();
      
      // Load custom success messages
      await fetchSuccessMessages();
      
      const storedName = localStorage.getItem('weddingPuzzleName');
      const storedEmail = localStorage.getItem('weddingPuzzleEmail');
      const storedScreen = localStorage.getItem('weddingPuzzleScreen');
      
      if (storedName && storedEmail && storedScreen) {
        // Restore saved state
        userName = storedName;
        userEmail = storedEmail;
        currentScreen = parseInt(storedScreen);
        
        // Check if this is a fresh page load (not a form submission)
        const isPageRefresh = !document.referrer || (document.referrer && document.referrer.split('?')[0] === window.location.href.split('?')[0]);
        
        if (isPageRefresh && currentScreen > 0) {
          // Load solved puzzles before showing welcome back
          await loadSolvedPuzzles();
          // Show welcome back screen
          showWelcomeBack();
        } else if (currentScreen >= 1 && currentScreen <= totalPuzzles) {
          // Load solved puzzles before continuing with puzzle
          await loadSolvedPuzzles();
          // Continue with a puzzle
          loadPuzzle(currentScreen);
        } else if (currentScreen > totalPuzzles) {
          // Load solved puzzles before showing completion
          await loadSolvedPuzzles();
          // Show completion screen instead of trying to load non-existent puzzle
          console.log(`📊 Requested puzzle ${currentScreen} is beyond totalPuzzles (${totalPuzzles}), going to completion`);
          showCompletion();
        } else {
          // Default to registration
          showScreen0();
        }
      } else {
        // No saved state, show registration
        showScreen0();
      }
    });
    
    // Load the total number of puzzles from the database
    async function loadTotalPuzzles() {
      try {
        // Try primary path
        let response = await fetch(`${DB_URL}/wedding/totalPuzzles.json`);
        
        // If primary failed, try backup path
        if (!response || !response.ok) {
          response = await fetch(`${DB_URL}/publicAnswers/wedding/totalPuzzles.json`);
        }
        
        if (response && response.ok) {
          const count = await response.json();
          if (count && !isNaN(count)) {
            totalPuzzles = count;
            console.log(`📊 Loaded totalPuzzles from database: ${totalPuzzles}`);
          }
        }
        
        console.log(`📊 Final totalPuzzles: ${totalPuzzles}`);
      } catch (error) {
        console.warn('Could not load total puzzles count, using default:', error);
      }
    }
    
    // Load the solved puzzles array from localStorage AND database
    async function loadSolvedPuzzles() {
      try {
        // Try to fetch progress from database first
        const result = await fetchUserProgressFromDatabase();
        
        if (result.data && result.data.solved && Array.isArray(result.data.solved)) {
          solvedPuzzles = [...result.data.solved]; // Create a copy
          
          // Load user answers from database
          if (result.data.userAnswers && typeof result.data.userAnswers === 'object') {
            window.userCorrectAnswers = { ...result.data.userAnswers }; // Create a copy
            console.log('📥 Loaded user answers from database:', window.userCorrectAnswers);
            
            // Verify the data structure
            Object.keys(window.userCorrectAnswers).forEach(puzzleNum => {
              const answers = window.userCorrectAnswers[puzzleNum];
              if (!Array.isArray(answers)) {
                console.warn(`⚠ Puzzle ${puzzleNum} answers are not an array:`, answers);
              } else {
                console.log(`✓ Puzzle ${puzzleNum} has ${answers.length} answers:`, answers);
              }
            });
          } else {
            window.userCorrectAnswers = {};
            console.log('📥 No user answers found in database');
          }
          
          // Update localStorage to match database
          const localProgress = {
            solved: [...solvedPuzzles],
            userAnswers: { ...window.userCorrectAnswers },
            currentScreen: result.data.currentScreen || currentScreen,
            name: result.data.name || userName,
            email: result.data.email || userEmail,
            timestamp: new Date().toISOString()
          };
          localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
          
          console.log('📥 Loaded progress from database:', { 
            solved: solvedPuzzles, 
            currentScreen: result.data.currentScreen,
            userAnswersCount: Object.keys(window.userCorrectAnswers).length 
          });
          return;
        }
      } catch (error) {
        console.warn('Could not load progress from database:', error);
      }
      
      // Fallback to localStorage if database unavailable
      const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
      if (localProgress.solved && Array.isArray(localProgress.solved)) {
        solvedPuzzles = [...localProgress.solved];
      } else {
        // Initialize with default
        solvedPuzzles = Array(totalPuzzles + 1).fill(false);
      }
      
      // Also load user's correct answers for pre-filling
      if (localProgress.userAnswers && typeof localProgress.userAnswers === 'object') {
        window.userCorrectAnswers = { ...localProgress.userAnswers };
        console.log('📥 Loaded user answers from localStorage:', window.userCorrectAnswers);
      } else {
        window.userCorrectAnswers = {};
        console.log('📥 No user answers found in localStorage');
      }
      
      console.log('📥 Loaded progress from localStorage:', { solved: solvedPuzzles });
    }
    
    // Fetch user progress from database
    async function fetchUserProgressFromDatabase() {
      if (!userId) return { data: null, path: null };
      
      const paths = [
        `wedding/progress/${userId}`,
        `publicAnswers/wedding/progress/${userId}`
      ];
      
      for (const path of paths) {
        try {
          const response = await fetch(`${DB_URL}/${path}.json`);
          if (response.ok) {
            const data = await response.json();
            if (data) {
              return { data, path: path.split('/').slice(0, -2).join('/') };
            }
          }
        } catch (error) {
          console.error(`Error fetching from ${path}:`, error);
        }
      }
      return { data: null, path: null };
    }
    
    // Display registration screen
    function showScreen0() {
      loading.style.display = 'none';
      switchScreen(null, screen0);
      
      // Pre-fill if we have data
      if (userName) document.getElementById('name').value = userName;
      if (userEmail) document.getElementById('email').value = userEmail;
    }
    
    // Fetch the custom welcome back message from the database
    async function fetchWelcomeBackMessage() {
      try {
        // Try primary path
        let response = await fetch(`${DB_URL}/wedding/welcomeBackMessage.json`);
        
        // If primary failed, try backup path
        if (!response || !response.ok) {
          response = await fetch(`${DB_URL}/publicAnswers/wedding/welcomeBackMessage.json`);
        }
        
        if (response && response.ok) {
          const message = await response.json();
          if (message && typeof message === 'string') {
            return message;
          }
        }
        return null;
      } catch (error) {
        console.warn('Could not load welcome back message:', error);
        return null;
      }
    }
    
    // Display welcome back screen
    async function showWelcomeBack() {
      loading.style.display = 'none';
      
      // Refresh progress from database before showing welcome message
      await loadSolvedPuzzles();
      
      // Update current screen from database if available
      const result = await fetchUserProgressFromDatabase();
      if (result.data && result.data.currentScreen) {
        currentScreen = result.data.currentScreen;
        localStorage.setItem('weddingPuzzleScreen', currentScreen);
      }
      
      // Fetch custom welcome back message if available
      const customMessage = await fetchWelcomeBackMessage();
      if (customMessage) {
        // Replace {{name}} placeholder with actual user name
        welcomeBackMessage.innerHTML = customMessage.replace(/\{\{name\}\}/g, userName || 'there');
      } else {
        const solvedCount = solvedPuzzles.filter(Boolean).length;
        welcomeBackMessage.textContent = `Welcome back, ${userName}! You've solved ${solvedCount} puzzles and are currently on puzzle ${currentScreen} of ${totalPuzzles}.`;
      }
      
      switchScreen(null, screenWelcomeBack);
    }
    
    // Display puzzle screen
    async function loadPuzzle(puzzleNum) {
      try {
        // Don't show loading immediately - let's transition smoothly
        const isInitialLoad = loading.style.display === 'block';
        
        if (!isInitialLoad) {
          // Add exit animation to current content
          const currentContent = document.querySelector('#puzzle-name, #clue-container, #answer-form');
          if (currentContent) {
            document.getElementById('clue-container').classList.add('puzzle-content-exit');
            document.getElementById('answer-form').classList.add('puzzle-content-exit');
            await new Promise(resolve => setTimeout(resolve, 300)); // Wait for exit animation
          }
        }
        
        // Show loading with delay only if not initial load
        if (!isInitialLoad) {
          setTimeout(() => {
            if (loading.style.display !== 'none') {
        loading.style.display = 'block';
            }
          }, 200);
        } else {
          loading.style.display = 'block';
        }
        
        document.getElementById('success-display').classList.add('hidden');
        document.getElementById('answer-form').style.display = 'block';
        
        const currentlyVisibleScreen = 
          !screen0.classList.contains('hidden') ? screen0 :
          !screenWelcomeBack.classList.contains('hidden') ? screenWelcomeBack :
          !screenPuzzle.classList.contains('hidden') ? screenPuzzle :
          !screenComplete.classList.contains('hidden') ? screenComplete : null;
        
        // Only hide screens if this is a screen transition, not puzzle-to-puzzle
        if (currentlyVisibleScreen && currentlyVisibleScreen !== screenPuzzle) {
        screen0.classList.add('hidden');
        screenWelcomeBack.classList.add('hidden');
        screenPuzzle.classList.add('hidden');
        screenComplete.classList.add('hidden');
        }
        
        puzzleError.classList.add('hidden');
        
        // Load solved puzzles data FIRST and wait for completion
        await loadSolvedPuzzles();
        
        // Log the current state for this specific puzzle
        const puzzleIsSolved = solvedPuzzles[puzzleNum];
        const userAnswersForPuzzle = window.userCorrectAnswers[puzzleNum];
        
        console.log(`🎯 Loading puzzle ${puzzleNum} - State check:`, {
          puzzleIsSolved,
          userAnswersForPuzzle,
          userAnswersType: Array.isArray(userAnswersForPuzzle) ? 'array' : typeof userAnswersForPuzzle,
          allUserAnswers: window.userCorrectAnswers,
          solvedPuzzlesArray: solvedPuzzles
        });
        
        // Fetch puzzle data - try multiple paths with fallbacks
        let puzzleResponse = null;
        
        // First try primary path
        try {
          puzzleResponse = await fetch(`${DB_URL}/wedding/answers/${puzzleNum}.json`);
        } catch (error) {
          console.error('Error with primary puzzle path:', error);
        }
        
        // If primary failed, try backup path
        if (!puzzleResponse || !puzzleResponse.ok) {
          try {
            puzzleResponse = await fetch(`${DB_URL}/publicAnswers/wedding/${puzzleNum}.json`);
          } catch (error) {
            console.error('Error with backup puzzle path:', error);
          }
        }
        
        // Parse the data if we have a valid response
        if (puzzleResponse && puzzleResponse.ok) {
          puzzleData = await puzzleResponse.json();
        }
        
        // If no puzzle data and we're beyond totalPuzzles, go to completion
        if (!puzzleData && puzzleNum > totalPuzzles) {
          console.log(`📊 No puzzle data for puzzle ${puzzleNum}, going to completion`);
          currentScreen = totalPuzzles + 1;
          localStorage.setItem('weddingPuzzleScreen', currentScreen);
          showCompletion();
          return;
        }
        
        // Apply fallback content if needed
        if (!puzzleData) {
          puzzleData = {
            name: `Puzzle ${puzzleNum}`,
            clue: `Puzzle ${puzzleNum} - Unable to load data. Please try again later.`,
            clueHtml: '',
            imageUrls: [],
            answers: [{ 
              text: "answer",
              questionText: "Your Answer:"
            }],
            wrongAnswerMessage: "That's not right. Try again!"
          };
          puzzleError.classList.remove('hidden');
        }
        
        // Ensure puzzleData has the expected structure
        if (!puzzleData.answers) {
          // Convert old format to new format
          puzzleData.answers = [{
            text: puzzleData.answer || "answer",
            questionText: "Your Answer:"
          }];
          delete puzzleData.answer;
        }
        
        // Set default wrong answer message if not provided
        if (!puzzleData.wrongAnswerMessage) {
          puzzleData.wrongAnswerMessage = "That's not right. Try again!";
        }
        
        // Set default partial correct message if not provided
        if (!puzzleData.partialCorrectMessage) {
          puzzleData.partialCorrectMessage = "Some answers are wrong. Keep trying!";
        }
        
        // Convert single imageUrl to imageUrls array if needed
        if (puzzleData.imageUrl && !puzzleData.imageUrls) {
          puzzleData.imageUrls = puzzleData.imageUrl ? [puzzleData.imageUrl] : [];
        }
        
        // Prepare content for smooth transition
        const clueContainer = document.getElementById('clue-container');
        const answerForm = document.getElementById('answer-form');
        
        // Add enter classes
        clueContainer.classList.remove('puzzle-content-exit');
        answerForm.classList.remove('puzzle-content-exit');
        clueContainer.classList.add('puzzle-content-enter');
        answerForm.classList.add('puzzle-content-enter');
        
        // Update puzzle name or use default
        puzzleName.textContent = puzzleData.name || `Puzzle #${puzzleNum}`;
        
        // Display clue content - prefer HTML content if available
        const clueContent = document.getElementById('clue-content');
        if (puzzleData.clueHtml) {
          clueContent.innerHTML = puzzleData.clueHtml;
        } else {
          clueContent.textContent = puzzleData.clue || 'No clue provided';
        }
        
        // Handle images
        const clueGallery = document.getElementById('clue-gallery');
        if (puzzleData.imageUrls && puzzleData.imageUrls.length > 0) {
          // Clear gallery
          clueGallery.innerHTML = '';
          
          // Add all images
          puzzleData.imageUrls.forEach(url => {
            if (url && url.trim()) {
              const img = document.createElement('img');
              img.src = url.trim();
              img.alt = "Puzzle Clue";
              clueGallery.appendChild(img);
            }
          });
          
          clueGallery.classList.remove('hidden');
        } else {
          clueGallery.classList.add('hidden');
        }
        
        // Generate answer fields based on current solved state
        answersContainer.innerHTML = '';
        
        console.log(`🔧 Generating ${puzzleData.answers.length} answer fields for puzzle ${puzzleNum}`);
        
        puzzleData.answers.forEach((answer, index) => {
          const multiAnswerDiv = document.createElement('div');
          multiAnswerDiv.className = 'multi-answer-container';
          multiAnswerDiv.id = `answer-container-${index}`;
          
          const formGroup = document.createElement('div');
          formGroup.className = 'form-group';
          
          const label = document.createElement('label');
          label.setAttribute('for', `answer-${index}`);
          label.textContent = answer.questionText || `Answer ${index + 1}:`;
          
          const input = document.createElement('input');
          input.type = 'text';
          input.id = `answer-${index}`;
          input.className = 'answer-input';
          input.required = true;
          
          formGroup.appendChild(label);
          formGroup.appendChild(input);
          multiAnswerDiv.appendChild(formGroup);
          answersContainer.appendChild(multiAnswerDiv);
          
          // NOW check if this puzzle is already solved and pre-fill
          const puzzleIsSolved = solvedPuzzles[puzzleNum];
          
          console.log(`🔧 Processing answer field ${index} for puzzle ${puzzleNum}:`, {
            puzzleIsSolved,
            hasUserAnswers: !!(window.userCorrectAnswers && window.userCorrectAnswers[puzzleNum]),
            userAnswerAtIndex: window.userCorrectAnswers[puzzleNum] ? window.userCorrectAnswers[puzzleNum][index] : undefined
          });
          
          if (puzzleIsSolved) {
            console.log(`🔍 Puzzle ${puzzleNum} is marked as solved, attempting pre-fill for answer ${index}...`);
            
            // Pre-fill with user's actual correct answers if available
            const userAnswers = window.userCorrectAnswers && window.userCorrectAnswers[puzzleNum];
            
            if (userAnswers && Array.isArray(userAnswers) && index < userAnswers.length && userAnswers[index] !== undefined && userAnswers[index] !== null && userAnswers[index] !== '') {
              input.value = userAnswers[index];
              console.log(`✅ Pre-filled answer ${index} with user's answer: "${userAnswers[index]}"`);
            } else {
              // Fallback to expected answer if user's answer not stored
              input.value = answer.text || '';
              console.warn(`⚠️ No valid user answer found for puzzle ${puzzleNum} answer ${index}, using expected: "${answer.text}"`);
              console.warn(`   Debug info:`, {
                userAnswers: userAnswers,
                isArray: Array.isArray(userAnswers),
                length: userAnswers ? userAnswers.length : 'N/A',
                index: index,
                valueAtIndex: userAnswers ? userAnswers[index] : 'N/A'
              });
            }
            
            input.disabled = true;
            input.style.fontWeight = 'bold';
            input.style.color = '#2E7D32';
            input.style.backgroundColor = '#f1f8e9';
            multiAnswerDiv.classList.add('correct');
          } else {
            console.log(`🔧 Puzzle ${puzzleNum} is not solved, leaving answer ${index} editable`);
          }
        });
        
        // Update submit button based on puzzle status
        const submitBtn = document.querySelector('#answer-form button[type="submit"]');
        if (solvedPuzzles[puzzleNum]) {
          submitBtn.disabled = true;
          submitBtn.textContent = 'Puzzle Solved ✓';
          
          // Add solved indicator to puzzle name if not already there
          if (!document.querySelector('.puzzle-solved-indicator')) {
            const solvedIndicator = document.createElement('span');
            solvedIndicator.className = 'puzzle-solved-indicator';
            solvedIndicator.textContent = 'Solved ✓';
            puzzleName.appendChild(solvedIndicator);
          }
        } else {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Submit Answer';
          
          // Remove any existing solved indicator
          const existingIndicator = document.querySelector('.puzzle-solved-indicator');
          if (existingIndicator) {
            existingIndicator.remove();
          }
        }
        
        // Reset wrong attempts
        wrongAttempts = 0;
        
        // Update navigation buttons and puzzle navigation
        updateNavigation(puzzleNum);
        
        // Hide loading and show puzzle screen with smooth animation
        loading.style.display = 'none';
        
        // Show the screen if it's not already shown
        if (currentlyVisibleScreen !== screenPuzzle) {
        switchScreen(currentlyVisibleScreen, screenPuzzle);
        }
        
        // Activate enter animation
        setTimeout(() => {
          clueContainer.classList.remove('puzzle-content-enter');
          answerForm.classList.remove('puzzle-content-enter');
          clueContainer.classList.add('puzzle-content-enter-active');
          answerForm.classList.add('puzzle-content-enter-active');
        }, 50);
        
        // Clean up animation classes
        setTimeout(() => {
          clueContainer.classList.remove('puzzle-content-enter-active');
          answerForm.classList.remove('puzzle-content-enter-active');
        }, 850);
        
        // Focus first answer field
        const firstAnswerInput = document.querySelector('.answer-input');
        if (firstAnswerInput) {
          if (!solvedPuzzles[puzzleNum]) {
          firstAnswerInput.value = '';
          setTimeout(() => {
            firstAnswerInput.focus();
            }, isInitialLoad ? 600 : 400);
          }
        }
        
        // Add a delayed check to ensure pre-filling worked
        setTimeout(async () => {
          console.log('🕐 Delayed pre-fill verification...');
          const puzzleIsSolved = solvedPuzzles[puzzleNum];
          if (puzzleIsSolved) {
            const answerInputs = document.querySelectorAll('.answer-input');
            const emptyInputs = Array.from(answerInputs).filter(input => !input.value);
            
            if (emptyInputs.length > 0) {
              console.warn('⚠️ Found empty inputs in solved puzzle, forcing pre-fill...');
              await forcePrefill();
            } else {
              console.log('✅ All inputs properly filled');
            }
          }
        }, 1000);
        
      } catch (error) {
        console.error('Error loading puzzle:', error);
        // Show error and fallback content with smooth transition
        puzzleData = {
          name: `Puzzle ${puzzleNum}`,
          clue: `Puzzle ${puzzleNum} - Unable to load data. Please try again later.`,
          imageUrls: [],
          answers: [{
            text: "answer",
            questionText: "Your Answer:"
          }]
        };
        
        puzzleName.textContent = puzzleData.name;
        document.getElementById('clue-content').textContent = puzzleData.clue;
        document.getElementById('clue-gallery').classList.add('hidden');
        
        // Generate single answer field
        answersContainer.innerHTML = '';
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        
        const label = document.createElement('label');
        label.setAttribute('for', 'answer-0');
        label.textContent = 'Your Answer:';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.id = 'answer-0';
        input.className = 'answer-input';
        input.required = true;
        
        formGroup.appendChild(label);
        formGroup.appendChild(input);
        answersContainer.appendChild(formGroup);
        
        // Update navigation
        updateNavigation(puzzleNum);
        
        loading.style.display = 'none';
        switchScreen(null, screenPuzzle);
        puzzleError.classList.remove('hidden');
      }
    }
    
    // Update navigation buttons and puzzle navigation based on current puzzle and progress
    function updateNavigation(puzzleNum) {
      // Previous button is always visible except on first puzzle
      prevPuzzleBtn.classList.toggle('hidden', puzzleNum <= 1);
      
      // Update puzzle navigation buttons
      const puzzleNav = document.getElementById('puzzle-nav');
      puzzleNav.innerHTML = '';
      
      // Show all unlocked puzzles: all solved puzzles + the next available one
      for (let i = 1; i <= totalPuzzles; i++) {
        const isSolved = solvedPuzzles[i];
        const isNextAvailable = i === 1 || solvedPuzzles[i - 1]; // First puzzle or previous is solved
        
        // Show puzzle if it's solved OR if it's the next available puzzle
        if (isSolved || isNextAvailable) {
          const navBtn = document.createElement('button');
          
          // Base classes
          navBtn.className = 'btn btn-nav';
          
          // Add status classes
          if (i === puzzleNum) {
            navBtn.classList.add('current-puzzle');
          } else if (isSolved) {
            navBtn.classList.add('solved-puzzle');
          }
          
          navBtn.textContent = `${i}`;
          navBtn.style.minWidth = '50px';
          navBtn.style.padding = '10px 8px';
          
          navBtn.addEventListener('click', async () => {
            if (i !== puzzleNum) {
              // Refresh state from database before navigating
              await loadSolvedPuzzles();
              
              // Re-verify this puzzle is still available after database refresh
              const stillSolved = solvedPuzzles[i];
              const stillNextAvailable = i === 1 || solvedPuzzles[i - 1];
              
              if (stillSolved || stillNextAvailable) {
                currentScreen = i;
                localStorage.setItem('weddingPuzzleScreen', currentScreen);
              loadPuzzle(i);
              } else {
                console.warn(`Puzzle ${i} is no longer available`);
                showFeedback(`Puzzle ${i} is not available yet. Complete the previous puzzles first.`, 'error');
              }
            }
          });
          
          puzzleNav.appendChild(navBtn);
        }
      }
      
      console.log('Navigation updated:', {
        totalPuzzles,
        solvedPuzzles,
        currentPuzzle: puzzleNum,
        buttonsShown: puzzleNav.children.length
      });
    }
    
    // Fetch ending page content from database
    async function fetchEndingPageContent() {
      try {
        const paths = [
          `wedding/endingPageContent`,
          `publicAnswers/wedding/endingPageContent`
        ];
        
        for (const path of paths) {
          try {
            const response = await fetch(`${DB_URL}/${path}.json`);
            if (response.ok) {
              const data = await response.json();
              if (data && typeof data === 'string') {
                return data;
              }
            }
          } catch (error) {
            console.error(`Error fetching ending page content from ${path}:`, error);
          }
        }
        
        // Return default content if nothing found
        return '<h2>Congratulations!</h2><p>You\'ve completed all the puzzles!</p>';
      } catch (error) {
        console.warn('Could not load ending page content:', error);
        return '<h2>Congratulations!</h2><p>You\'ve completed all the puzzles!</p>';
      }
    }
    
    // Display completion screen
    async function showCompletion() {
      loading.style.display = 'none';
      
      const currentlyVisibleScreen = 
        !screen0.classList.contains('hidden') ? screen0 :
        !screenWelcomeBack.classList.contains('hidden') ? screenWelcomeBack :
        !screenPuzzle.classList.contains('hidden') ? screenPuzzle : null;
      
      // Load custom ending page content
      const endingContent = await fetchEndingPageContent();
      endingPageContent.innerHTML = endingContent;
      
      switchScreen(currentlyVisibleScreen, screenComplete);
      
      // Trigger confetti
      startConfetti();
    }
    
    // Registration form submission - completely rebuilt without any Firebase Auth
    infoForm.addEventListener('submit', function(e) {
      e.preventDefault();
      
      // Get user info
      userName = document.getElementById('name').value.trim();
      userEmail = document.getElementById('email').value.trim();
      
      if (!userName || !userEmail) {
        alert('Please enter both name and email.');
        return;
      }
      
      // Show loading
      loading.style.display = 'block';
      screen0.classList.add('hidden');
      registrationError.classList.add('hidden');
      
      // Generate unique ID locally (no Firebase auth)
      userId = 'anon_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('weddingPuzzleId', userId);
      
      // Set initial progress
      currentScreen = 1;
      
      // Save to localStorage first (most important)
      localStorage.setItem('weddingPuzzleName', userName);
      localStorage.setItem('weddingPuzzleEmail', userEmail);
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      
      // Initialize solved puzzles array
      solvedPuzzles = Array(totalPuzzles + 1).fill(false);
      
      // Initialize user correct answers
      window.userCorrectAnswers = {};
      
      // Debug function to reset progress (can be called from browser console)
      window.resetPuzzleProgress = function() {
        // Clear all local storage
        localStorage.removeItem('weddingPuzzleName');
        localStorage.removeItem('weddingPuzzleEmail');
        localStorage.removeItem('weddingPuzzleScreen');
        localStorage.removeItem('weddingPuzzleLocalProgress');
        localStorage.removeItem('weddingPuzzleLocalAttempts');
        localStorage.removeItem('weddingPuzzleId');
        localStorage.removeItem('weddingPuzzleSuccessPath');
        
        // Reset in-memory state
        solvedPuzzles = Array(totalPuzzles + 1).fill(false);
        window.userCorrectAnswers = {};
        
        // Clear database if possible
        if (userId && successPath) {
          fetch(`${DB_URL}/${successPath}/${userId}.json`, {
            method: 'DELETE'
          }).then(() => {
            console.log('Database progress cleared');
          }).catch(err => {
            console.warn('Could not clear database:', err);
          });
        }
        
        console.log('Puzzle progress reset completely. Refresh the page to start over.');
      };
      
      // Debug function to view current progress
      window.viewProgress = async function() {
        await loadSolvedPuzzles();
        console.log('📊 Current progress:', {
          currentScreen,
          solvedPuzzles,
          userCorrectAnswers: window.userCorrectAnswers,
          userId,
          successPath
        });
        
        // Show detailed breakdown of each puzzle
        for (let i = 1; i <= totalPuzzles; i++) {
          console.log(`Puzzle ${i}:`, {
            solved: solvedPuzzles[i],
            userAnswers: window.userCorrectAnswers[i],
            answersType: Array.isArray(window.userCorrectAnswers[i]) ? 'array' : typeof window.userCorrectAnswers[i]
          });
        }
      };
      
      // Debug function to inspect specific puzzle
      window.inspectPuzzle = function(puzzleNum) {
        console.log(`🔍 Inspecting Puzzle ${puzzleNum}:`, {
          solved: solvedPuzzles[puzzleNum],
          userAnswers: window.userCorrectAnswers[puzzleNum],
          localStorage: JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}')
        });
      };
      
      // Debug function to unlock a specific puzzle (can be called from browser console)
      window.unlockPuzzle = function(puzzleNum) {
        if (puzzleNum > 1) {
          // Mark previous puzzle as solved to unlock this one
          solvedPuzzles[puzzleNum - 1] = true;
          const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
          localProgress.solved = solvedPuzzles;
          localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
          console.log(`Unlocked puzzle ${puzzleNum} by marking puzzle ${puzzleNum - 1} as solved`);
          location.reload();
        }
      };
      
      // Debug function to mark a puzzle as unsolved
      window.unsolveCurrentPuzzle = function() {
        solvedPuzzles[currentScreen] = false;
        if (window.userCorrectAnswers) {
          delete window.userCorrectAnswers[currentScreen];
        }
        const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
        localProgress.solved = solvedPuzzles;
        localProgress.userAnswers = window.userCorrectAnswers;
        localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
        console.log(`Marked puzzle ${currentScreen} as unsolved`);
        location.reload();
      };
      
      // Prepare progress data
      const progressData = {
        name: userName,
        email: userEmail,
        currentScreen: currentScreen,
        solved: solvedPuzzles,
        userAnswers: {},
        timestamp: new Date().toISOString()
      };
      
      // Store locally regardless of what happens with remote saves
      localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(progressData));
      
      // Try saving to primary DB path first, then fallback
      const attemptSave = async () => {
        try {
          // Try primary path
          const primaryResponse = await fetch(`${DB_URL}/wedding/progress/${userId}.json`, {
        method: 'PUT',
        body: JSON.stringify(progressData)
          });
          
          if (primaryResponse.ok) {
          localStorage.setItem('weddingPuzzleSuccessPath', 'wedding/progress');
            successPath = 'wedding/progress';
            console.log('Successfully saved to primary database path');
          return true;
        }
          
          // Try fallback path
          const fallbackResponse = await fetch(`${DB_URL}/publicAnswers/wedding/progress/${userId}.json`, {
          method: 'PUT',
          body: JSON.stringify(progressData)
        });
          
          if (fallbackResponse.ok) {
          localStorage.setItem('weddingPuzzleSuccessPath', 'publicAnswers/wedding/progress');
            successPath = 'publicAnswers/wedding/progress';
            console.log('Successfully saved to fallback database path');
            return true;
          }
          
          return false;
        } catch (error) {
        console.warn('Error saving progress to database:', error);
          return false;
        }
      };
      
      // Attempt save and then load first puzzle
      attemptSave().then((saveSuccessful) => {
        if (saveSuccessful) {
          console.log('User registration saved to database successfully');
        } else {
          console.warn('Could not save to database, continuing with localStorage only');
        }
        
        // Load first puzzle regardless of database save outcome
        loadPuzzle(currentScreen);
      });
    });
    
    // Welcome back buttons
    continueBtn.addEventListener('click', async function() {
      await loadSolvedPuzzles();
      loadPuzzle(currentScreen);
    });
    
    restartFromBeginningBtn.addEventListener('click', async function() {
      await loadSolvedPuzzles();
      currentScreen = 1;
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      loadPuzzle(currentScreen);
    });
    
    // Navigation buttons
    if (prevPuzzleBtn) {
      prevPuzzleBtn.addEventListener('click', function() {
        if (currentScreen > 1) {
          currentScreen--;
          localStorage.setItem('weddingPuzzleScreen', currentScreen);
          loadPuzzle(currentScreen);
        }
      });
    }
    
    if (nextPuzzleBtn) {
      nextPuzzleBtn.addEventListener('click', function() {
        if (currentScreen < totalPuzzles && solvedPuzzles[currentScreen]) {
          currentScreen++;
          localStorage.setItem('weddingPuzzleScreen', currentScreen);
          loadPuzzle(currentScreen);
        }
      });
    }
    
    // Show a feedback message
    function showFeedback(message, type) {
      const feedbackEl = document.getElementById('feedback-message');
      feedbackEl.textContent = message;
      feedbackEl.className = 'feedback-message ' + type;
      
      // Show the message
      setTimeout(() => {
        feedbackEl.classList.add('show');
        
        // Hide after 3 seconds
        setTimeout(() => {
          feedbackEl.classList.remove('show');
        }, 3000);
      }, 10);
    }
    
    // Show a success message and transition to the next screen after a delay
    function showSuccessAndTransition(message, nextFunction) {
      // Hide the answer form
      document.getElementById('answer-form').style.display = 'none';
      
      // Show success display
      const successDisplay = document.getElementById('success-display');
      const successMessage = document.getElementById('success-message');
      successMessage.textContent = message || 'Great job! Moving to the next puzzle...';
      successDisplay.classList.remove('hidden');
      
      // Show the checkmark with animation
      const checkmark = document.querySelector('.success-checkmark');
      if (checkmark) {
      checkmark.style.display = 'block';
        checkmark.classList.add('show');
        
        // Reset any previous animations
        setTimeout(() => {
          checkmark.style.animation = 'none';
          checkmark.offsetHeight; // Trigger reflow
          checkmark.style.animation = 'checkmarkBounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
        }, 50);
      }
      
      // Transition after delay
      setTimeout(() => {
        if (typeof nextFunction === 'function') {
          nextFunction();
        }
      }, 2000);
    }
    
    // Answer submission
    answerForm.addEventListener('submit', async (e) => {
      e.preventDefault(); // Prevent the default form submission
      
      // Check if this puzzle is already solved - prevent re-submission
      if (solvedPuzzles[currentScreen]) {
        console.log('Puzzle', currentScreen, 'marked as solved:', solvedPuzzles);
        console.log('User correct answers:', window.userCorrectAnswers);
        showFeedback('This puzzle is already solved!', 'info');
        return;
      }
      
      // Collect all answers
      const answerInputs = document.querySelectorAll('.answer-input');
      const answers = Array.from(answerInputs).map(input => input.value.trim());
      
      if (answers.some(a => !a)) {
        showFeedback('Please fill in all answer fields.', 'error');
        return;
      }
      
      try {
        // Check if all answers are correct
        let allCorrect = true;
        let correctAnswers = 0;
        
        // For each answer, check if it matches
        answers.forEach((answer, index) => {
          const expectedAnswer = puzzleData.answers[index]?.text || '';
          const isCorrect = answer.toLowerCase() === expectedAnswer.toLowerCase();
          
          // Mark the answer container as correct if it's right
          const answerContainer = document.getElementById(`answer-container-${index}`);
          if (answerContainer) {
            if (isCorrect) {
              answerContainer.classList.add('correct');
              answerContainer.classList.remove('incorrect');
              correctAnswers++;
            } else {
              answerContainer.classList.remove('correct');
              answerContainer.classList.add('incorrect');
              allCorrect = false;
            }
          }
        });
        
        // Track attempt in localStorage first
        const attemptData = {
          answers: answers,
          correct: allCorrect,
          timestamp: new Date().toISOString()
        };
        
        // Always store locally first
        const localAttempts = JSON.parse(localStorage.getItem('weddingPuzzleLocalAttempts') || '{}');
        if (!localAttempts[currentScreen]) localAttempts[currentScreen] = [];
        localAttempts[currentScreen].push(attemptData);
        localStorage.setItem('weddingPuzzleLocalAttempts', JSON.stringify(localAttempts));
        
        // Try to save attempt to database (non-blocking)
        const successPath = localStorage.getItem('weddingPuzzleSuccessPath');
        if (successPath === 'wedding/progress') {
          fetch(`${DB_URL}/wedding/attempts/${currentScreen}/${userId}.json`, {
            method: 'POST',
            body: JSON.stringify(attemptData)
          }).catch(err => console.warn('Could not save attempt to primary path:', err));
        } else if (successPath === 'publicAnswers/wedding/progress') {
          fetch(`${DB_URL}/publicAnswers/wedding/attempts/${currentScreen}/${userId}.json`, {
            method: 'POST',
            body: JSON.stringify(attemptData)
          }).catch(err => console.warn('Could not save attempt to fallback path:', err));
        }
        
        if (allCorrect) {
          // Mark current puzzle as solved
          solvedPuzzles[currentScreen] = true;
          
          // Store user's correct answers for pre-filling later
          if (!window.userCorrectAnswers) {
            window.userCorrectAnswers = {};
          }
          window.userCorrectAnswers[currentScreen] = [...answers]; // Create a copy of the answers array
          console.log(`✓ Storing user answers for puzzle ${currentScreen}:`, window.userCorrectAnswers[currentScreen]);
          
          // Determine what the next puzzle should be
          const justSolvedPuzzle = currentScreen;
          const nextPuzzle = currentScreen < totalPuzzles ? currentScreen + 1 : null;
          
          // Check if we just solved the last puzzle
          const isLastPuzzleSolved = justSolvedPuzzle === totalPuzzles;
          
          console.log(`📊 Completion check:`, {
            justSolvedPuzzle,
            totalPuzzles,
            nextPuzzle,
            isLastPuzzleSolved
          });
          
          // Update current screen to next puzzle if there is one, otherwise go to completion
          if (isLastPuzzleSolved) {
            currentScreen = totalPuzzles + 1; // Set to completion screen
            localStorage.setItem('weddingPuzzleScreen', currentScreen);
          } else if (nextPuzzle) {
            currentScreen = nextPuzzle;
            localStorage.setItem('weddingPuzzleScreen', currentScreen);
          }
          
          // Update solved status and user answers in localStorage immediately
          const localProgress = JSON.parse(localStorage.getItem('weddingPuzzleLocalProgress') || '{}');
          localProgress.solved = [...solvedPuzzles]; // Create a copy
          localProgress.userAnswers = { ...window.userCorrectAnswers }; // Create a copy
          localProgress.currentScreen = currentScreen;
          localStorage.setItem('weddingPuzzleLocalProgress', JSON.stringify(localProgress));
          console.log('✓ Updated localStorage with:', localProgress);
          
          // Try to update Firebase using the known successful path
          const updateData = {
            currentScreen: currentScreen,
            solved: [...solvedPuzzles], // Create a copy
            userAnswers: { ...window.userCorrectAnswers }, // Create a copy
            name: userName,
            email: userEmail,
            timestamp: new Date().toISOString()
          };
          
          console.log('📤 Saving to database:', updateData);
          
          // Save to database immediately and wait for confirmation
          const savePromise = new Promise((resolve) => {
          if (successPath === 'wedding/progress') {
            fetch(`${DB_URL}/wedding/progress/${userId}.json`, {
                method: 'PUT',
              body: JSON.stringify(updateData)
              }).then(response => {
                if (response.ok) {
                  console.log('Progress saved to database successfully');
                }
                resolve();
              }).catch(err => {
                console.warn('Could not update progress in primary path:', err);
                resolve();
              });
          } else if (successPath === 'publicAnswers/wedding/progress') {
            fetch(`${DB_URL}/publicAnswers/wedding/progress/${userId}.json`, {
                method: 'PUT',
              body: JSON.stringify(updateData)
              }).then(response => {
                if (response.ok) {
                  console.log('Progress saved to database successfully');
                }
                resolve();
              }).catch(err => {
                console.warn('Could not update progress in fallback path:', err);
                resolve();
              });
            } else {
              resolve();
            }
          });
          
          // Check if all puzzles completed
          const allPuzzlesSolved = solvedPuzzles.slice(1, totalPuzzles + 1).every(Boolean);
          
          if (isLastPuzzleSolved || allPuzzlesSolved) {
            // All puzzles completed - show completion
            showSuccessAndTransition(customSuccessMessages.allComplete, () => {
              savePromise.then(() => {
                showCompletion();
              });
            });
          } else if (nextPuzzle) {
            // Show success message and automatically move to next puzzle
            const message = customSuccessMessages.puzzleSolved.replace('{nextPuzzle}', nextPuzzle);
            showSuccessAndTransition(message, () => {
              // Wait for database save then load next puzzle
              savePromise.then(() => {
              loadPuzzle(nextPuzzle);
              });
            });
          } else {
            // Fallback case (shouldn't happen with current logic)
            showSuccessAndTransition(customSuccessMessages.lastPuzzle, () => {
              // Reset the success display
              document.getElementById('success-display').classList.add('hidden');
              document.getElementById('answer-form').style.display = 'block';
              const checkmark = document.querySelector('.success-checkmark');
              if (checkmark) {
                checkmark.style.display = 'none';
                checkmark.classList.remove('show');
              }
            });
          }
          
        } else {
          // Wrong answer
          wrongAttempts++;
          
          // Shake the card
          card.classList.add('card-shake');
          setTimeout(() => {
            card.classList.remove('card-shake');
          }, 500);
          
          // Show error feedback
          if (correctAnswers > 0) {
            showFeedback(puzzleData.partialCorrectMessage || "Some answers are wrong. Keep trying!", 'error');
          } else {
            showFeedback(puzzleData.wrongAnswerMessage || "That's not right. Try again!", 'error');
          }
          
          // Show hint after 3 wrong attempts
          if (wrongAttempts >= 3) {
            hintToast.classList.add('show');
            setTimeout(() => {
              hintToast.classList.remove('show');
            }, 5000);
          }
          
          // If some answers are correct, keep them highlighted
          if (correctAnswers > 0) {
            // Focus the first incorrect answer
            for (let i = 0; i < answerInputs.length; i++) {
              if (answers[i].toLowerCase() !== (puzzleData.answers[i]?.text || '').toLowerCase()) {
                answerInputs[i].focus();
                break;
              }
            }
          } else {
            // Clear all answer fields if none are correct
            answerInputs[0].focus();
          }
        }
        
      } catch (error) {
        console.error('Error processing answer:', error);
        showFeedback('There was a problem processing your answer. Please try again.', 'error');
      }
    });
    
    // Restart button
    restartBtn.addEventListener('click', () => {
      currentScreen = 1;
      localStorage.setItem('weddingPuzzleScreen', currentScreen);
      loadPuzzle(currentScreen);
    });
    
    // Confetti effect on completion
    function startConfetti() {
      const canvas = document.getElementById('confetti-canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      const pieces = [];
      const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', 
                     '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50',
                     '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', 
                     '#FFD700', '#FFA500', '#FF6347', '#FF4500', '#FF1493'];
      
      class Piece {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * -100;
          this.rotation = Math.random() * 360;
          this.size = Math.random() * 25 + 5; // Bigger pieces
          this.weight = Math.random() * 1 + 0.5; // Varied weights for natural movement
          this.speed = Math.random() * 6 + 2; // Faster movement
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.shape = Math.random() > 0.5 ? 'circle' : 'rect';
          this.opacity = Math.random() * 0.5 + 0.5; // Varied opacity
          this.rotationSpeed = (Math.random() - 0.5) * 5; // Some rotate clockwise, some counter-clockwise
        }
        
        update() {
          this.y += this.speed;
          this.x += Math.sin(this.y * this.weight * 0.01) * 2; // Wavy horizontal movement
          this.rotation += this.rotationSpeed;
          
          if (this.y > canvas.height) {
            this.y = Math.random() * -100;
            this.x = Math.random() * canvas.width;
          }
        }
        
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation * Math.PI / 180);
          ctx.globalAlpha = this.opacity;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          
          if (this.shape === 'circle') {
            ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
          } else {
            ctx.rect(-this.size / 2, -this.size / 2, this.size, this.size);
          }
          
          ctx.fill();
          ctx.restore();
        }
      }
      
      // Create more pieces
      for (let i = 0; i < 250; i++) {
        pieces.push(new Piece());
      }
      
      // Animation loop
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        pieces.forEach(piece => {
          piece.update();
          piece.draw();
        });
        
        requestAnimationFrame(animate);
      }
      
      animate();
    }
    
    // Debug function to manually force pre-filling for current puzzle
    window.forcePrefill = async function() {
      console.log('🔄 Forcing pre-fill check...');
      await loadSolvedPuzzles();
      
      const puzzleNum = currentScreen;
      const puzzleIsSolved = solvedPuzzles[puzzleNum];
      const userAnswers = window.userCorrectAnswers[puzzleNum];
      
      console.log(`🔄 Force pre-fill for puzzle ${puzzleNum}:`, {
        puzzleIsSolved,
        userAnswers,
        currentScreen,
        allSolvedPuzzles: solvedPuzzles,
        allUserAnswers: window.userCorrectAnswers
      });
      
      if (puzzleIsSolved && userAnswers && Array.isArray(userAnswers)) {
        const answerInputs = document.querySelectorAll('.answer-input');
        console.log(`🔄 Found ${answerInputs.length} answer inputs to fill`);
        
        answerInputs.forEach((input, index) => {
          if (index < userAnswers.length && userAnswers[index]) {
            input.value = userAnswers[index];
            input.disabled = true;
            input.style.fontWeight = 'bold';
            input.style.color = '#2E7D32';
            input.style.backgroundColor = '#f1f8e9';
            
            const container = input.closest('.multi-answer-container');
            if (container) {
              container.classList.add('correct');
            }
            
            console.log(`🔄 Force filled answer ${index}: "${userAnswers[index]}"`);
          }
        });
        
        // Also update submit button
        const submitBtn = document.querySelector('#answer-form button[type="submit"]');
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.textContent = 'PUZZLE SOLVED ✓';
        }
      } else {
        console.log('🔄 Cannot force pre-fill - puzzle not solved or no user answers');
      }
    };
    
    // Debug function to check what puzzle data exists in database
    window.checkDatabasePuzzles = async function() {
      console.log('🔍 Checking database for puzzle data...');
      
      const paths = [
        'wedding/answers',
        'publicAnswers/wedding'
      ];
      
      for (const path of paths) {
        try {
          const response = await fetch(`${DB_URL}/${path}.json`);
          if (response.ok) {
            const data = await response.json();
            console.log(`📊 Data from ${path}:`, data);
            
            if (data) {
              const puzzleNumbers = Object.keys(data).filter(key => !isNaN(parseInt(key))).map(Number).sort((a, b) => a - b);
              console.log(`📊 Found puzzles: ${puzzleNumbers.join(', ')}`);
              
              // Check specifically for puzzle 11
              if (data['11']) {
                console.warn('⚠️ Found puzzle 11 data:', data['11']);
              }
            }
          }
        } catch (error) {
          console.error(`❌ Error checking ${path}:`, error);
        }
      }
      
      // Also check totalPuzzles
      for (const basePath of ['wedding', 'publicAnswers/wedding']) {
        try {
          const response = await fetch(`${DB_URL}/${basePath}/totalPuzzles.json`);
          if (response.ok) {
            const count = await response.json();
            console.log(`📊 totalPuzzles from ${basePath}: ${count}`);
          }
        } catch (error) {
          console.log(`📊 No totalPuzzles found in ${basePath}`);
        }
      }
    };
    
    // Debug function to clean up puzzle 11
    window.cleanupPuzzle11 = async function() {
      console.log('🧹 Cleaning up puzzle 11 data...');
      
      const paths = [
        'wedding/answers/11',
        'publicAnswers/wedding/11'
      ];
      
      for (const path of paths) {
        try {
          const response = await fetch(`${DB_URL}/${path}.json`, {
            method: 'DELETE'
          });
          if (response.ok) {
            console.log(`✅ Deleted ${path}`);
          } else {
            console.log(`ℹ️ ${path} might not exist`);
          }
        } catch (error) {
          console.error(`❌ Error deleting ${path}:`, error);
        }
      }
      
      // Set totalPuzzles to 10
      for (const basePath of ['wedding', 'publicAnswers/wedding']) {
        try {
          const response = await fetch(`${DB_URL}/${basePath}/totalPuzzles.json`, {
            method: 'PUT',
            body: JSON.stringify(10)
          });
          if (response.ok) {
            console.log(`✅ Set totalPuzzles to 10 in ${basePath}`);
          }
        } catch (error) {
          console.error(`❌ Error setting totalPuzzles in ${basePath}:`, error);
        }
      }
      
      console.log('🧹 Cleanup complete! Refresh the page to test.');
    };
  </script>
</body>
</html> 