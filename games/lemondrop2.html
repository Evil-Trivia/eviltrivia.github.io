<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Evil Trivia - Lemon Drop 2</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    body {
      font-family: 'Press Start 2P', cursive;
      background: linear-gradient(180deg, #b7def8 0%, #7fc0f0 25%, #57a4d6 60%, #3f6f9b 100%);
      color: #0b2540;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      touch-action: manipulation;
      user-select: none;
      position: relative;
    }
    .container {
      width: 100%;
      max-width: 1100px;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .setup-screen {
      background: #8B4513;
      border: 4px solid #654321;
      padding: 30px;
      box-shadow: 8px 8px 0px rgba(0,0,0,0.5);
      margin-top: 20px;
    }
    .setup-screen.hidden {
      display: none;
    }
    .game-screen {
      display: none;
    }
    .game-screen.active {
      display: block;
    }
    .form-group {
      margin-bottom: 20px;
    }
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 10px;
      color: #FFD700;
      text-shadow: 2px 2px 0px #000;
    }
    .form-group input,
    .form-group select {
      width: 100%;
      padding: 12px;
      font-size: 12px;
      font-family: 'Press Start 2P', cursive;
      border: 3px solid #000;
      background: #F5DEB3;
      box-sizing: border-box;
    }
    .btn {
      padding: 15px 25px;
      background-color: #228B22;
      color: white;
      border: 3px solid #000;
      cursor: pointer;
      font-size: 12px;
      font-family: 'Press Start 2P', cursive;
      box-shadow: 4px 4px 0px #000;
      transition: all 0.1s;
      width: 100%;
      margin-top: 10px;
    }
    .btn:hover {
      background-color: #32CD32;
    }
    .btn:active {
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0px #000;
    }
    h1 {
      text-align: center;
      font-size: 26px;
      margin-bottom: 5px;
    }
    .subtitle {
      text-align: center;
      font-size: 9px;
      color: #1b3d5c;
      margin-bottom: 10px;
      line-height: 1.4;
    }
    .hud {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 10px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #000;
      padding: 10px;
      margin-bottom: 10px;
      font-size: 14px;
      text-transform: uppercase;
      color: #fff;
    }
    .hud span {
      color: #FFD700;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
    }
    .hud button {
      background: #ff9b42;
      border: 3px solid #0f1c2c;
      color: #0f1c2c;
      padding: 10px 16px;
      font-family: 'Press Start 2P', cursive;
      cursor: pointer;
      box-shadow: 3px 3px 0 #0f1c2c;
    }
    .hud button:active {
      transform: translate(2px, 2px);
      box-shadow: 1px 1px 0 #000;
    }
    canvas {
      width: 100%;
      border: 4px solid #0b2540;
      background: linear-gradient(180deg, #fdfdf3 0%, #cfeaa5 65%, #adce7c 85%, #7a5b34 100%);
      image-rendering: pixelated;
      box-shadow: 0 0 25px rgba(8, 23, 45, 0.4);
      flex-shrink: 0;
    }
    .game-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .game-over-screen {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #8B4513;
      border: 4px solid #654321;
      padding: 40px;
      box-shadow: 8px 8px 0px rgba(0,0,0,0.5);
      text-align: center;
      z-index: 2000;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }
    .game-over-screen.active {
      display: block;
    }
    .game-over-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1999;
    }
    .game-over-overlay.active {
      display: block;
    }
    .game-over-title {
      font-size: 24px;
      color: #FF4444;
      text-shadow: 3px 3px 0px #000;
      margin-bottom: 20px;
    }
    .game-over-score {
      font-size: 32px;
      color: #FFD700;
      text-shadow: 3px 3px 0px #000;
      margin: 20px 0;
    }
    .game-over-stats {
      margin: 20px 0;
      font-size: 12px;
      line-height: 2;
      color: #fff;
    }
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 140px;
      pointer-events: none;
      z-index: 1000;
    }
    .mobile-btn {
      position: absolute;
      background: rgba(255, 255, 255, 0.3);
      border: 3px solid rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      pointer-events: all;
      touch-action: none;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: rgba(0, 0, 0, 0.6);
      font-weight: bold;
    }
    .mobile-btn:active {
      background: rgba(255, 255, 255, 0.6);
    }
    .mobile-left {
      bottom: 20px;
      left: 20px;
      width: 85px;
      height: 85px;
    }
    .mobile-right {
      bottom: 20px;
      left: 115px;
      width: 85px;
      height: 85px;
    }
    .mobile-jump {
      bottom: 20px;
      right: 20px;
      width: 110px;
      height: 110px;
    }
    .rotate-prompt {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 9999;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      text-align: center;
      padding: 20px;
    }
    .rotate-prompt.show {
      display: flex;
    }
    .rotate-icon {
      font-size: 80px;
      margin-bottom: 20px;
      animation: rotate 2s ease-in-out infinite;
    }
    @keyframes rotate {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }
    .rotate-text {
      font-size: 16px;
      line-height: 1.8;
    }
    @media (max-width: 700px) and (orientation: portrait) {
      .rotate-prompt {
        display: flex;
      }
    }
    @media (max-width: 900px) and (orientation: landscape), (max-height: 600px) and (orientation: landscape) {
      body {
        padding: 0;
      }
      .container {
        max-width: 100%;
        width: 100%;
        padding: 5px;
      }
      h1 {
        font-size: 11px;
        margin-bottom: 2px;
      }
      .subtitle {
        font-size: 6px;
        margin-bottom: 3px;
      }
      .setup-screen {
        padding: 15px;
        margin-top: 5px;
      }
      .form-group {
        margin-bottom: 10px;
      }
      .form-group label {
        font-size: 8px;
        margin-bottom: 4px;
      }
      .form-group input,
      .form-group select {
        padding: 8px;
        font-size: 9px;
      }
      .btn {
        padding: 10px;
        font-size: 9px;
      }
      .hud {
        padding: 4px 8px;
        margin-bottom: 3px;
        font-size: 6px;
        gap: 5px;
      }
      .hud button {
        padding: 4px 8px;
        font-size: 6px;
      }
      canvas {
        height: calc(100vh - 60px) !important;
        border-width: 2px;
      }
      .mobile-controls {
        display: block;
        height: 60px;
      }
      .mobile-left, .mobile-right {
        width: 45px;
        height: 45px;
        bottom: 8px;
        font-size: 18px;
      }
      .mobile-right {
        left: 55px;
      }
      .mobile-jump {
        width: 55px;
        height: 55px;
        bottom: 3px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üçã LEMON DROP II üçã</h1>
    <div class="subtitle">
      Roll, bounce, and leap across an endless bar counter.<br>
      Arrow keys (or A/D) to roll ¬∑ Space to jump.
    </div>

    <!-- Setup Screen -->
    <div id="setupScreen" class="setup-screen">
      <div class="form-group">
        <label for="barLocation2">BAR LOCATION:</label>
        <select id="barLocation2" onchange="onLocationChange2()">
          <option value="">Select location...</option>
          <option value="St. Dymphna's">St. Dymphna's</option>
          <option value="Radegast Hall">Radegast Hall</option>
        </select>
      </div>

      <div class="form-group">
        <label for="teamSelect2">SELECT TEAM:</label>
        <select id="teamSelect2">
          <option value="">Loading teams...</option>
        </select>
      </div>
      
      <button class="btn" onclick="startGame2()">START GAME</button>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="game-screen">
      <div class="hud">
        <div>DISTANCE: <span id="distanceValue">0</span> M</div>
        <button id="regenBtn">NEW LAYOUT</button>
      </div>
      <canvas id="platformCanvas" width="960" height="540"></canvas>
    </div>

  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverOverlay" class="game-over-overlay"></div>
  
  <!-- Game Over Screen -->
  <div id="gameOverScreen" class="game-over-screen">
    <div class="game-over-title">GAME OVER!</div>
    <div class="game-over-score">DISTANCE: <span id="finalDistance">0</span> M</div>
    <div id="submissionMessage" style="margin: 15px 0; font-size: 12px; color: #32CD32; display: none;">
      ‚úì Score saved successfully!
    </div>
    <div id="scoreStats2" class="game-over-stats">
      <div>YOUR TEAM'S BEST: <span id="bestScoreDisplay2">Loading...</span></div>
    </div>
    <div style="display: flex; gap: 20px; justify-content: center; margin-top: 20px;">
      <button class="btn" onclick="playAgain2()">PLAY AGAIN</button>
      <button class="btn" onclick="backToSetup2()" style="background-color: #4169E1;">MAIN MENU</button>
    </div>
  </div>

  <div class="mobile-controls" id="mobileControls">
    <button class="mobile-btn mobile-left" id="mobileLeft">‚óÄ</button>
    <button class="mobile-btn mobile-right" id="mobileRight">‚ñ∂</button>
    <button class="mobile-btn mobile-jump" id="mobileJump">‚ñ≤</button>
  </div>

  <div class="rotate-prompt" id="rotatePrompt">
    <div class="rotate-icon">üì±‚û°Ô∏è</div>
    <div class="rotate-text">
      Please rotate your device<br>to landscape mode<br>for the best experience
    </div>
  </div>

  <!-- Firebase -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
    import { getDatabase, ref, push, set, get } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
        authDomain: "eviltrivia-47664.firebaseapp.com",
        databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
        projectId: "eviltrivia-47664",
        storageBucket: "eviltrivia-47664.firebaseapp.com",
        messagingSenderId: "401826818140",
        appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
        measurementId: "G-2W6RK96Y34"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    window.db = db;
    window.dbRef = ref;
    window.dbPush = push;
    window.dbSet = set;
    window.dbGet = get;
  </script>

  <script>
    const {
      Engine,
      Render,
      Runner,
      World,
      Bodies,
      Body,
      Events,
      Composite,
      Query
    } = Matter;

    const canvas = document.getElementById('platformCanvas');
    const distanceValue = document.getElementById('distanceValue');
    const regenBtn = document.getElementById('regenBtn');

    const MOVE_FORCE = 0.00022;
    const AIR_MOVE_FORCE = 0.00018;
    const MAX_MOVE_SPEED = 4.2;
    const AIR_DRAG = 0.005;
    const JUMP_FORCE = 0.055;
    const JUMP_HOLD_FORCE = 0.0011;
    const MAX_JUMP_HOLD_TICKS = 18;
    const CAMERA_LERP = 0.15;
    const JUMP_GROUND_BUFFER = 5;
    const ROLL_DAMPING = 0.07;
    const MAX_SPIN = 0.32;

    let engine, world, render, runner;
    let lemon;
    let platforms = [];
    let groundedContacts = 0;
    let levelWidth = 4000;
    let keys = {};
    let cameraTarget = { x: 0, y: 0 };
    let distanceTravelled = 0;
    let inputBound = false;
    let resizeHandler = null;
    let resizeTimeout = null;
    let jumpHoldTicks = 0;
    let lastPlatformX = 0;
    let touchLeft = false;
    let touchRight = false;
    let touchJump = false;
    let leftWall = null;
    let rightWall = null;
    let gameEnded = false;

    function initGame() {
      cleanup();
      distanceTravelled = 0;
      distanceValue.textContent = '0';
      engine = Engine.create();
      world = engine.world;
      world.gravity.y = 1.1;

      const width = canvas.clientWidth;
      const height = canvas.clientHeight;

      render = Render.create({
        canvas,
        engine,
        options: {
          width,
          height,
          background: 'transparent',
          wireframes: false,
          hasBounds: true,
          pixelRatio: window.devicePixelRatio || 1
        }
      });

      runner = Runner.create();

      createLevel(width, height);
      createPlayer(width, height);
      setupInput();
      setupEvents(width, height);

      Render.run(render);
      Runner.run(runner, engine);
      
      // Add custom text rendering
      Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        const messageX = 2000; // 100m mark
        const messageY = 200; // Higher up on screen
        
        // Check if message is in view
        if (messageX > render.bounds.min.x - 300 && messageX < render.bounds.max.x + 300) {
          ctx.save();
          ctx.font = 'bold 24px "Press Start 2P", cursive';
          ctx.fillStyle = '#FFD700';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 4;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          const lines = ['PLEASE RETURN', 'YOUR PEN AT', 'THE END OF TRIVIA'];
          lines.forEach((line, i) => {
            const y = messageY + (i * 35);
            ctx.strokeText(line, messageX, y);
            ctx.fillText(line, messageX, y);
          });
          
          ctx.restore();
        }
      });
    }

    function cleanup() {
      if (render) {
        Render.stop(render);
        render.canvas && render.canvas.getContext('2d').clearRect(0, 0, render.canvas.width, render.canvas.height);
        render.textures = {};
      }
      if (runner) {
        Runner.stop(runner);
      }
      if (engine) {
        Composite.clear(engine.world, false);
        Engine.clear(engine);
      }
      lemon = null;
      platforms = [];
      groundedContacts = 0;
      jumpHoldTicks = 0;
      leftWall = null;
      rightWall = null;
    }

    function createPlayer(width, height) {
      const targetSize = 45;
      const lemonVertices = getLemonVertices();
      const scale = targetSize / 1000;
      const scaledVertices = lemonVertices.map(v => ({
        x: v.x * scale,
        y: v.y * scale
      }));

      lemon = Bodies.fromVertices(
        100,
        height - 100,
        [scaledVertices],
        {
          density: 0.002,
          friction: 0.8,
          frictionStatic: 0.9,
          frictionAir: AIR_DRAG,
          restitution: 0.15,
          label: 'lemon',
          render: {
            sprite: {
              texture: '../images/lemon.png',
              xScale: scale,
              yScale: scale,
              yOffset: 0.03
            }
          }
        },
        true
      );

      World.add(world, lemon);
      cameraTarget.x = lemon.position.x;
      cameraTarget.y = lemon.position.y;
    }

    function createLevel(width, height) {
      platforms = [];
      const segmentCount = 28;
      const minWidth = 160;
      const maxWidth = 280;
      const baseY = height - 70;
      const startPlatform = createPenPlatform(140, baseY - 20, 260);
      platforms.push(startPlatform);
      
      let cursorX = startPlatform.bounds.max.x;
      let currentY = baseY;

      for (let i = 0; i < segmentCount; i++) {
        const platformWidth = minWidth + Math.random() * (maxWidth - minWidth);
        const gap = 80 + Math.random() * 140;
        cursorX += platformWidth / 2 + gap;

        const offset = (Math.random() - 0.5) * 160;
        currentY = clamp(currentY + offset, 160, baseY);

        const platform = createPenPlatform(cursorX, currentY, platformWidth);

        platforms.push(platform);
        cursorX += platformWidth / 2;
      }

      lastPlatformX = cursorX;
      levelWidth = cursorX + width * 2;

      leftWall = Bodies.rectangle(-200, height / 2, 400, height * 2, {
        isStatic: true,
        label: 'wall'
      });

      World.add(world, [leftWall, ...platforms]);
    }

    function createPenPlatform(x, y, width) {
      const penColors = ['#000000', '#0000FF', '#FF0000', '#000080', '#008000'];
      const color = penColors[Math.floor(Math.random() * penColors.length)];
      
      const penHeight = 14;
      
      // Main collision body with pen sprite
      const platform = Bodies.rectangle(x, y, width, penHeight, {
        isStatic: true,
        label: 'platform',
        friction: 0.95,
        render: {
          sprite: {
            texture: '../pen.png',
            xScale: width / 486,
            yScale: penHeight / 47
          }
        }
      });
      
      // Coyote time ledge - invisible extension on both sides
      const coyoteLedge = Bodies.rectangle(x, y, width + 10, penHeight, {
        isStatic: true,
        label: 'platform',
        friction: 0.95,
        isSensor: true,
        render: { visible: false }
      });
      
      const compound = Body.create({
        parts: [platform, coyoteLedge],
        isStatic: true,
        label: 'platform',
        friction: 0.95
      });
      
      return compound;
    }

    function extendLevel(viewWidth, viewHeight) {
      const minWidth = 160;
      const maxWidth = 280;
      const baseY = viewHeight - 70;
      const lastPlatform = platforms[platforms.length - 1];
      let cursorX = lastPlatformX;
      let currentY = lastPlatform ? lastPlatform.position.y : baseY;
      
      const newSegments = 15;
      for (let i = 0; i < newSegments; i++) {
        const platformWidth = minWidth + Math.random() * (maxWidth - minWidth);
        const gap = 80 + Math.random() * 140;
        cursorX += platformWidth / 2 + gap;

        const offset = (Math.random() - 0.5) * 160;
        currentY = clamp(currentY + offset, 160, baseY);

        const platform = createPenPlatform(cursorX, currentY, platformWidth);
        platforms.push(platform);
        World.add(world, platform);
        
        cursorX += platformWidth / 2;
      }
      
      lastPlatformX = cursorX;
      levelWidth = cursorX + viewWidth * 2;
    }

    function setupInput() {
      keys = {};
      if (inputBound) return;
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      inputBound = true;
    }

    function handleKeyDown(e) {
      const wasPressed = keys[e.code];
      keys[e.code] = true;
      if (!wasPressed && (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') && canJump()) {
        performJump();
      }
    }

    function handleKeyUp(e) {
      keys[e.code] = false;
    }

    function isJumpKeyActive() {
      return keys.Space || keys.ArrowUp || keys.KeyW;
    }

    function setupMobileControls() {
      const mobileLeft = document.getElementById('mobileLeft');
      const mobileRight = document.getElementById('mobileRight');
      const mobileJump = document.getElementById('mobileJump');

      if (mobileLeft) {
        mobileLeft.addEventListener('touchstart', (e) => {
          e.preventDefault();
          touchLeft = true;
        });
        mobileLeft.addEventListener('touchend', (e) => {
          e.preventDefault();
          touchLeft = false;
        });
      }

      if (mobileRight) {
        mobileRight.addEventListener('touchstart', (e) => {
          e.preventDefault();
          touchRight = true;
        });
        mobileRight.addEventListener('touchend', (e) => {
          e.preventDefault();
          touchRight = false;
        });
      }

      if (mobileJump) {
        let jumpPressed = false;
        mobileJump.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (!jumpPressed && canJump()) {
            performJump();
            jumpPressed = true;
          }
          touchJump = true;
        });
        mobileJump.addEventListener('touchend', (e) => {
          e.preventDefault();
          touchJump = false;
          jumpPressed = false;
        });
      }
    }

    function setupEvents(viewWidth, viewHeight) {
      Events.on(engine, 'beforeUpdate', () => {
        if (!lemon) return;
        let direction = 0;
        if (keys.ArrowLeft || keys.KeyA || touchLeft) direction -= 1;
        if (keys.ArrowRight || keys.KeyD || touchRight) direction += 1;

        const isGrounded = groundedContacts > 0;
        const moveForce = isGrounded ? MOVE_FORCE : AIR_MOVE_FORCE;

        if (direction !== 0) {
          Body.applyForce(lemon, lemon.position, {
            x: direction * moveForce,
            y: 0
          });
          if (isGrounded) {
            Body.setAngularVelocity(lemon, lemon.angularVelocity + direction * 0.02);
          }
        } else if (Math.abs(lemon.velocity.x) > 0.01 && isGrounded) {
          const dampingFactor = 1 - ROLL_DAMPING;
          Body.setVelocity(lemon, {
            x: lemon.velocity.x * dampingFactor,
            y: lemon.velocity.y
          });
        }

        if (Math.abs(lemon.velocity.x) > MAX_MOVE_SPEED) {
          Body.setVelocity(lemon, {
            x: Math.sign(lemon.velocity.x) * MAX_MOVE_SPEED,
            y: lemon.velocity.y
          });
        }

        if (Math.abs(lemon.angularVelocity) > MAX_SPIN) {
          Body.setAngularVelocity(lemon, Math.sign(lemon.angularVelocity) * MAX_SPIN);
        }

        if (jumpHoldTicks > 0) {
          if ((isJumpKeyActive() || touchJump) && lemon.velocity.y < 0) {
            Body.applyForce(lemon, lemon.position, { x: 0, y: -JUMP_HOLD_FORCE });
            jumpHoldTicks--;
          } else if ((!isJumpKeyActive() && !touchJump) || lemon.velocity.y >= 0) {
            jumpHoldTicks = 0;
          }
        }

        // Generate more platforms if approaching the end
        if (lemon.position.x > lastPlatformX - viewWidth * 2) {
          extendLevel(viewWidth, viewHeight);
        }
      });

      Events.on(engine, 'afterUpdate', () => {
        if (!lemon) return;
        updateCamera(viewWidth, viewHeight);
        distanceTravelled = Math.max(distanceTravelled, Math.floor(lemon.position.x / 20));
        distanceValue.textContent = distanceTravelled;

        // Use canvas height for consistent game over detection
        const currentHeight = canvas.height || viewHeight;
        if (lemon.position.y > currentHeight + 200) {
          gameOver2();
        }
      });

      Events.on(engine, 'collisionStart', event => adjustContacts(event.pairs, 1));
      Events.on(engine, 'collisionEnd', event => adjustContacts(event.pairs, -1));

      ensureResizeListener();
    }

    function adjustContacts(pairs, delta) {
      pairs.forEach(pair => {
        if (pair.bodyA === lemon || pair.bodyB === lemon) {
          const other = pair.bodyA === lemon ? pair.bodyB : pair.bodyA;
          if (!other.isStatic && other.label !== 'platform') return;

          const normal = pair.collision.normal;
          const touchingGround = (pair.bodyA === lemon && normal.y < -0.4) ||
                                 (pair.bodyB === lemon && normal.y > 0.4);
          if (touchingGround) {
            groundedContacts = Math.max(0, groundedContacts + delta);
            if (delta > 0) {
              jumpHoldTicks = 0;
            }
          }
        }
      });
    }

    function isNearGround() {
      if (!lemon || platforms.length === 0) return false;
      const footY = lemon.bounds.max.y;
      const start = { x: lemon.position.x, y: footY };
      const end = { x: lemon.position.x, y: footY + JUMP_GROUND_BUFFER };
      const hits = Query.ray(platforms, start, end);
      return hits.length > 0;
    }
    
    function canJump() {
      return groundedContacts > 0 || isNearGround();
    }

    function performJump() {
      if (!lemon) return;
      groundedContacts = 0;
      Body.setVelocity(lemon, { x: lemon.velocity.x, y: Math.min(lemon.velocity.y, -2) });
      Body.applyForce(lemon, {
        x: lemon.position.x,
        y: lemon.position.y + 10
      }, {
        x: 0,
        y: -JUMP_FORCE
      });
      jumpHoldTicks = MAX_JUMP_HOLD_TICKS;
    }

    async function gameOver2() {
      if (runner) Runner.stop(runner);
      
      const finalScore = distanceTravelled;
      document.getElementById('finalDistance').textContent = finalScore;
      
      // Show overlay and game over screen
      document.getElementById('gameOverOverlay').classList.add('active');
      document.getElementById('gameOverScreen').classList.add('active');
      
      // Submit score first, then load stats to show updated best
      await submitScore2(finalScore);
      
      // Wait a moment for Firebase to update, then load stats
      setTimeout(() => {
        loadScoreStats2();
      }, 500);
    }

    function playAgain2() {
      document.getElementById('gameOverOverlay').classList.remove('active');
      document.getElementById('gameOverScreen').classList.remove('active');
      document.getElementById('submissionMessage').style.display = 'none';
      distanceTravelled = 0;
      initGame();
    }

    function backToSetup2() {
      document.getElementById('gameOverOverlay').classList.remove('active');
      document.getElementById('gameOverScreen').classList.remove('active');
      document.getElementById('gameScreen').classList.remove('active');
      document.getElementById('setupScreen').classList.remove('hidden');
      document.getElementById('submissionMessage').style.display = 'none';
      
      // Show title and subtitle again
      const title = document.querySelector('h1');
      const subtitle = document.querySelector('.subtitle');
      if (title) title.style.display = 'block';
      if (subtitle) subtitle.style.display = 'block';
      
      cleanup();
    }

    async function loadScoreStats2() {
      try {
        const currentTeam = window.currentTeamName;
        
        if (!currentTeam) {
          document.getElementById('bestScoreDisplay2').textContent = 'No team selected';
          return;
        }
        
        // Wait for Firebase to be ready
        if (!window.dbGet || !window.dbRef) {
          setTimeout(() => loadScoreStats2(), 200);
          return;
        }
        
        document.getElementById('bestScoreDisplay2').textContent = 'Loading...';
        
        const scores = [];
        
        const mainSnap = await window.dbGet(window.dbRef(window.db, 'games/lemondrop2/answers'));
        if (mainSnap.exists()) {
          Object.values(mainSnap.val()).forEach(s => scores.push(s));
        }
        
        const publicSnap = await window.dbGet(window.dbRef(window.db, 'publicAnswers/lemondrop2'));
        if (publicSnap.exists()) {
          Object.values(publicSnap.val()).forEach(s => scores.push(s));
        }
        
        if (scores.length === 0) {
          document.getElementById('bestScoreDisplay2').textContent = 'No scores yet';
          return;
        }
        
        // Filter scores for current team
        const teamScores = scores.filter(s => s.teamName === currentTeam);
        
        if (teamScores.length === 0) {
          document.getElementById('bestScoreDisplay2').textContent = 'First score for your team!';
        } else {
          const bestScore = Math.max(...teamScores.map(s => s.score || 0));
          document.getElementById('bestScoreDisplay2').textContent = `${bestScore}m`;
        }
        
      } catch (error) {
        console.error('Error loading score stats:', error);
        document.getElementById('bestScoreDisplay2').textContent = 'Error loading';
      }
    }

    function resetPlayer(viewWidth, viewHeight) {
      if (!lemon) return;
      Body.setPosition(lemon, { x: 80, y: viewHeight - 120 });
      Body.setVelocity(lemon, { x: 0, y: 0 });
      Body.setAngularVelocity(lemon, 0);
      distanceTravelled = 0;
      jumpHoldTicks = 0;
    }

    function updateCamera(viewWidth, viewHeight) {
      const marginX = viewWidth * 0.3;
      const marginY = viewHeight * 0.4;
      const minX = render.bounds.min.x + marginX;
      const maxX = render.bounds.max.x - marginX;

      let targetX = cameraTarget.x;
      if (lemon.position.x < minX || lemon.position.x > maxX) {
        targetX = lemon.position.x;
      } else {
        targetX = lerp(cameraTarget.x, lemon.position.x, CAMERA_LERP);
      }

      const targetY = lerp(cameraTarget.y, lemon.position.y, CAMERA_LERP);

      cameraTarget.x = clamp(targetX, viewWidth / 2, levelWidth - viewWidth / 2);
      cameraTarget.y = clamp(targetY, viewHeight / 2, viewHeight * 1.5);

      const halfW = viewWidth / 2;
      const halfH = viewHeight / 2;

      render.bounds.min.x = cameraTarget.x - halfW;
      render.bounds.max.x = cameraTarget.x + halfW;
      render.bounds.min.y = cameraTarget.y - halfH;
      render.bounds.max.y = cameraTarget.y + halfH;

      Render.lookAt(render, render.bounds);
    }

    function getLemonVertices() {
      return [
        { x: 0, y: -490 }, { x: 50, y: -485 }, { x: 100, y: -475 },
        { x: 150, y: -460 }, { x: 200, y: -440 }, { x: 250, y: -415 },
        { x: 300, y: -380 }, { x: 345, y: -340 }, { x: 385, y: -295 },
        { x: 420, y: -245 }, { x: 445, y: -190 }, { x: 465, y: -130 },
        { x: 478, y: -65 }, { x: 485, y: 0 }, { x: 485, y: 65 },
        { x: 478, y: 130 }, { x: 465, y: 190 }, { x: 445, y: 245 },
        { x: 420, y: 295 }, { x: 385, y: 340 }, { x: 345, y: 380 },
        { x: 300, y: 415 }, { x: 250, y: 440 }, { x: 200, y: 460 },
        { x: 150, y: 475 }, { x: 100, y: 485 }, { x: 50, y: 490 },
        { x: 0, y: 492 }, { x: -50, y: 490 }, { x: -100, y: 485 },
        { x: -150, y: 475 }, { x: -200, y: 460 }, { x: -250, y: 440 },
        { x: -300, y: 415 }, { x: -345, y: 380 }, { x: -385, y: 340 },
        { x: -420, y: 295 }, { x: -445, y: 245 }, { x: -465, y: 190 },
        { x: -478, y: 130 }, { x: -485, y: 65 }, { x: -490, y: 0 },
        { x: -485, y: -65 }, { x: -478, y: -130 }, { x: -465, y: -190 },
        { x: -445, y: -245 }, { x: -420, y: -295 }, { x: -385, y: -340 },
        { x: -345, y: -380 }, { x: -300, y: -415 }, { x: -250, y: -440 },
        { x: -200, y: -460 }, { x: -150, y: -475 }, { x: -100, y: -485 },
        { x: -50, y: -490 }
      ];
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function lerp(start, end, t) {
      return start + (end - start) * t;
    }

    function ensureResizeListener() {
      if (resizeHandler) return;
      resizeHandler = () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (render) {
            Render.stop(render);
          }
          initGame();
        }, 250);
      };
      window.addEventListener('resize', resizeHandler);
    }

    async function onLocationChange2() {
      const location = document.getElementById('barLocation2').value;
      const teamSelect = document.getElementById('teamSelect2');
      
      if (!location) {
        teamSelect.innerHTML = '<option value="">Select location first</option>';
        return;
      }
      
      await loadTeamsForLocation2(location);
    }

    async function loadTeamsForLocation2(location) {
      try {
        const teamSelect = document.getElementById('teamSelect2');
        teamSelect.innerHTML = '<option value="">Loading...</option>';
        
        // Load teams for this specific location from active sessions
        const activeSessionsSnap = await window.dbGet(window.dbRef(window.db, 'games/lemondrop/activeSessions'));
        
        if (!activeSessionsSnap.exists()) {
          teamSelect.innerHTML = '<option value="">No active sessions - contact admin</option>';
          return;
        }
        
        const activeSessions = activeSessionsSnap.val();
        
        // Find session by matching the location field (not the key)
        let sessionData = null;
        for (const key in activeSessions) {
          if (activeSessions[key].location === location) {
            sessionData = activeSessions[key];
            break;
          }
        }
        
        if (!sessionData || !sessionData.teams || sessionData.teams.length === 0) {
          teamSelect.innerHTML = '<option value="">No active session for this location</option>';
          return;
        }
        
        // Populate with teams from this location only
        teamSelect.innerHTML = '<option value="">Select your team...</option>';
        sessionData.teams.sort().forEach(teamName => {
          const option = document.createElement('option');
          option.value = teamName;
          option.textContent = teamName;
          teamSelect.appendChild(option);
        });
        
      } catch (error) {
        console.error('Error loading teams:', error);
        document.getElementById('teamSelect2').innerHTML = '<option value="">Error loading teams</option>';
      }
    }

    function startGame2() {
      const teamName = document.getElementById('teamSelect2').value;
      const barLocation = document.getElementById('barLocation2').value;
      
      if (!teamName || !barLocation) {
        alert('Please select team name and bar location.');
        return;
      }
      
      // Store for score submission
      window.currentTeamName = teamName;
      window.currentBarLocation = barLocation;
      
      // Hide setup and header, show game
      document.getElementById('setupScreen').classList.add('hidden');
      document.getElementById('gameScreen').classList.add('active');
      
      // Hide title and subtitle to maximize game space
      const title = document.querySelector('h1');
      const subtitle = document.querySelector('.subtitle');
      if (title) title.style.display = 'none';
      if (subtitle) subtitle.style.display = 'none';
      
      initGame();
    }

    async function submitScore2(score) {
      const teamName = window.currentTeamName;
      const barLocation = window.currentBarLocation;
      
      if (!teamName || !barLocation) {
        console.error('Missing team name or location');
        return;
      }
      
      const scoreData = {
        teamName: teamName,
        barLocation: barLocation,
        score: score,
        timestamp: Date.now(),
        date: new Date().toISOString().split('T')[0]
      };
      
      try {
        const answersRef = window.dbRef(window.db, 'games/lemondrop2/answers');
        const newAnswerRef = window.dbPush(answersRef);
        await window.dbSet(newAnswerRef, scoreData);
        console.log('Score submitted successfully to main path');
        document.getElementById('submissionMessage').style.display = 'block';
      } catch (error) {
        console.error('Error submitting to main path:', error);
        
        try {
          const publicAnswersRef = window.dbRef(window.db, 'publicAnswers/lemondrop2');
          const newAnswerRef = window.dbPush(publicAnswersRef);
          await window.dbSet(newAnswerRef, scoreData);
          console.log('Score submitted to fallback path');
          document.getElementById('submissionMessage').style.display = 'block';
        } catch (fallbackError) {
          console.error('Error submitting to fallback path:', fallbackError);
        }
      }
    }

    regenBtn.addEventListener('click', () => {
      initGame();
      distanceTravelled = 0;
    });

    setupMobileControls();
    window.addEventListener('beforeunload', cleanup);
    window.startGame2 = startGame2;
    window.onLocationChange2 = onLocationChange2;
    window.playAgain2 = playAgain2;
    window.backToSetup2 = backToSetup2;
  </script>
</body>
</html>

