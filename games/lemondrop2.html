<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Evil Trivia - Lemon Drop 2</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    body {
      font-family: 'Press Start 2P', cursive;
      background: linear-gradient(180deg, #b7def8 0%, #7fc0f0 25%, #57a4d6 60%, #3f6f9b 100%);
      color: #0b2540;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      touch-action: manipulation;
      user-select: none;
      position: relative;
    }
    .container {
      width: 100%;
      max-width: 1100px;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .setup-screen {
      background: #8B4513;
      border: 4px solid #654321;
      padding: 30px;
      box-shadow: 8px 8px 0px rgba(0,0,0,0.5);
      margin-top: 20px;
    }
    .setup-screen.hidden {
      display: none;
    }
    .game-screen {
      display: none;
    }
    .game-screen.active {
      display: block;
    }
    .form-group {
      margin-bottom: 20px;
    }
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 10px;
      color: #FFD700;
      text-shadow: 2px 2px 0px #000;
    }
    .form-group input,
    .form-group select {
      width: 100%;
      padding: 12px;
      font-size: 12px;
      font-family: 'Press Start 2P', cursive;
      border: 3px solid #000;
      background: #F5DEB3;
      box-sizing: border-box;
    }
    .btn {
      padding: 15px 25px;
      background-color: #228B22;
      color: white;
      border: 3px solid #000;
      cursor: pointer;
      font-size: 12px;
      font-family: 'Press Start 2P', cursive;
      box-shadow: 4px 4px 0px #000;
      transition: all 0.1s;
      width: 100%;
      margin-top: 10px;
    }
    .btn:hover {
      background-color: #32CD32;
    }
    .btn:active {
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0px #000;
    }
    h1 {
      text-align: center;
      font-size: 26px;
      margin-bottom: 10px;
      text-shadow: 4px 4px 0 #000;
    }
    .subtitle {
      text-align: center;
      font-size: 11px;
      color: #1b3d5c;
      text-shadow: 2px 2px 0 rgba(255,255,255,0.5);
      margin-bottom: 20px;
      line-height: 1.6;
    }
    .hud {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 10px;
      background: rgba(255, 255, 255, 0.7);
      border: 3px solid #1c3b65;
      padding: 15px;
      margin-bottom: 15px;
      font-size: 10px;
      text-transform: uppercase;
      color: #0b2540;
    }
    .hud span {
      color: #78ffb6;
    }
    .hud button {
      background: #ff9b42;
      border: 3px solid #0f1c2c;
      color: #0f1c2c;
      padding: 10px 16px;
      font-family: 'Press Start 2P', cursive;
      cursor: pointer;
      box-shadow: 3px 3px 0 #0f1c2c;
    }
    .hud button:active {
      transform: translate(2px, 2px);
      box-shadow: 1px 1px 0 #000;
    }
    canvas {
      width: 100%;
      border: 4px solid #0b2540;
      background: linear-gradient(180deg, #fdfdf3 0%, #cfeaa5 65%, #adce7c 85%, #7a5b34 100%);
      image-rendering: pixelated;
      box-shadow: 0 0 25px rgba(8, 23, 45, 0.4);
      flex-shrink: 0;
    }
    .game-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 140px;
      pointer-events: none;
      z-index: 1000;
    }
    .mobile-btn {
      position: absolute;
      background: rgba(255, 255, 255, 0.3);
      border: 3px solid rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      pointer-events: all;
      touch-action: none;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: rgba(0, 0, 0, 0.6);
      font-weight: bold;
    }
    .mobile-btn:active {
      background: rgba(255, 255, 255, 0.6);
    }
    .mobile-left {
      bottom: 20px;
      left: 20px;
      width: 70px;
      height: 70px;
    }
    .mobile-right {
      bottom: 20px;
      left: 100px;
      width: 70px;
      height: 70px;
    }
    .mobile-jump {
      bottom: 20px;
      right: 20px;
      width: 90px;
      height: 90px;
    }
    .rotate-prompt {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 9999;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      text-align: center;
      padding: 20px;
    }
    .rotate-prompt.show {
      display: flex;
    }
    .rotate-icon {
      font-size: 80px;
      margin-bottom: 20px;
      animation: rotate 2s ease-in-out infinite;
    }
    @keyframes rotate {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }
    .rotate-text {
      font-size: 16px;
      line-height: 1.8;
    }
    @media (max-width: 700px) and (orientation: portrait) {
      .rotate-prompt {
        display: flex;
      }
    }
    @media (max-width: 900px) and (orientation: landscape), (max-height: 600px) and (orientation: landscape) {
      body {
        padding: 0;
      }
      .container {
        max-width: 100%;
        width: 100%;
        padding: 5px;
      }
      h1 {
        font-size: 11px;
        margin-bottom: 2px;
      }
      .subtitle {
        font-size: 6px;
        margin-bottom: 3px;
      }
      .setup-screen {
        padding: 15px;
        margin-top: 5px;
      }
      .form-group {
        margin-bottom: 10px;
      }
      .form-group label {
        font-size: 8px;
        margin-bottom: 4px;
      }
      .form-group input,
      .form-group select {
        padding: 8px;
        font-size: 9px;
      }
      .btn {
        padding: 10px;
        font-size: 9px;
      }
      .hud {
        padding: 4px 8px;
        margin-bottom: 3px;
        font-size: 6px;
        gap: 5px;
      }
      .hud button {
        padding: 4px 8px;
        font-size: 6px;
      }
      canvas {
        height: calc(100vh - 60px) !important;
        border-width: 2px;
      }
      .mobile-controls {
        display: block;
        height: 60px;
      }
      .mobile-left, .mobile-right {
        width: 45px;
        height: 45px;
        bottom: 8px;
        font-size: 18px;
      }
      .mobile-right {
        left: 55px;
      }
      .mobile-jump {
        width: 55px;
        height: 55px;
        bottom: 3px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üçã LEMON DROP II üçã</h1>
    <div class="subtitle">
      Roll, bounce, and leap across an endless bar counter.<br>
      Arrow keys (or A/D) to roll ¬∑ Space to jump.
    </div>

    <!-- Setup Screen -->
    <div id="setupScreen" class="setup-screen">
      <div class="form-group">
        <label for="barLocation2">BAR LOCATION:</label>
        <select id="barLocation2" onchange="onLocationChange2()">
          <option value="">Select location...</option>
          <option value="St. Dymphna's">St. Dymphna's</option>
          <option value="Radegast Hall">Radegast Hall</option>
        </select>
      </div>

      <div class="form-group">
        <label for="teamSelect2">SELECT TEAM:</label>
        <select id="teamSelect2">
          <option value="">Loading teams...</option>
        </select>
      </div>
      
      <button class="btn" onclick="startGame2()">START GAME</button>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="game-screen">
      <div class="hud">
        <div>Distance: <span id="distanceValue">0</span> m</div>
        <div>Procedural level ¬∑ camera follows the lemon</div>
        <button id="regenBtn">NEW LAYOUT</button>
      </div>
      <canvas id="platformCanvas" width="960" height="540"></canvas>
    </div>
  </div>

  <div class="mobile-controls" id="mobileControls">
    <button class="mobile-btn mobile-left" id="mobileLeft">‚óÄ</button>
    <button class="mobile-btn mobile-right" id="mobileRight">‚ñ∂</button>
    <button class="mobile-btn mobile-jump" id="mobileJump">‚ñ≤</button>
  </div>

  <div class="rotate-prompt" id="rotatePrompt">
    <div class="rotate-icon">üì±‚û°Ô∏è</div>
    <div class="rotate-text">
      Please rotate your device<br>to landscape mode<br>for the best experience
    </div>
  </div>

  <!-- Firebase -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
    import { getDatabase, ref, push, set, get } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
        authDomain: "eviltrivia-47664.firebaseapp.com",
        databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
        projectId: "eviltrivia-47664",
        storageBucket: "eviltrivia-47664.firebaseapp.com",
        messagingSenderId: "401826818140",
        appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
        measurementId: "G-2W6RK96Y34"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    window.db = db;
    window.dbRef = ref;
    window.dbPush = push;
    window.dbSet = set;
    window.dbGet = get;
  </script>

  <script>
    const {
      Engine,
      Render,
      Runner,
      World,
      Bodies,
      Body,
      Events,
      Composite,
      Query
    } = Matter;

    const canvas = document.getElementById('platformCanvas');
    const distanceValue = document.getElementById('distanceValue');
    const regenBtn = document.getElementById('regenBtn');

    const MOVE_FORCE = 0.00022;
    const AIR_MOVE_FORCE = 0.00018;
    const MAX_MOVE_SPEED = 4.2;
    const AIR_DRAG = 0.005;
    const JUMP_FORCE = 0.055;
    const JUMP_HOLD_FORCE = 0.0011;
    const MAX_JUMP_HOLD_TICKS = 18;
    const CAMERA_LERP = 0.15;
    const JUMP_GROUND_BUFFER = 5;
    const ROLL_DAMPING = 0.07;
    const MAX_SPIN = 0.32;

    let engine, world, render, runner;
    let lemon;
    let platforms = [];
    let groundedContacts = 0;
    let levelWidth = 4000;
    let keys = {};
    let cameraTarget = { x: 0, y: 0 };
    let distanceTravelled = 0;
    let inputBound = false;
    let resizeHandler = null;
    let resizeTimeout = null;
    let jumpHoldTicks = 0;
    let lastPlatformX = 0;
    let touchLeft = false;
    let touchRight = false;
    let touchJump = false;
    let leftWall = null;
    let rightWall = null;

    function initGame() {
      cleanup();
      distanceTravelled = 0;
      distanceValue.textContent = '0';
      engine = Engine.create();
      world = engine.world;
      world.gravity.y = 1.1;

      const width = canvas.clientWidth;
      const height = canvas.clientHeight;

      render = Render.create({
        canvas,
        engine,
        options: {
          width,
          height,
          background: 'transparent',
          wireframes: false,
          hasBounds: true,
          pixelRatio: window.devicePixelRatio || 1
        }
      });

      runner = Runner.create();

      createLevel(width, height);
      createPlayer(width, height);
      setupInput();
      setupEvents(width, height);

      Render.run(render);
      Runner.run(runner, engine);
    }

    function cleanup() {
      if (render) {
        Render.stop(render);
        render.canvas && render.canvas.getContext('2d').clearRect(0, 0, render.canvas.width, render.canvas.height);
        render.textures = {};
      }
      if (runner) {
        Runner.stop(runner);
      }
      if (engine) {
        Composite.clear(engine.world, false);
        Engine.clear(engine);
      }
      lemon = null;
      platforms = [];
      groundedContacts = 0;
      jumpHoldTicks = 0;
      leftWall = null;
      rightWall = null;
    }

    function createPlayer(width, height) {
      const targetSize = 45;
      const lemonVertices = getLemonVertices();
      const scale = targetSize / 1000;
      const scaledVertices = lemonVertices.map(v => ({
        x: v.x * scale,
        y: v.y * scale
      }));

      lemon = Bodies.fromVertices(
        100,
        height - 100,
        [scaledVertices],
        {
          density: 0.002,
          friction: 0.8,
          frictionStatic: 0.9,
          frictionAir: AIR_DRAG,
          restitution: 0.15,
          label: 'lemon',
          render: {
            sprite: {
              texture: '../images/lemon.png',
              xScale: scale,
              yScale: scale,
              yOffset: 0.03
            }
          }
        },
        true
      );

      World.add(world, lemon);
      cameraTarget.x = lemon.position.x;
      cameraTarget.y = lemon.position.y;
    }

    function createLevel(width, height) {
      platforms = [];
      const segmentCount = 28;
      const minWidth = 160;
      const maxWidth = 280;
      const baseY = height - 70;
      const startPlatform = createPenPlatform(140, baseY - 20, 260);
      platforms.push(startPlatform);
      
      let cursorX = startPlatform.bounds.max.x;
      let currentY = baseY;

      for (let i = 0; i < segmentCount; i++) {
        const platformWidth = minWidth + Math.random() * (maxWidth - minWidth);
        const gap = 80 + Math.random() * 140;
        cursorX += platformWidth / 2 + gap;

        const offset = (Math.random() - 0.5) * 160;
        currentY = clamp(currentY + offset, 160, baseY);

        const platform = createPenPlatform(cursorX, currentY, platformWidth);

        platforms.push(platform);
        cursorX += platformWidth / 2;
      }

      lastPlatformX = cursorX;
      levelWidth = cursorX + width * 2;

      leftWall = Bodies.rectangle(-200, height / 2, 400, height * 2, {
        isStatic: true,
        label: 'wall'
      });

      World.add(world, [leftWall, ...platforms]);
    }

    function createPenPlatform(x, y, width) {
      const penColors = ['#000000', '#0000FF', '#FF0000', '#000080', '#008000'];
      const color = penColors[Math.floor(Math.random() * penColors.length)];
      
      const penHeight = 14;
      
      // Main collision body with pen sprite
      const platform = Bodies.rectangle(x, y, width, penHeight, {
        isStatic: true,
        label: 'platform',
        friction: 0.95,
        render: {
          sprite: {
            texture: '../pen.png',
            xScale: width / 486,
            yScale: penHeight / 47
          }
        }
      });
      
      // Coyote time ledge - invisible extension on both sides
      const coyoteLedge = Bodies.rectangle(x, y, width + 10, penHeight, {
        isStatic: true,
        label: 'platform',
        friction: 0.95,
        isSensor: true,
        render: { visible: false }
      });
      
      const compound = Body.create({
        parts: [platform, coyoteLedge],
        isStatic: true,
        label: 'platform',
        friction: 0.95
      });
      
      return compound;
    }

    function extendLevel(viewWidth, viewHeight) {
      const minWidth = 160;
      const maxWidth = 280;
      const baseY = viewHeight - 70;
      const lastPlatform = platforms[platforms.length - 1];
      let cursorX = lastPlatformX;
      let currentY = lastPlatform ? lastPlatform.position.y : baseY;
      
      const newSegments = 15;
      for (let i = 0; i < newSegments; i++) {
        const platformWidth = minWidth + Math.random() * (maxWidth - minWidth);
        const gap = 80 + Math.random() * 140;
        cursorX += platformWidth / 2 + gap;

        const offset = (Math.random() - 0.5) * 160;
        currentY = clamp(currentY + offset, 160, baseY);

        const platform = createPenPlatform(cursorX, currentY, platformWidth);
        platforms.push(platform);
        World.add(world, platform);
        
        cursorX += platformWidth / 2;
      }
      
      lastPlatformX = cursorX;
      levelWidth = cursorX + viewWidth * 2;
    }

    function setupInput() {
      keys = {};
      if (inputBound) return;
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      inputBound = true;
    }

    function handleKeyDown(e) {
      const wasPressed = keys[e.code];
      keys[e.code] = true;
      if (!wasPressed && (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') && canJump()) {
        performJump();
      }
    }

    function handleKeyUp(e) {
      keys[e.code] = false;
    }

    function isJumpKeyActive() {
      return keys.Space || keys.ArrowUp || keys.KeyW;
    }

    function setupMobileControls() {
      const mobileLeft = document.getElementById('mobileLeft');
      const mobileRight = document.getElementById('mobileRight');
      const mobileJump = document.getElementById('mobileJump');

      if (mobileLeft) {
        mobileLeft.addEventListener('touchstart', (e) => {
          e.preventDefault();
          touchLeft = true;
        });
        mobileLeft.addEventListener('touchend', (e) => {
          e.preventDefault();
          touchLeft = false;
        });
      }

      if (mobileRight) {
        mobileRight.addEventListener('touchstart', (e) => {
          e.preventDefault();
          touchRight = true;
        });
        mobileRight.addEventListener('touchend', (e) => {
          e.preventDefault();
          touchRight = false;
        });
      }

      if (mobileJump) {
        let jumpPressed = false;
        mobileJump.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (!jumpPressed && canJump()) {
            performJump();
            jumpPressed = true;
          }
          touchJump = true;
        });
        mobileJump.addEventListener('touchend', (e) => {
          e.preventDefault();
          touchJump = false;
          jumpPressed = false;
        });
      }
    }

    function setupEvents(viewWidth, viewHeight) {
      Events.on(engine, 'beforeUpdate', () => {
        if (!lemon) return;
        let direction = 0;
        if (keys.ArrowLeft || keys.KeyA || touchLeft) direction -= 1;
        if (keys.ArrowRight || keys.KeyD || touchRight) direction += 1;

        const isGrounded = groundedContacts > 0;
        const moveForce = isGrounded ? MOVE_FORCE : AIR_MOVE_FORCE;

        if (direction !== 0) {
          Body.applyForce(lemon, lemon.position, {
            x: direction * moveForce,
            y: 0
          });
          if (isGrounded) {
            Body.setAngularVelocity(lemon, lemon.angularVelocity + direction * 0.02);
          }
        } else if (Math.abs(lemon.velocity.x) > 0.01 && isGrounded) {
          const dampingFactor = 1 - ROLL_DAMPING;
          Body.setVelocity(lemon, {
            x: lemon.velocity.x * dampingFactor,
            y: lemon.velocity.y
          });
        }

        if (Math.abs(lemon.velocity.x) > MAX_MOVE_SPEED) {
          Body.setVelocity(lemon, {
            x: Math.sign(lemon.velocity.x) * MAX_MOVE_SPEED,
            y: lemon.velocity.y
          });
        }

        if (Math.abs(lemon.angularVelocity) > MAX_SPIN) {
          Body.setAngularVelocity(lemon, Math.sign(lemon.angularVelocity) * MAX_SPIN);
        }

        if (jumpHoldTicks > 0) {
          if ((isJumpKeyActive() || touchJump) && lemon.velocity.y < 0) {
            Body.applyForce(lemon, lemon.position, { x: 0, y: -JUMP_HOLD_FORCE });
            jumpHoldTicks--;
          } else if ((!isJumpKeyActive() && !touchJump) || lemon.velocity.y >= 0) {
            jumpHoldTicks = 0;
          }
        }

        // Generate more platforms if approaching the end
        if (lemon.position.x > lastPlatformX - viewWidth * 2) {
          extendLevel(viewWidth, viewHeight);
        }
      });

      Events.on(engine, 'afterUpdate', () => {
        if (!lemon) return;
        updateCamera(viewWidth, viewHeight);
        distanceTravelled = Math.max(distanceTravelled, Math.floor(lemon.position.x / 20));
        distanceValue.textContent = distanceTravelled;

        if (lemon.position.y > viewHeight + 400) {
          resetPlayer(viewWidth, viewHeight);
        }
      });

      Events.on(engine, 'collisionStart', event => adjustContacts(event.pairs, 1));
      Events.on(engine, 'collisionEnd', event => adjustContacts(event.pairs, -1));

      ensureResizeListener();
    }

    function adjustContacts(pairs, delta) {
      pairs.forEach(pair => {
        if (pair.bodyA === lemon || pair.bodyB === lemon) {
          const other = pair.bodyA === lemon ? pair.bodyB : pair.bodyA;
          if (!other.isStatic && other.label !== 'platform') return;

          const normal = pair.collision.normal;
          const touchingGround = (pair.bodyA === lemon && normal.y < -0.4) ||
                                 (pair.bodyB === lemon && normal.y > 0.4);
          if (touchingGround) {
            groundedContacts = Math.max(0, groundedContacts + delta);
            if (delta > 0) {
              jumpHoldTicks = 0;
            }
          }
        }
      });
    }

    function isNearGround() {
      if (!lemon || platforms.length === 0) return false;
      const footY = lemon.bounds.max.y;
      const start = { x: lemon.position.x, y: footY };
      const end = { x: lemon.position.x, y: footY + JUMP_GROUND_BUFFER };
      const hits = Query.ray(platforms, start, end);
      return hits.length > 0;
    }
    
    function canJump() {
      return groundedContacts > 0 || isNearGround();
    }

    function performJump() {
      if (!lemon) return;
      groundedContacts = 0;
      Body.setVelocity(lemon, { x: lemon.velocity.x, y: Math.min(lemon.velocity.y, -2) });
      Body.applyForce(lemon, {
        x: lemon.position.x,
        y: lemon.position.y + 10
      }, {
        x: 0,
        y: -JUMP_FORCE
      });
      jumpHoldTicks = MAX_JUMP_HOLD_TICKS;
    }

    function resetPlayer(viewWidth, viewHeight) {
      if (!lemon) return;
      Body.setPosition(lemon, { x: 80, y: viewHeight - 120 });
      Body.setVelocity(lemon, { x: 0, y: 0 });
      Body.setAngularVelocity(lemon, 0);
      distanceTravelled = 0;
      jumpHoldTicks = 0;
    }

    function updateCamera(viewWidth, viewHeight) {
      const marginX = viewWidth * 0.3;
      const marginY = viewHeight * 0.4;
      const minX = render.bounds.min.x + marginX;
      const maxX = render.bounds.max.x - marginX;

      let targetX = cameraTarget.x;
      if (lemon.position.x < minX || lemon.position.x > maxX) {
        targetX = lemon.position.x;
      } else {
        targetX = lerp(cameraTarget.x, lemon.position.x, CAMERA_LERP);
      }

      const targetY = lerp(cameraTarget.y, lemon.position.y, CAMERA_LERP);

      cameraTarget.x = clamp(targetX, viewWidth / 2, levelWidth - viewWidth / 2);
      cameraTarget.y = clamp(targetY, viewHeight / 2, viewHeight * 1.5);

      const halfW = viewWidth / 2;
      const halfH = viewHeight / 2;

      render.bounds.min.x = cameraTarget.x - halfW;
      render.bounds.max.x = cameraTarget.x + halfW;
      render.bounds.min.y = cameraTarget.y - halfH;
      render.bounds.max.y = cameraTarget.y + halfH;

      Render.lookAt(render, render.bounds);
    }

    function getLemonVertices() {
      return [
        { x: 0, y: -490 }, { x: 50, y: -485 }, { x: 100, y: -475 },
        { x: 150, y: -460 }, { x: 200, y: -440 }, { x: 250, y: -415 },
        { x: 300, y: -380 }, { x: 345, y: -340 }, { x: 385, y: -295 },
        { x: 420, y: -245 }, { x: 445, y: -190 }, { x: 465, y: -130 },
        { x: 478, y: -65 }, { x: 485, y: 0 }, { x: 485, y: 65 },
        { x: 478, y: 130 }, { x: 465, y: 190 }, { x: 445, y: 245 },
        { x: 420, y: 295 }, { x: 385, y: 340 }, { x: 345, y: 380 },
        { x: 300, y: 415 }, { x: 250, y: 440 }, { x: 200, y: 460 },
        { x: 150, y: 475 }, { x: 100, y: 485 }, { x: 50, y: 490 },
        { x: 0, y: 492 }, { x: -50, y: 490 }, { x: -100, y: 485 },
        { x: -150, y: 475 }, { x: -200, y: 460 }, { x: -250, y: 440 },
        { x: -300, y: 415 }, { x: -345, y: 380 }, { x: -385, y: 340 },
        { x: -420, y: 295 }, { x: -445, y: 245 }, { x: -465, y: 190 },
        { x: -478, y: 130 }, { x: -485, y: 65 }, { x: -490, y: 0 },
        { x: -485, y: -65 }, { x: -478, y: -130 }, { x: -465, y: -190 },
        { x: -445, y: -245 }, { x: -420, y: -295 }, { x: -385, y: -340 },
        { x: -345, y: -380 }, { x: -300, y: -415 }, { x: -250, y: -440 },
        { x: -200, y: -460 }, { x: -150, y: -475 }, { x: -100, y: -485 },
        { x: -50, y: -490 }
      ];
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function lerp(start, end, t) {
      return start + (end - start) * t;
    }

    function ensureResizeListener() {
      if (resizeHandler) return;
      resizeHandler = () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (render) {
            Render.stop(render);
          }
          initGame();
        }, 250);
      };
      window.addEventListener('resize', resizeHandler);
    }

    // Team management
    async function loadAllTeams2() {
      try {
        const teamSelect = document.getElementById('teamSelect2');
        teamSelect.innerHTML = '<option value="">Select your team...</option>';
        
        const allTeams = new Set();
        
        // Load all sessions from grading
        const sessionsSnap = await window.dbGet(window.dbRef(window.db, 'grading'));
        if (sessionsSnap.exists()) {
          const sessions = sessionsSnap.val();
          
          // Collect all unique team names from all sessions
          for (const sessionId in sessions) {
            const teamsSnap = await window.dbGet(window.dbRef(window.db, `grading/${sessionId}/teams`));
            if (teamsSnap.exists()) {
              const teams = teamsSnap.val();
              Object.values(teams).forEach(team => {
                if (team.name) {
                  allTeams.add(team.name);
                }
              });
            }
          }
        }
        
        // Sort and add to dropdown
        const sortedTeams = Array.from(allTeams).sort();
        sortedTeams.forEach(teamName => {
          const option = document.createElement('option');
          option.value = teamName;
          option.textContent = teamName;
          teamSelect.appendChild(option);
        });
        
        if (sortedTeams.length === 0) {
          teamSelect.innerHTML = '<option value="">No teams found</option>';
        }
      } catch (error) {
        console.error('Error loading teams:', error);
        document.getElementById('teamSelect2').innerHTML = '<option value="">Error loading teams</option>';
      }
    }

    async function onLocationChange2() {
      // Location change doesn't affect team list - all teams always visible
    }

    function startGame2() {
      const teamName = document.getElementById('teamSelect2').value;
      const barLocation = document.getElementById('barLocation2').value;
      
      if (!teamName || !barLocation) {
        alert('Please select team name and bar location.');
        return;
      }
      
      // Store for score submission
      window.currentTeamName = teamName;
      window.currentBarLocation = barLocation;
      
      // Hide setup, show game
      document.getElementById('setupScreen').classList.add('hidden');
      document.getElementById('gameScreen').classList.add('active');
      
      initGame();
    }

    async function submitScore2(score) {
      const teamName = window.currentTeamName;
      const barLocation = window.currentBarLocation;
      
      if (!teamName || !barLocation) return;
      
      const scoreData = {
        teamName: teamName,
        barLocation: barLocation,
        score: score,
        timestamp: Date.now(),
        date: new Date().toISOString().split('T')[0]
      };
      
      try {
        const answersRef = window.dbRef(window.db, 'games/lemondrop2/answers');
        const newAnswerRef = window.dbPush(answersRef);
        await window.dbSet(newAnswerRef, scoreData);
        console.log('Score submitted successfully');
      } catch (error) {
        console.error('Error submitting to main path:', error);
        
        try {
          const publicAnswersRef = window.dbRef(window.db, 'publicAnswers/lemondrop2');
          const newAnswerRef = window.dbPush(publicAnswersRef);
          await window.dbSet(newAnswerRef, scoreData);
          console.log('Score submitted to fallback path');
        } catch (fallbackError) {
          console.error('Error submitting to fallback path:', fallbackError);
        }
      }
    }

    regenBtn.addEventListener('click', () => {
      initGame();
      distanceTravelled = 0;
    });

    setupMobileControls();
    window.addEventListener('beforeunload', cleanup);
    window.startGame2 = startGame2;
    window.onLocationChange2 = onLocationChange2;
    
    // Load all teams on page load
    loadAllTeams2();
  </script>
</body>
</html>

