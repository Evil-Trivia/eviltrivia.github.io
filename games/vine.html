<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Evil Trivia - Vine Word Ladder</title>
  <script src="/js/components/autoload-banner.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #2E7D32; /* Forest green background */
      margin-top: 60px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      color: #fff;
      margin-bottom: 10px;
    }
    
    .subtitle {
      text-align: center;
      color: #E8F5E9;
      margin-bottom: 20px;
      font-size: 16px;
      line-height: 1.5;
    }
    
    .subtitle a {
      color: #fff;
      text-decoration: underline;
      font-weight: bold;
    }
    
    .subtitle a:hover {
      color: #C8E6C9;
    }

    .game-card {
      background: white;
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-top: 20px;
      position: relative;
    }
    
    .date-display {
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
      color: #777;
    }
    
    .word-ladder {
      margin: 30px 0;
    }
    
    .ladder-rung {
      display: flex;
      margin-bottom: 15px;
      align-items: center;
      position: relative; /* Added for positioning vines */
    }
    
    .ladder-position {
      width: 30px;
      text-align: center;
      font-weight: bold;
      color: #555;
    }
    
    .ladder-word {
      flex: 1;
      display: flex;
      justify-content: center;
      gap: 5px;
    }
    
    .letter-box {
      width: 40px;
      height: 40px;
      border: 2px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
      text-transform: uppercase;
      background-color: #f8f8f8;
    }
    
    .filled {
      background-color: #C8E6C9;
      border-color: #81C784;
      box-shadow: 0 0 8px rgba(46, 125, 50, 0.4); /* Added subtle glow effect */
      animation: letterFill 0.5s ease-out; /* Added animation when letter appears */
    }
    
    @keyframes letterFill {
      0% { transform: scale(0.8); opacity: 0.5; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .ladder-hint {
      flex: 1;
      padding-left: 15px;
      color: #555;
      font-style: italic;
    }
    
    .answer-form {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin-top: 30px;
    }
    
    .answer-input {
      padding: 12px;
      font-size: 16px;
      border: 2px solid #ddd;
      border-radius: 4px;
      text-align: center;
      text-transform: uppercase;
      width: 80%;
      max-width: 300px;
    }
    
    .submit-btn {
      padding: 12px 30px;
      background-color: #2E7D32;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .submit-btn:hover {
      background-color: #1B5E20;
    }
    
    .status-message {
      margin-top: 20px;
      padding: 15px;
      border-radius: 5px;
      font-weight: bold;
      text-align: center;
    }
    
    .correct {
      background-color: #C8E6C9;
      color: #2E7D32;
    }
    
    .incorrect {
      background-color: #FFCDD2;
      color: #C62828;
    }
    
    .complete {
      background-color: #E8F5E9;
      color: #2E7D32;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      margin-top: 30px;
    }
    
    .score-display {
      margin-top: 20px;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
    }
    
    .share-section {
      margin-top: 30px;
      text-align: center;
    }
    
    .share-button {
      background-color: #1B5E20;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 16px;
      font-weight: bold;
      margin-top: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .share-button:hover {
      background-color: #2E7D32;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .share-button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .no-puzzle {
      text-align: center;
      padding: 30px;
      font-size: 18px;
      color: #555;
    }
    
    .emoji {
      font-size: 32px;
      margin-bottom: 10px;
    }
    
    .loading {
      text-align: center;
      padding: 30px;
      font-size: 18px;
    }
    
    .help-button {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 30px;
      height: 30px;
      background-color: #2E7D32;
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 30px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s;
    }
    
    .help-button:hover {
      background-color: #1B5E20;
    }
    
    .help-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }
    
    .help-popup {
      background-color: white;
      max-width: 500px;
      width: 90%;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      position: relative;
    }
    
    .help-popup h3 {
      margin-top: 0;
      color: #333;
    }
    
    .help-popup p {
      color: #555;
      line-height: 1.5;
    }
    
    .close-button {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 24px;
      height: 24px;
      background-color: #f0f0f0;
      color: #333;
      border-radius: 50%;
      text-align: center;
      line-height: 24px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close-button:hover {
      background-color: #e0e0e0;
    }
    
    /* Media queries for mobile */
    @media (max-width: 480px) {
      .ladder-rung {
        flex-direction: column;
      }
      
      .ladder-hint {
        padding-left: 0;
        text-align: center;
        margin-top: 10px;
      }
      
      .letter-box {
        width: 30px;
        height: 30px;
        font-size: 16px;
      }
      
      .vine-container {
        display: none; /* Hide vines on small screens for simplicity */
      }
    }
    
    /* Navigation buttons */
    .navigation-buttons {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
    }
    
    .nav-button {
      padding: 8px 15px;
      background-color: #2E7D32;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .nav-button:hover:not(:disabled) {
      background-color: #1B5E20;
    }
    
    .nav-button:disabled {
      background-color: #A5D6A7;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    /* Vine Animation Styles */
    .vine-container {
      position: absolute;
      left: 12px; /* Adjusted for wider vine */
      width: 30px; /* Increased from 20px */
      height: 0; /* Initially 0 height */
      overflow: hidden;
      transition: height 1.2s ease-in-out;
      z-index: 1;
    }
    
    .vine-container.visible {
      height: 70px; /* Increased from 60px */
    }
    
    .vine-svg {
      width: 100%;
      height: 100%;
    }
    
    .vine-svg path {
      stroke-dasharray: 300;
      stroke-dashoffset: 300;
      transition: stroke-dashoffset 1.5s ease-in-out;
    }
    
    .vine-container.animate .vine-svg path {
      stroke-dashoffset: 0;
    }
    
    /* Confetti effect for completion */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #A5D6A7;
      animation: confetti-fall linear forwards;
      z-index: 100;
      opacity: 0.8;
    }
    
    @keyframes confetti-fall {
      to {
        transform: translateY(100vh) rotate(720deg);
      }
    }
    
    /* Wave animation for completed vine */
    .vine-wave {
      animation: vine-wave 3s ease-in-out infinite;
      transform-origin: center;
    }
    
    @keyframes vine-wave {
      0% {
        transform: translateX(0) rotate(0deg);
      }
      25% {
        transform: translateX(2px) rotate(1deg);
      }
      50% {
        transform: translateX(-2px) rotate(-1deg);
      }
      75% {
        transform: translateX(3px) rotate(1.5deg);
      }
      100% {
        transform: translateX(0) rotate(0deg);
      }
    }
    
    /* Leaf wiggle animation for completed vine */
    .leaf-wiggle .vine-leaf-1,
    .leaf-wiggle .vine-leaf-2,
    .leaf-wiggle .vine-leaf-3 {
      animation: leaf-wiggle 2.5s ease-in-out infinite;
      transform-origin: center;
    }
    
    .leaf-wiggle .vine-leaf-2 {
      animation-delay: 0.5s;
    }
    
    .leaf-wiggle .vine-leaf-3 {
      animation-delay: 1s;
    }
    
    @keyframes leaf-wiggle {
      0% {
        transform: rotate(0deg) scale(1);
      }
      25% {
        transform: rotate(3deg) scale(1.05);
      }
      50% {
        transform: rotate(-2deg) scale(1);
      }
      75% {
        transform: rotate(2deg) scale(1.02);
      }
      100% {
        transform: rotate(0deg) scale(1);
      }
    }
    
    /* Make sure SVG is displayed properly inside containers */
    .vine-container svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Vine</h1>
    <div class="subtitle">
      A daily word ladder game from Evil Trivia<br>
      Want to play in-person? <a href="https://eviltrivia.com/live/">Click here</a>
    </div>
    
    <div class="game-card" id="gameContainer">
      <!-- Help button and popup -->
      <div class="help-button" id="helpButton">?</div>
      
      <div class="help-overlay" id="helpOverlay">
        <div class="help-popup">
          <div class="close-button" id="closeHelpButton">✕</div>
          <h3>How to Play Vine</h3>
          <p>Vine is a word ladder game where you transform one word into another by changing one letter at a time.</p>
          <p>Each step in the ladder has a hint that describes the word you need to form.</p>
          <p>Starting from the given word, each word in the ladder differs from the previous word by exactly one letter.</p>
          <p>For example: CAT → CAR → BAR → BAT</p>
          <p>Enter your guesses in the input box. If correct, the word will be filled in the appropriate position.</p>
          <p>Incorrect guesses will cost you 1 point from your score!</p>
          <p>Try to complete the entire ladder with the highest score possible.</p>
        </div>
      </div>
      
      <div id="loadingMessage" class="loading">
        Loading today's word ladder...
      </div>
      
      <div id="noPuzzleMessage" class="no-puzzle" style="display: none;">
        <div class="emoji">🌿</div>
        <p>There's no active word ladder at the moment. Please check back later!</p>
      </div>
      
      <div id="puzzleContainer" style="display: none;">
        <div id="dateDisplay" class="date-display"></div>
        
        <div class="navigation-buttons">
          <button id="prevButton" class="nav-button" disabled>← Previous</button>
          <button id="nextButton" class="nav-button" disabled>Next →</button>
        </div>
        
        <div id="wordLadder" class="word-ladder">
          <!-- Word ladder rungs will be generated here -->
        </div>
        
        <div id="scoreDisplay" class="score-display">
          Score: <span id="currentScore">10</span>
        </div>
        
        <form id="answerForm" class="answer-form">
          <input type="text" id="answerInput" class="answer-input" placeholder="Enter word" required>
          <button type="submit" class="submit-btn">Submit</button>
        </form>
        
        <div id="statusMessage" class="status-message" style="display: none;"></div>
        
        <div id="completionMessage" class="complete" style="display: none;">
          <h3>Congratulations!</h3>
          <p>You've completed today's word ladder!</p>
          
          <div class="share-section">
            <button id="shareButton" class="share-button">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16 6 12 2 8 6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
              Share Results
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
    import { getDatabase, ref, get, set, push, onValue } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-auth.js";
    
    // Initialize help button
    document.addEventListener('DOMContentLoaded', initializeHelpButton);
    
    function initializeHelpButton() {
      const helpButton = document.getElementById('helpButton');
      const helpOverlay = document.getElementById('helpOverlay');
      const closeHelpButton = document.getElementById('closeHelpButton');
      
      if (helpButton && helpOverlay && closeHelpButton) {
        helpButton.addEventListener('click', () => {
          helpOverlay.style.display = 'flex';
        });
        
        closeHelpButton.addEventListener('click', () => {
          helpOverlay.style.display = 'none';
        });
        
        // Close help when clicking outside the popup
        helpOverlay.addEventListener('click', (e) => {
          if (e.target === helpOverlay) {
            helpOverlay.style.display = 'none';
          }
        });
      }
    }
    
    // DOM elements
    const loadingMessage = document.getElementById('loadingMessage');
    const noPuzzleMessage = document.getElementById('noPuzzleMessage');
    const puzzleContainer = document.getElementById('puzzleContainer');
    const wordLadder = document.getElementById('wordLadder');
    const dateDisplay = document.getElementById('dateDisplay');
    const answerForm = document.getElementById('answerForm');
    const answerInput = document.getElementById('answerInput');
    const statusMessage = document.getElementById('statusMessage');
    const completionMessage = document.getElementById('completionMessage');
    const shareButton = document.getElementById('shareButton');
    const prevButton = document.getElementById('prevButton');
    const nextButton = document.getElementById('nextButton');
    const scoreDisplay = document.getElementById('currentScore');
    
    // Firebase references
    let app;
    let db;
    let auth;
    let currentUserId = null;
    
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyDzLeYIULAaVMWYAe7WPPQRq4uZB7hbvnQ",
      authDomain: "eviltrivia-47664.firebaseapp.com",
      databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
      projectId: "eviltrivia-47664",
      storageBucket: "eviltrivia-47664.appspot.com",
      messagingSenderId: "262105139440",
      appId: "1:262105139440:web:28fb2e6251d33e2e698531",
      measurementId: "G-KK6NTBZHYZ"
    };
    
    // Initialize Firebase
    try {
      app = initializeApp(firebaseConfig);
      db = getDatabase(app);
      auth = getAuth(app);
      console.log("Firebase initialized successfully - database URL:", firebaseConfig.databaseURL);
      
      // Check auth state
      onAuthStateChanged(auth, (user) => {
        if (user) {
          // User is signed in
          currentUserId = user.uid;
          console.log("User is signed in with ID:", currentUserId);
        } else {
          // User is signed out
          currentUserId = null;
          console.log("No user is signed in, will use anonymous ID");
        }
        
        // Load the active word ladder after checking auth
        loadActiveWordLadder();
      });
    } catch (error) {
      console.error("Firebase initialization error:", error);
      loadingMessage.innerHTML = `
        <p>Error initializing Firebase: ${error.message}</p>
        <p>Please refresh the page or try again later.</p>
      `;
    }
    
    // Game state
    let currentPuzzle = null;
    let userProgress = [];
    let currentScore = 10; // Start with 10 points
    let solvedPositions = new Set();
    let hasCompleted = false;
    let startTime = null;
    let endTime = null;
    let mistakeCount = 0;
    let puzzleHistory = [];
    let currentPuzzleIndex = -1;
    
    // Load the active word ladder
    async function loadActiveWordLadder() {
      try {
        if (!db) {
          throw new Error("Database connection not established");
        }
        
        console.log("Starting to load active word ladder");
        const activeWordLadderRef = ref(db, 'games/vine/activePuzzle');
        
        onValue(activeWordLadderRef, async (snapshot) => {
          try {
            console.log("Active puzzle data received");
            const activePuzzleId = snapshot.val();
            
            if (!activePuzzleId) {
              // No active puzzle
              console.log("No active puzzle found");
              loadingMessage.style.display = 'none';
              noPuzzleMessage.style.display = 'block';
              puzzleContainer.style.display = 'none';
              return;
            }
            
            console.log("Active puzzle ID:", activePuzzleId);
            
            // Get the puzzle details
            const puzzleRef = ref(db, `games/vine/puzzles/${activePuzzleId}`);
            const puzzleSnapshot = await get(puzzleRef);
            currentPuzzle = puzzleSnapshot.val();
            
            if (!currentPuzzle) {
              // Puzzle not found
              console.error("Puzzle not found with ID:", activePuzzleId);
              loadingMessage.style.display = 'none';
              noPuzzleMessage.style.display = 'block';
              noPuzzleMessage.innerHTML = `
                <div class="emoji">😞</div>
                <p>Puzzle not found. The active puzzle may have been deleted.</p>
              `;
              puzzleContainer.style.display = 'none';
              return;
            }
            
            // Check if puzzle is available
            if (currentPuzzle.available === false) {
              // Puzzle is explicitly marked as unavailable
              console.log("Active puzzle is unavailable");
              loadingMessage.style.display = 'none';
              noPuzzleMessage.style.display = 'block';
              noPuzzleMessage.innerHTML = `
                <div class="emoji">🌿</div>
                <p>Today's word ladder is not available right now. Please check back later!</p>
              `;
              puzzleContainer.style.display = 'none';
              return;
            }
            
            // Ensure ID is set on the puzzle object
            currentPuzzle.id = activePuzzleId;
            
            // Load puzzle history for navigation
            await loadPuzzleHistory();
            
            // Initialize user progress
            initializeUserProgress();
            
            // Show puzzle and hide loading
            loadingMessage.style.display = 'none';
            noPuzzleMessage.style.display = 'none';
            puzzleContainer.style.display = 'block';
            
            // Display date if available
            if (currentPuzzle.date) {
              const date = new Date(currentPuzzle.date);
              const options = { year: 'numeric', month: 'long', day: 'numeric' };
              const formattedDate = date.toLocaleDateString(undefined, options);
              dateDisplay.textContent = formattedDate;
              dateDisplay.style.display = 'block';
            } else {
              dateDisplay.style.display = 'none';
            }
            
            // Display the word ladder
            displayWordLadder();
          } catch (innerError) {
            console.error("Error in onValue callback:", innerError);
            loadingMessage.style.display = 'none';
            noPuzzleMessage.style.display = 'block';
            noPuzzleMessage.innerHTML = `
              <div class="emoji">😞</div>
              <p>Error loading puzzle: ${innerError.message}</p>
              <p>Please try refreshing the page.</p>
            `;
          }
        }, (error) => {
          console.error("onValue error:", error);
          loadingMessage.style.display = 'none';
          noPuzzleMessage.style.display = 'block';
          noPuzzleMessage.innerHTML = `
            <div class="emoji">😞</div>
            <p>Error listening for puzzle updates: ${error.message}</p>
            <p>Please try refreshing the page.</p>
          `;
        });
      } catch (error) {
        console.error("Error in loadActiveWordLadder:", error);
        loadingMessage.style.display = 'none';
        noPuzzleMessage.style.display = 'block';
        noPuzzleMessage.innerHTML = `
          <div class="emoji">😞</div>
          <p>Error loading puzzle: ${error.message}</p>
          <p>Please try refreshing the page or contact support if the issue persists.</p>
        `;
      }
    }
    
    // Load puzzle history
    async function loadPuzzleHistory() {
      try {
        // Get all puzzles
        const puzzlesRef = ref(db, 'games/vine/puzzles');
        const puzzlesSnapshot = await get(puzzlesRef);
        const puzzles = puzzlesSnapshot.val() || {};
        
        // Convert to array and add IDs
        puzzleHistory = Object.entries(puzzles).map(([id, puzzle]) => {
          return { ...puzzle, id };
        });
        
        // Filter to only include available puzzles or the active one
        puzzleHistory = puzzleHistory.filter(puzzle => 
          puzzle.id === currentPuzzle.id || puzzle.available !== false
        );
        
        // Sort by date (oldest first so previous means older)
        puzzleHistory.sort((a, b) => {
          const dateA = a.date ? new Date(a.date) : new Date(0);
          const dateB = b.date ? new Date(b.date) : new Date(0);
          return dateA - dateB; // Oldest first
        });
        
        // Find current puzzle index
        currentPuzzleIndex = puzzleHistory.findIndex(p => p.id === currentPuzzle.id);
        
        // Update navigation buttons
        updateNavigationButtons();
      } catch (error) {
        console.error("Error loading puzzle history:", error);
      }
    }
    
    // Update navigation buttons
    function updateNavigationButtons() {
      // Enable/disable previous button (older puzzles)
      prevButton.disabled = currentPuzzleIndex <= 0;
      
      // Enable/disable next button (newer puzzles)
      nextButton.disabled = currentPuzzleIndex >= puzzleHistory.length - 1;
      
      // Set up click handlers
      prevButton.onclick = () => {
        if (currentPuzzleIndex > 0) {
          navigateToPuzzle(currentPuzzleIndex - 1);
        }
      };
      
      nextButton.onclick = () => {
        if (currentPuzzleIndex < puzzleHistory.length - 1) {
          navigateToPuzzle(currentPuzzleIndex + 1);
        }
      };
    }
    
    // Navigate to a puzzle by index
    function navigateToPuzzle(index) {
      if (index < 0 || index >= puzzleHistory.length) {
        return;
      }
      
      // Save current index and puzzle
      currentPuzzleIndex = index;
      currentPuzzle = puzzleHistory[index];
      
      // Reset game state
      hasCompleted = false;
      completionMessage.style.display = 'none';
      answerForm.style.display = 'flex';
      
      // Initialize user progress for the new puzzle
      initializeUserProgress();
      
      // Update date display
      if (currentPuzzle.date) {
        const date = new Date(currentPuzzle.date);
        const options = { year: 'numeric', month: 'long', day: 'numeric' };
        const formattedDate = date.toLocaleDateString(undefined, options);
        dateDisplay.textContent = formattedDate;
        dateDisplay.style.display = 'block';
      } else {
        dateDisplay.style.display = 'none';
      }
      
      // Update the display
      displayWordLadder();
      
      // Update navigation buttons
      updateNavigationButtons();
    }
    
    // Initialize user progress from localStorage or Firebase
    async function initializeUserProgress() {
      // Reset game state
      userProgress = Array(currentPuzzle.ladder.length).fill(null);
      solvedPositions = new Set();
      hasCompleted = false;
      startTime = Date.now();
      mistakeCount = 0;
      
      // Start with first word already filled
      userProgress[0] = currentPuzzle.ladder[0].word;
      solvedPositions.add(0);
      
      // Check for saved progress in localStorage
      const storageKey = `vine_progress_${currentPuzzle.id}`;
      const savedProgress = localStorage.getItem(storageKey);
      const savedScore = localStorage.getItem(`vine_score_${currentPuzzle.id}`);
      const savedCompleted = localStorage.getItem(`vine_completed_${currentPuzzle.id}`);
      const savedMistakes = localStorage.getItem(`vine_mistakes_${currentPuzzle.id}`);
      const savedTimeStr = localStorage.getItem(`vine_time_${currentPuzzle.id}`);
      const savedTimeTaken = savedTimeStr ? parseInt(savedTimeStr, 10) : null;
      
      if (savedProgress) {
        // Restore progress from localStorage
        userProgress = JSON.parse(savedProgress);
        
        // Rebuild solved positions set
        solvedPositions = new Set();
        userProgress.forEach((word, index) => {
          if (word) solvedPositions.add(index);
        });
        
        // Restore score
        if (savedScore) {
          currentScore = parseInt(savedScore, 10);
        }
        
        // Restore mistake count
        if (savedMistakes) {
          mistakeCount = parseInt(savedMistakes, 10);
        }
        
        // Check if already completed
        if (savedCompleted === 'true') {
          hasCompleted = true;
          
          // If we have a saved time, calculate a fake start time that would result in this time taken
          if (savedTimeTaken) {
            endTime = Date.now();
            // Calculate a start time that would give us the saved time
            startTime = endTime - (savedTimeTaken * 1000);
            console.log(`Restored completed puzzle with time: ${savedTimeTaken}s`);
          } else {
            // Fallback if no time saved
            endTime = Date.now();
            startTime = endTime; // This will result in a time of 0, but it's better than a random time
            console.log('Completed puzzle but no time was saved');
          }
          
          showCompletionMessage();
        }
      }
      
      // Update the score display
      scoreDisplay.textContent = currentScore;
    }
    
    // Display the word ladder
    function displayWordLadder() {
      // Clear previous content
      wordLadder.innerHTML = '';
      
      // Create ladder rungs
      currentPuzzle.ladder.forEach((rung, index) => {
        const ladderRung = document.createElement('div');
        ladderRung.className = 'ladder-rung';
        ladderRung.setAttribute('data-position', index);
        
        // Position number
        const positionElement = document.createElement('div');
        positionElement.className = 'ladder-position';
        positionElement.textContent = (index + 1);
        ladderRung.appendChild(positionElement);
        
        // Add vine between rungs (except for the first rung)
        if (index > 0) {
          // Create vine container
          const vineContainer = document.createElement('div');
          vineContainer.className = 'vine-container';
          vineContainer.id = `vine-${index-1}-${index}`;
          vineContainer.style.top = `-35px`; // Position to connect with previous rung
          
          // Add the SVG
          vineContainer.innerHTML = `
            <img src="/images/vine_animation.svg" class="vine-svg" alt="Vine connecting words" />
          `;
          
          // Check if this vine should be visible (if previous rung is solved)
          if (solvedPositions.has(index) || solvedPositions.has(index-1)) {
            setTimeout(() => {
              vineContainer.classList.add('visible');
              setTimeout(() => {
                vineContainer.classList.add('animate');
              }, 100);
            }, 10);
          }
          
          ladderRung.appendChild(vineContainer);
        }
        
        // Word (as letter boxes)
        const wordElement = document.createElement('div');
        wordElement.className = 'ladder-word';
        
        const word = userProgress[index] || rung.word;
        const wordLength = word.length;
        
        for (let i = 0; i < wordLength; i++) {
          const letterBox = document.createElement('div');
          letterBox.className = 'letter-box';
          if (userProgress[index]) {
            letterBox.classList.add('filled');
            letterBox.textContent = word[i];
          }
          wordElement.appendChild(letterBox);
        }
        
        ladderRung.appendChild(wordElement);
        
        // Hint
        const hintElement = document.createElement('div');
        hintElement.className = 'ladder-hint';
        hintElement.textContent = rung.hint || '';
        ladderRung.appendChild(hintElement);
        
        wordLadder.appendChild(ladderRung);
      });
      
      // If completed, show completion message
      if (hasCompleted) {
        showCompletionMessage();
      }
    }
    
    // Handle form submission
    answerForm.addEventListener('submit', (e) => {
      e.preventDefault();
      
      if (hasCompleted) {
        return; // Game already completed
      }
      
      const answer = answerInput.value.trim().toUpperCase();
      
      if (!answer) {
        showStatus('Please enter a word', 'incorrect');
        return;
      }
      
      // Check if the answer is valid in the ladder
      checkAnswer(answer);
      
      // Clear input
      answerInput.value = '';
    });
    
    // Check if answer is valid
    function checkAnswer(answer) {
      let isCorrect = false;
      let correctPosition = -1;
      
      // Check against each unsolved word in the ladder
      for (let i = 0; i < currentPuzzle.ladder.length; i++) {
        if (solvedPositions.has(i)) continue; // Skip already solved positions
        
        if (currentPuzzle.ladder[i].word.toUpperCase() === answer) {
          isCorrect = true;
          correctPosition = i;
          break;
        }
      }
      
      if (isCorrect) {
        // Mark as solved
        userProgress[correctPosition] = currentPuzzle.ladder[correctPosition].word;
        solvedPositions.add(correctPosition);
        
        // Save progress
        saveProgress();
        
        // Show success message
        showStatus('Correct! Well done!', 'correct');
        
        // Update display
        displayWordLadder();
        
        // Animate vines for the newly solved position
        animateVinesForPosition(correctPosition);
        
        // Check if all words are solved
        if (solvedPositions.size === currentPuzzle.ladder.length) {
          endTime = Date.now();
          hasCompleted = true;
          
          // Save completion data
          localStorage.setItem(`vine_completed_${currentPuzzle.id}`, 'true');
          
          // Save score to Firebase if user is logged in
          saveUserScore();
          
          // Show completion message
          showCompletionMessage();
          
          // Create confetti for celebration
          createConfetti();
        }
      } else {
        // Deduct point for incorrect answer
        currentScore = Math.max(0, currentScore - 1);
        mistakeCount++;
        scoreDisplay.textContent = currentScore;
        
        // Save score
        localStorage.setItem(`vine_score_${currentPuzzle.id}`, currentScore.toString());
        localStorage.setItem(`vine_mistakes_${currentPuzzle.id}`, mistakeCount.toString());
        
        // Show error message
        showStatus('Incorrect! Try again. (-1 point)', 'incorrect');
      }
    }
    
    // Save user score to Firebase - SIMPLIFIED
    async function saveUserScore() {
      try {
        console.log("SIMPLE SCORE SAVING: Starting simple score save process");
        
        // Basic validation
        if (!db || !currentPuzzle || !currentPuzzle.id) {
          console.error("Missing database or puzzle information");
          return false;
        }
        
        // Get user ID (use anonymous ID if not logged in)
        const userId = currentUserId || 
          localStorage.getItem('vine_anon_user_id') || 
          ('anon_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
        
        // Save anonymous ID for future use
        if (!currentUserId) {
          localStorage.setItem('vine_anon_user_id', userId);
        }
        
        // Get completion time from localStorage or calculate it
        const savedTimeStr = localStorage.getItem(`vine_time_${currentPuzzle.id}`);
        const seconds = savedTimeStr ? parseInt(savedTimeStr, 10) : Math.floor((endTime - startTime) / 1000);
        
        // Create score data
        const timestamp = new Date().toISOString();
        const scoreData = {
          userId: userId,
          timeInSeconds: seconds,
          mistakes: mistakeCount,
          completedAt: timestamp,
          score: currentScore
        };
        
        // Log data for debugging
        console.log("Score data:", JSON.stringify(scoreData));
        console.log("Puzzle ID:", currentPuzzle.id);
        
        // Create scores node if it doesn't exist
        const puzzleRef = ref(db, `vine/puzzles/${currentPuzzle.id}`);
        
        // Create a child node for this score under the scores node
        // We do this by first creating/getting the scores reference
        const scoresRef = ref(db, `vine/puzzles/${currentPuzzle.id}/scores`);
        
        console.log(`Attempting direct write to: vine/puzzles/${currentPuzzle.id}/scores/${userId}`);
        
        // Then set this user's score
        const userScoreRef = ref(db, `vine/puzzles/${currentPuzzle.id}/scores/${userId}`);
        
        try {
          // Try to write directly to the user score path
          await set(userScoreRef, scoreData);
          console.log("SUCCESS: Score saved successfully to Firebase");
          
          // Verify it was saved
          try {
            const snapshot = await get(userScoreRef);
            if (snapshot.exists()) {
              console.log("VERIFIED: Score data read back successfully");
              return true;
            } else {
              console.warn("WARNING: Score was supposedly saved but couldn't be read back");
            }
          } catch (verifyError) {
            console.error("Error verifying saved score:", verifyError);
          }
        } catch (directWriteError) {
          console.error("Error writing directly to user score:", directWriteError);
          
          // If direct write fails, try using push() to generate a unique key
          try {
            console.log("Trying alternative approach with push()");
            const newScoreRef = push(scoresRef);
            await set(newScoreRef, {
              ...scoreData,
              pushId: true
            });
            console.log("SUCCESS: Score saved using push() method");
            return true;
          } catch (pushError) {
            console.error("Error saving score with push():", pushError);
          }
        }
        
        // Fallback to localStorage if Firebase fails
        console.log("Saving to localStorage as fallback");
        const localScores = JSON.parse(localStorage.getItem('vine_local_scores') || '{}');
        localScores[`${currentPuzzle.id}_${userId}`] = scoreData;
        localStorage.setItem('vine_local_scores', JSON.stringify(localScores));
        
        return false;
      } catch (error) {
        console.error("Critical error in saveUserScore:", error);
        return false;
      }
    }
    
    // Calculate user's percentile based on scores
    async function calculatePercentile() {
      if (!db || !currentPuzzle) {
        console.log('Cannot calculate percentile: DB or puzzle not available');
        return { percentile: null, totalPlayers: 0, error: 'Database not available' };
      }
      
      try {
        console.log(`[${new Date().toISOString()}] PERCENTILE: Beginning percentile calculation`);
        
        // Get the time in seconds from localStorage
        const savedTimeStr = localStorage.getItem(`vine_time_${currentPuzzle.id}`);
        const seconds = savedTimeStr ? parseInt(savedTimeStr, 10) : Math.floor((endTime - startTime) / 1000);
        
        if (seconds <= 0) {
          console.warn('Invalid time value for percentile calculation:', seconds);
        }
        
        console.log(`Using time of ${seconds}s for percentile calculation`);
        const puzzleId = currentPuzzle.id;
        
        // Get the previously successful path if available
        const successfulPath = localStorage.getItem('vine_successful_score_path');
        
        // Define the paths to try, prioritizing the previously successful path
        const paths = [];
        
        if (successfulPath) {
          // Extract the base path from the successful path (remove the user ID part)
          const parts = successfulPath.split('/');
          parts.pop(); // Remove the userId
          const basePath = parts.join('/');
          paths.push(basePath);
        }
        
        // Add all possible paths
        paths.push(`games/vine/puzzles/${puzzleId}/scores`);
        paths.push(`vine/puzzles/${puzzleId}/scores`);
        paths.push(`games/publicScores/vine/${puzzleId}`);
        
        console.log(`[${new Date().toISOString()}] PERCENTILE: Will try these paths for scores:`, paths);
        
        let scores = [];
        let pathSucceeded = false;
        
        // Try each path in sequence
        for (const path of paths) {
          try {
            console.log(`[${new Date().toISOString()}] PERCENTILE: Trying to read scores from ${path}`);
            const scoresRef = ref(db, path);
            const scoresSnapshot = await get(scoresRef);
            
            if (scoresSnapshot.exists()) {
              console.log(`[${new Date().toISOString()}] PERCENTILE: Found scores at ${path}`);
              
              // Process the scores
              scores = [];
              let skippedScores = 0;
              
              scoresSnapshot.forEach(childSnapshot => {
                const scoreData = childSnapshot.val();
                
                if (scoreData && typeof scoreData.timeInSeconds === 'number' && typeof scoreData.mistakes === 'number') {
                  // Calculate a composite score where lower is better
                  // Weight: Time is primary, mistakes add a penalty
                  const compositeScore = scoreData.timeInSeconds + (scoreData.mistakes * 10);
                  scores.push(compositeScore);
                } else {
                  skippedScores++;
                }
              });
              
              if (skippedScores > 0) {
                console.log(`Skipped ${skippedScores} invalid score entries`);
              }
              
              console.log(`[${new Date().toISOString()}] PERCENTILE: Processed ${scores.length} valid scores from ${path}`);
              
              if (scores.length > 0) {
                pathSucceeded = true;
                break; // We found valid scores, no need to try more paths
              }
            } else {
              console.log(`[${new Date().toISOString()}] PERCENTILE: No scores found at ${path}`);
            }
          } catch (pathError) {
            console.error(`[${new Date().toISOString()}] PERCENTILE: Error reading from ${path}:`, pathError);
          }
        }
        
        // If no Firebase paths worked, try the localStorage fallback
        if (!pathSucceeded) {
          console.log(`[${new Date().toISOString()}] PERCENTILE: Trying localStorage fallback`);
          
          const localScores = JSON.parse(localStorage.getItem('vine_local_scores') || '{}');
          scores = [];
          
          // Extract relevant scores for this puzzle
          Object.entries(localScores).forEach(([key, scoreData]) => {
            if (key.startsWith(`${puzzleId}_`) && 
                typeof scoreData.timeInSeconds === 'number' && 
                typeof scoreData.mistakes === 'number') {
              const compositeScore = scoreData.timeInSeconds + (scoreData.mistakes * 10);
              scores.push(compositeScore);
            }
          });
          
          if (scores.length > 0) {
            console.log(`[${new Date().toISOString()}] PERCENTILE: Using ${scores.length} scores from localStorage`);
            pathSucceeded = true;
          } else {
            console.log(`[${new Date().toISOString()}] PERCENTILE: No valid scores found in localStorage either`);
          }
        }
        
        // If we have no scores at all, return isFirst
        if (scores.length === 0) {
          console.log(`[${new Date().toISOString()}] PERCENTILE: No scores found anywhere, assuming user is first`);
          return { percentile: 100, totalPlayers: 1, isFirst: true };
        }
        
        // Calculate the user's composite score
        const userCompositeScore = seconds + (mistakeCount * 10);
        console.log(`User composite score: ${userCompositeScore} (from ${seconds}s and ${mistakeCount} mistakes)`);
        console.log(`Total valid scores found: ${scores.length}`);
        
        // If this is the only score, user is first
        if (scores.length <= 1) {
          return { percentile: 100, totalPlayers: 1, isFirst: true };
        }
        
        // Sort scores (lower is better)
        scores.sort((a, b) => a - b);
        
        // Calculate percentile (higher percentile means better performance)
        const totalPlayers = scores.length;
        const betterThanCount = scores.filter(score => score > userCompositeScore).length;
        const percentile = Math.round((betterThanCount / totalPlayers) * 100);
        
        console.log(`[${new Date().toISOString()}] PERCENTILE: Final result - ${percentile}% (better than ${betterThanCount} of ${totalPlayers} players)`);
        
        return {
          percentile,
          totalPlayers,
          isFirst: false
        };
      } catch (error) {
        console.error(`[${new Date().toISOString()}] PERCENTILE: Critical error in percentile calculation:`, error);
        return { percentile: null, totalPlayers: 0, error: 'Failed to calculate percentile: ' + error.message };
      }
    }
    
    // Show status message
    function showStatus(message, type) {
      statusMessage.textContent = message;
      statusMessage.className = 'status-message ' + type;
      statusMessage.style.display = 'block';
      
      // Hide after 3 seconds
      setTimeout(() => {
        statusMessage.style.display = 'none';
      }, 3000);
    }
    
    // Save progress to localStorage
    function saveProgress() {
      const storageKey = `vine_progress_${currentPuzzle.id}`;
      localStorage.setItem(storageKey, JSON.stringify(userProgress));
      localStorage.setItem(`vine_score_${currentPuzzle.id}`, currentScore.toString());
    }
    
    // Show completion message - update to call the simplified saveUserScore function
    async function showCompletionMessage() {
      completionMessage.style.display = 'block';
      answerForm.style.display = 'none';
      
      console.log(`[${new Date().toISOString()}] COMPLETION: Showing completion message`);
      
      // Calculate time taken
      const timeTaken = endTime - startTime;
      const seconds = Math.floor(timeTaken / 1000);
      
      // Store time in localStorage immediately to ensure it's saved
      if (seconds > 0) {
        console.log(`Saving completion time to localStorage: ${seconds}s`);
        localStorage.setItem(`vine_time_${currentPuzzle.id}`, seconds.toString());
      } else {
        // If time is 0 or negative, check if we have a saved time
        const savedTimeStr = localStorage.getItem(`vine_time_${currentPuzzle.id}`);
        if (!savedTimeStr) {
          // If no saved time, store a minimal time
          console.log('Time calculation resulted in 0 or negative, setting to 1s');
          localStorage.setItem(`vine_time_${currentPuzzle.id}`, '1');
        }
      }
      
      // Update the completion message with the time and mistakes
      const statsElement = document.createElement('p');
      // Use the time from localStorage if available (more reliable)
      const savedTimeStr = localStorage.getItem(`vine_time_${currentPuzzle.id}`);
      const displayTime = savedTimeStr ? parseInt(savedTimeStr, 10) : seconds;
      
      statsElement.innerHTML = `You solved this puzzle with <strong>${mistakeCount}</strong> mistake${mistakeCount !== 1 ? 's' : ''} in <strong>${displayTime}s</strong>`;
      
      // Insert after the first paragraph
      const firstParagraph = completionMessage.querySelector('p');
      if (firstParagraph && firstParagraph.nextSibling) {
        completionMessage.insertBefore(statsElement, firstParagraph.nextSibling);
      } else {
        completionMessage.appendChild(statsElement);
      }
      
      // Create percentile message with loading state
      const percentileElement = document.createElement('p');
      percentileElement.innerHTML = `Calculating your ranking...`;
      percentileElement.style.fontSize = '0.9em';
      percentileElement.style.color = '#43A047';
      percentileElement.id = 'percentileMessage';
      completionMessage.appendChild(percentileElement);
      
      // Apply vine animations
      applyVineWaveAnimation();
      
      // Set up share functionality with placeholder data initially
      setupShareButton({ calculating: true });
      
      try {
        // Try to save the score using the simplified function
        console.log("Calling simplified saveUserScore function");
        const scoreSaved = await saveUserScore();
        console.log(`Score save result: ${scoreSaved ? "Success" : "Failed"}`);
        
        // Add the raw data display for debugging
        const isAdmin = window.location.href.includes('debug=true') || localStorage.getItem('vine_admin_debug') === 'true';
        if (isAdmin) {
          // Add debug container
          const debugContainer = document.createElement('div');
          debugContainer.style.marginTop = '20px';
          debugContainer.style.padding = '15px';
          debugContainer.style.borderTop = '1px dashed #aaa';
          debugContainer.style.fontSize = '12px';
          debugContainer.style.color = '#666';
          debugContainer.style.textAlign = 'left';
          
          // Add debug heading
          const debugHeading = document.createElement('h4');
          debugHeading.textContent = 'Debug Information';
          debugHeading.style.margin = '0 0 10px 0';
          debugHeading.style.fontSize = '14px';
          debugContainer.appendChild(debugHeading);
          
          // Add database path info
          const pathInfo = document.createElement('p');
          pathInfo.textContent = `Database Path: vine/puzzles/${currentPuzzle.id}/scores/${currentUserId || localStorage.getItem('vine_anon_user_id') || 'anonymous'}`;
          pathInfo.style.margin = '5px 0';
          pathInfo.style.fontFamily = 'monospace';
          debugContainer.appendChild(pathInfo);
          
          // Add score data info
          const dataInfo = document.createElement('pre');
          const scoreData = {
            userId: currentUserId || localStorage.getItem('vine_anon_user_id') || 'anonymous',
            timeInSeconds: displayTime,
            mistakes: mistakeCount,
            completedAt: new Date().toISOString(),
            score: currentScore
          };
          dataInfo.textContent = JSON.stringify(scoreData, null, 2);
          dataInfo.style.margin = '10px 0';
          dataInfo.style.padding = '8px';
          dataInfo.style.backgroundColor = '#f5f5f5';
          dataInfo.style.borderRadius = '4px';
          dataInfo.style.maxHeight = '200px';
          dataInfo.style.overflow = 'auto';
          dataInfo.style.fontSize = '11px';
          debugContainer.appendChild(dataInfo);
          
          // Add a manual testing button
          const testButton = document.createElement('button');
          testButton.textContent = 'Test Direct Write';
          testButton.style.padding = '5px 10px';
          testButton.style.backgroundColor = '#555';
          testButton.style.color = 'white';
          testButton.style.border = 'none';
          testButton.style.borderRadius = '4px';
          testButton.style.cursor = 'pointer';
          testButton.style.marginRight = '10px';
          
          // Add result container
          const resultContainer = document.createElement('div');
          resultContainer.style.marginTop = '10px';
          resultContainer.style.padding = '8px';
          resultContainer.style.backgroundColor = '#f5f5f5';
          resultContainer.style.borderRadius = '4px';
          resultContainer.style.fontSize = '11px';
          resultContainer.style.fontFamily = 'monospace';
          resultContainer.style.display = 'none';
          
          testButton.addEventListener('click', async () => {
            resultContainer.style.display = 'block';
            resultContainer.innerHTML = 'Testing direct write...';
            
            try {
              // Try a direct write to the scores node
              const testData = {
                test: true,
                timestamp: Date.now()
              };
              
              // Try to write directly to the scores node
              const testRef = ref(db, `vine/puzzles/${currentPuzzle.id}/scores/test_${Date.now()}`);
              await set(testRef, testData);
              resultContainer.innerHTML = '✅ Success! Score data written successfully.';
            } catch (error) {
              resultContainer.innerHTML = `❌ Error: ${error.message}`;
            }
          });
          
          debugContainer.appendChild(testButton);
          debugContainer.appendChild(resultContainer);
          
          // Add a clear local storage button
          const clearButton = document.createElement('button');
          clearButton.textContent = 'Clear Local Storage';
          clearButton.style.padding = '5px 10px';
          clearButton.style.backgroundColor = '#c62828';
          clearButton.style.color = 'white';
          clearButton.style.border = 'none';
          clearButton.style.borderRadius = '4px';
          clearButton.style.cursor = 'pointer';
          
          clearButton.addEventListener('click', () => {
            localStorage.removeItem('vine_anon_user_id');
            localStorage.removeItem(`vine_progress_${currentPuzzle.id}`);
            localStorage.removeItem(`vine_score_${currentPuzzle.id}`);
            localStorage.removeItem(`vine_completed_${currentPuzzle.id}`);
            localStorage.removeItem(`vine_mistakes_${currentPuzzle.id}`);
            localStorage.removeItem(`vine_time_${currentPuzzle.id}`);
            localStorage.removeItem('vine_successful_score_path');
            localStorage.removeItem('vine_local_scores');
            
            resultContainer.style.display = 'block';
            resultContainer.innerHTML = 'Local storage cleared for this puzzle.';
          });
          
          debugContainer.appendChild(clearButton);
          
          // Append to completion message
          completionMessage.appendChild(debugContainer);
        }
        
        // Calculate percentile data
        setTimeout(async () => {
          try {
            // Use a simplified version of calculatePercentile that uses exact path
            const scoresRef = ref(db, `vine/puzzles/${currentPuzzle.id}/scores`);
            const scoresSnapshot = await get(scoresRef);
            
            if (!scoresSnapshot.exists()) {
              percentileElement.innerHTML = `Congratulations! You're the first to complete this puzzle!`;
              setupShareButton({ 
                percentile: 100, 
                totalPlayers: 1, 
                isFirst: true 
              });
              return;
            }
            
            // Count valid scores and calculate percentile
            const scores = [];
            scoresSnapshot.forEach(childSnapshot => {
              const scoreData = childSnapshot.val();
              if (scoreData && typeof scoreData.timeInSeconds === 'number' && typeof scoreData.mistakes === 'number') {
                const compositeScore = scoreData.timeInSeconds + (scoreData.mistakes * 10);
                scores.push(compositeScore);
              }
            });
            
            if (scores.length === 0) {
              percentileElement.innerHTML = `Congratulations! You're the first to complete this puzzle!`;
              setupShareButton({ 
                percentile: 100, 
                totalPlayers: 1, 
                isFirst: true 
              });
              return;
            }
            
            // Calculate user's score and percentile
            const userCompositeScore = displayTime + (mistakeCount * 10);
            const totalPlayers = scores.length;
            
            if (totalPlayers <= 1) {
              percentileElement.innerHTML = `Congratulations! You're the first to complete this puzzle!`;
              setupShareButton({ 
                percentile: 100, 
                totalPlayers: 1, 
                isFirst: true 
              });
              return;
            }
            
            // Sort scores (lower is better)
            scores.sort((a, b) => a - b);
            
            // Calculate percentile (higher percentile means better performance)
            const betterThanCount = scores.filter(score => score > userCompositeScore).length;
            const percentile = Math.round((betterThanCount / totalPlayers) * 100);
            
            const suffix = getOrdinalSuffix(percentile);
            percentileElement.innerHTML = 
              `That places you in the <strong>${percentile}${suffix}</strong> percentile ` +
              `of <strong>${totalPlayers}</strong> players so far`;
            
            setupShareButton({
              percentile,
              totalPlayers,
              isFirst: false
            });
          } catch (error) {
            console.error("Error calculating percentile:", error);
            percentileElement.innerHTML = `You've completed this puzzle! Rankings currently unavailable.`;
            setupShareButton(null);
          }
        }, 2000);
      } catch (error) {
        console.error("Error in completion process:", error);
        percentileElement.innerHTML = `You've completed this puzzle! Rankings currently unavailable.`;
        setupShareButton(null);
      }
    }
    
    // Helper function to get ordinal suffix (1st, 2nd, 3rd, etc.)
    function getOrdinalSuffix(num) {
      const j = num % 10;
      const k = num % 100;
      if (j === 1 && k !== 11) return "st";
      if (j === 2 && k !== 12) return "nd";
      if (j === 3 && k !== 13) return "rd";
      return "th";
    }
    
    // Apply wave animation to all visible vines
    function applyVineWaveAnimation() {
      // Get all vine containers
      const vineContainers = document.querySelectorAll('.vine-container.visible');
      
      // Apply the animation with staggered delays
      vineContainers.forEach((container, index) => {
        setTimeout(() => {
          // Add classes to the container for wave animation
          container.classList.add('vine-wave');
          
          // For SVG leaf wiggling, we need to add the class to the SVG element
          const img = container.querySelector('.vine-svg');
          if (img) {
            // Create a div wrapper with the animation class
            const animationWrapper = document.createElement('div');
            animationWrapper.className = 'leaf-wiggle';
            
            // Replace the img with a direct SVG inclusion for better animation control
            fetch('/images/vine_animation.svg')
              .then(response => response.text())
              .then(svgContent => {
                animationWrapper.innerHTML = svgContent;
                // Replace the image with the actual SVG content
                img.parentNode.replaceChild(animationWrapper, img);
              })
              .catch(error => {
                console.error('Error fetching SVG:', error);
              });
          }
        }, index * 200); // Stagger the animation starts
      });
    }
    
    // Format time in minutes and seconds
    function formatTime(totalSeconds) {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}m ${seconds}s`;
    }
    
    // Set up share button
    function setupShareButton(percentileData) {
      // Create share text with percentile data if available
      const shareText = createShareText(percentileData);
      
      // Create the copyable element
      const { container, shareBtn, textElement } = createCopyableResult(shareText);
      
      // Replace existing button
      shareButton.innerHTML = '';
      shareButton.appendChild(container);
      
      // Set up click handler
      shareBtn.addEventListener('click', () => {
        // On mobile, use native share if available
        if (navigator.share && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
          navigator.share({
            text: shareText,
          })
          .then(() => {
            console.log('Successfully shared');
          })
          .catch((error) => {
            console.error('Error sharing:', error);
            // Fallback to copy
            copyToClipboard(shareText, shareBtn);
          });
        } else {
          // On desktop, copy to clipboard
          copyToClipboard(shareText, shareBtn);
        }
      });
    }
    
    // Create share text
    function createShareText(percentileData) {
      // Get puzzle title
      const puzzleTitle = currentPuzzle.name || 'Daily Puzzle';
      
      // Get time taken from localStorage
      const savedTimeStr = localStorage.getItem(`vine_time_${currentPuzzle.id}`);
      const timeTaken = savedTimeStr ? parseInt(savedTimeStr, 10) : 0;
      
      console.log(`Creating share text with time: ${timeTaken}s`);
      
      // Create emoji representation of the word ladder
      const totalRungs = currentPuzzle.ladder.length;
      
      // Build the emoji ladder - green squares for solved, white for unsolved
      const ladderEmoji = Array(totalRungs).fill('⬜️')
        .map((square, index) => solvedPositions.has(index) ? '🟩' : '⬜️')
        .join('');
      
      // Build the share text
      let shareText = `🌿 Word Vine 🌿\n`;
      shareText += `[${puzzleTitle}]\n\n`;
      shareText += `Solved with ${mistakeCount} mistake${mistakeCount !== 1 ? 's' : ''} in ${timeTaken}s!\n\n`;
      
      // Add percentile info if we have it
      if (percentileData) {
        if (percentileData.calculating) {
          // Still calculating, don't add percentile info yet
          shareText += `Try solving this puzzle yourself!\n\n`;
        } else if (percentileData.isFirst) {
          // First to complete
          shareText += `I'm the first to complete this puzzle! 🥇\n\n`;
        } else if (percentileData.totalPlayers > 1 && percentileData.percentile !== null) {
          // Normal case with percentile info
          const suffix = getOrdinalSuffix(percentileData.percentile);
          shareText += `That places me in the ${percentileData.percentile}${suffix} percentile of ${percentileData.totalPlayers} players so far\n\n`;
        } else if (percentileData.error) {
          // Error occurred during percentile calculation
          shareText += `Try solving this puzzle yourself!\n\n`;
        } else {
          // No percentile data available
          shareText += `Try solving this puzzle yourself!\n\n`;
        }
      } else {
        // No percentile data available
        shareText += `Try solving this puzzle yourself!\n\n`;
      }
      
      shareText += `${ladderEmoji}\n\n`;
      shareText += `eviltrivia.com/games/vine`;
      
      return shareText;
    }
    
    // Create a stylized copyable element
    function createCopyableResult(shareText) {
      const resultContainer = document.createElement('div');
      resultContainer.className = 'copyable-result';
      resultContainer.style.cssText = `
        margin: 20px auto;
        max-width: 400px;
        padding: 20px;
        background-color: #f8f8f8;
        border: 1px solid #ddd;
        border-radius: 8px;
        text-align: left;
        position: relative;
        font-family: monospace;
        white-space: pre-wrap;
        font-size: 14px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        color: #333; /* Ensuring text is dark for contrast */
      `;
      
      // Add the share button
      const shareBtn = document.createElement('button');
      shareBtn.className = 'share-button';
      shareBtn.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: #2E7D32;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
        font-size: 12px;
        opacity: 0.9;
        transition: all 0.2s;
      `;
      shareBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
          <polyline points="16 6 12 2 8 6"></polyline>
          <line x1="12" y1="2" x2="12" y2="15"></line>
        </svg>
        <span>Share</span>
      `;
      
      // Add the text content
      const textElement = document.createElement('div');
      textElement.innerText = shareText;
      textElement.style.color = '#333'; /* Ensuring text is dark */
      
      // Assemble
      resultContainer.appendChild(shareBtn);
      resultContainer.appendChild(textElement);
      
      return { container: resultContainer, shareBtn, textElement };
    }
    
    // Copy text to clipboard and show feedback
    function copyToClipboard(text, button) {
      navigator.clipboard.writeText(text)
        .then(() => {
          button.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20 6L9 17l-5-5"/>
            </svg>
            <span>Copied!</span>
          `;
          setTimeout(() => {
            button.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16 6 12 2 8 6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
              <span>Share</span>
            `;
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy text: ', err);
          button.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="8" x2="12" y2="12"></line>
              <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <span>Error</span>
          `;
          setTimeout(() => {
            button.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16 6 12 2 8 6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
              <span>Share</span>
            `;
          }, 2000);
        });
    }
    
    // Animate vines for a newly solved position
    function animateVinesForPosition(position) {
      // Check if vine should grow upward (to previous position)
      if (position > 0) {
        const vineId = `vine-${position-1}-${position}`;
        const vineContainer = document.getElementById(vineId);
        
        if (vineContainer) {
          setTimeout(() => {
            vineContainer.classList.add('visible');
            setTimeout(() => {
              vineContainer.classList.add('animate');
            }, 100);
          }, 300); // Slight delay for visual effect
        }
      }
      
      // Check if vine should grow downward (to next position)
      if (position < currentPuzzle.ladder.length - 1) {
        const vineId = `vine-${position}-${position+1}`;
        const vineContainer = document.getElementById(vineId);
        
        if (vineContainer) {
          setTimeout(() => {
            vineContainer.classList.add('visible');
            setTimeout(() => {
              vineContainer.classList.add('animate');
            }, 100);
          }, 300); // Slight delay for visual effect
        }
      }
    }
    
    // Create confetti effect for completion
    function createConfetti() {
      const colors = ['#A5D6A7', '#81C784', '#66BB6A', '#4CAF50', '#43A047', '#388E3C', '#2E7D32'];
      const confettiCount = 100;
      
      for (let i = 0; i < confettiCount; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = `${Math.random() * 100}vw`;
          confetti.style.top = `-20px`;
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          confetti.style.width = `${5 + Math.random() * 10}px`;
          confetti.style.height = `${5 + Math.random() * 10}px`;
          confetti.style.animationDuration = `${3 + Math.random() * 4}s`;
          
          document.body.appendChild(confetti);
          
          // Remove after animation completes
          setTimeout(() => {
            confetti.remove();
          }, 7000);
        }, Math.random() * 1500); // Stagger the confetti appearance
      }
    }
  </script>
</body>
</html> 