<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Evil Trivia - Vine Word Ladder</title>
  <script src="/js/components/autoload-banner.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #2E7D32; /* Forest green background */
      margin-top: 60px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      color: #fff;
      margin-bottom: 10px;
    }
    
    .subtitle {
      text-align: center;
      color: #E8F5E9;
      margin-bottom: 20px;
      font-size: 16px;
      line-height: 1.5;
    }
    
    .subtitle a {
      color: #fff;
      text-decoration: underline;
      font-weight: bold;
    }
    
    .subtitle a:hover {
      color: #C8E6C9;
    }

    .game-card {
      background: white;
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-top: 20px;
      position: relative;
    }
    
    .date-display {
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
      color: #777;
    }
    
    .word-ladder {
      margin: 30px 0;
    }
    
    .ladder-rung {
      display: flex;
      margin-bottom: 15px;
      align-items: center;
      position: relative; /* Added for positioning vines */
    }
    
    .ladder-position {
      width: 30px;
      text-align: center;
      font-weight: bold;
      color: #555;
    }
    
    .ladder-word {
      flex: 1;
      display: flex;
      justify-content: center;
      gap: 5px;
    }
    
    .letter-box {
      width: 40px;
      height: 40px;
      border: 2px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
      text-transform: uppercase;
      background-color: #f8f8f8;
    }
    
    .filled {
      background-color: #C8E6C9;
      border-color: #81C784;
      box-shadow: 0 0 8px rgba(46, 125, 50, 0.4); /* Added subtle glow effect */
      animation: letterFill 0.5s ease-out; /* Added animation when letter appears */
    }
    
    @keyframes letterFill {
      0% { transform: scale(0.8); opacity: 0.5; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .ladder-hint {
      flex: 1;
      padding-left: 15px;
      color: #555;
      font-style: italic;
    }
    
    .answer-form {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin-top: 30px;
    }
    
    .answer-input {
      padding: 12px;
      font-size: 16px;
      border: 2px solid #ddd;
      border-radius: 4px;
      text-align: center;
      text-transform: uppercase;
      width: 80%;
      max-width: 300px;
    }
    
    .submit-btn {
      padding: 12px 30px;
      background-color: #2E7D32;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .submit-btn:hover {
      background-color: #1B5E20;
    }
    
    .status-message {
      margin-top: 20px;
      padding: 15px;
      border-radius: 5px;
      font-weight: bold;
      text-align: center;
    }
    
    .correct {
      background-color: #C8E6C9;
      color: #2E7D32;
    }
    
    .incorrect {
      background-color: #FFCDD2;
      color: #C62828;
    }
    
    .complete {
      background-color: #E8F5E9;
      color: #2E7D32;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      margin-top: 30px;
    }
    
    .score-display {
      margin-top: 20px;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
    }
    
    .share-section {
      margin-top: 30px;
      text-align: center;
    }
    
    .share-button {
      background-color: #1B5E20;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 16px;
      font-weight: bold;
      margin-top: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .share-button:hover {
      background-color: #2E7D32;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .share-button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .no-puzzle {
      text-align: center;
      padding: 30px;
      font-size: 18px;
      color: #555;
    }
    
    .emoji {
      font-size: 32px;
      margin-bottom: 10px;
    }
    
    .loading {
      text-align: center;
      padding: 30px;
      font-size: 18px;
    }
    
    .help-button {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 30px;
      height: 30px;
      background-color: #2E7D32;
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 30px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s;
    }
    
    .help-button:hover {
      background-color: #1B5E20;
    }
    
    .help-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }
    
    .help-popup {
      background-color: white;
      max-width: 500px;
      width: 90%;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      position: relative;
    }
    
    .help-popup h3 {
      margin-top: 0;
      color: #333;
    }
    
    .help-popup p {
      color: #555;
      line-height: 1.5;
    }
    
    .close-button {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 24px;
      height: 24px;
      background-color: #f0f0f0;
      color: #333;
      border-radius: 50%;
      text-align: center;
      line-height: 24px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close-button:hover {
      background-color: #e0e0e0;
    }
    
    /* Media queries for mobile */
    @media (max-width: 480px) {
      .ladder-rung {
        flex-direction: column;
      }
      
      .ladder-hint {
        padding-left: 0;
        text-align: center;
        margin-top: 10px;
      }
      
      .letter-box {
        width: 30px;
        height: 30px;
        font-size: 16px;
      }
      
      .vine-container {
        display: none; /* Hide vines on small screens for simplicity */
      }
    }
    
    /* Navigation buttons */
    .navigation-buttons {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
    }
    
    .nav-button {
      padding: 8px 15px;
      background-color: #2E7D32;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .nav-button:hover:not(:disabled) {
      background-color: #1B5E20;
    }
    
    .nav-button:disabled {
      background-color: #A5D6A7;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    /* Vine Animation Styles */
    .vine-container {
      position: absolute;
      left: 12px; /* Adjusted for wider vine */
      width: 30px; /* Increased from 20px */
      height: 0; /* Initially 0 height */
      overflow: hidden;
      transition: height 1.2s ease-in-out;
      z-index: 1;
    }
    
    .vine-container.visible {
      height: 70px; /* Increased from 60px */
    }
    
    .vine-svg {
      width: 100%;
      height: 100%;
    }
    
    .vine-svg path {
      stroke-dasharray: 300;
      stroke-dashoffset: 300;
      transition: stroke-dashoffset 1.5s ease-in-out;
    }
    
    .vine-container.animate .vine-svg path {
      stroke-dashoffset: 0;
    }
    
    /* Confetti effect for completion */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #A5D6A7;
      animation: confetti-fall linear forwards;
      z-index: 100;
      opacity: 0.8;
    }
    
    @keyframes confetti-fall {
      to {
        transform: translateY(100vh) rotate(720deg);
      }
    }
    
    /* Wave animation for completed vine */
    .vine-wave {
      animation: vine-wave 3s ease-in-out infinite;
      transform-origin: center;
    }
    
    @keyframes vine-wave {
      0% {
        transform: translateX(0) rotate(0deg);
      }
      25% {
        transform: translateX(2px) rotate(1deg);
      }
      50% {
        transform: translateX(-2px) rotate(-1deg);
      }
      75% {
        transform: translateX(3px) rotate(1.5deg);
      }
      100% {
        transform: translateX(0) rotate(0deg);
      }
    }
    
    /* Leaf wiggle animation for completed vine */
    .leaf-wiggle .vine-leaf-1,
    .leaf-wiggle .vine-leaf-2,
    .leaf-wiggle .vine-leaf-3 {
      animation: leaf-wiggle 2.5s ease-in-out infinite;
      transform-origin: center;
    }
    
    .leaf-wiggle .vine-leaf-2 {
      animation-delay: 0.5s;
    }
    
    .leaf-wiggle .vine-leaf-3 {
      animation-delay: 1s;
    }
    
    @keyframes leaf-wiggle {
      0% {
        transform: rotate(0deg) scale(1);
      }
      25% {
        transform: rotate(3deg) scale(1.05);
      }
      50% {
        transform: rotate(-2deg) scale(1);
      }
      75% {
        transform: rotate(2deg) scale(1.02);
      }
      100% {
        transform: rotate(0deg) scale(1);
      }
    }
    
    /* Make sure SVG is displayed properly inside containers */
    .vine-container svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Vine</h1>
    <div class="subtitle">
      A daily word ladder game from Evil Trivia<br>
      Want to play in-person? <a href="https://eviltrivia.com/live/">Click here</a>
    </div>
    
    <div class="game-card" id="gameContainer">
      <!-- Help button and popup -->
      <div class="help-button" id="helpButton">?</div>
      
      <div class="help-overlay" id="helpOverlay">
        <div class="help-popup">
          <div class="close-button" id="closeHelpButton">‚úï</div>
          <h3>How to Play Vine</h3>
          <p>Vine is a word ladder game where you transform one word into another by changing one letter at a time.</p>
          <p>Each step in the ladder has a hint that describes the word you need to form.</p>
          <p>Starting from the given word, each word in the ladder differs from the previous word by exactly one letter.</p>
          <p>For example: CAT ‚Üí CAR ‚Üí BAR ‚Üí BAT</p>
          <p>Enter your guesses in the input box. If correct, the word will be filled in the appropriate position.</p>
          <p>Incorrect guesses will cost you 1 point from your score!</p>
          <p>Try to complete the entire ladder with the highest score possible.</p>
        </div>
      </div>
      
      <div id="loadingMessage" class="loading">
        Loading today's word ladder...
      </div>
      
      <div id="noPuzzleMessage" class="no-puzzle" style="display: none;">
        <div class="emoji">üåø</div>
        <p>There's no active word ladder at the moment. Please check back later!</p>
      </div>
      
      <div id="puzzleContainer" style="display: none;">
        <div id="dateDisplay" class="date-display"></div>
        
        <div class="navigation-buttons">
          <button id="prevButton" class="nav-button" disabled>‚Üê Previous</button>
          <button id="nextButton" class="nav-button" disabled>Next ‚Üí</button>
        </div>
        
        <div id="wordLadder" class="word-ladder">
          <!-- Word ladder rungs will be generated here -->
        </div>
        
        <div id="scoreDisplay" class="score-display">
          Score: <span id="currentScore">10</span>
        </div>
        
        <form id="answerForm" class="answer-form">
          <input type="text" id="answerInput" class="answer-input" placeholder="Enter word" required>
          <button type="submit" class="submit-btn">Submit</button>
        </form>
        
        <div id="statusMessage" class="status-message" style="display: none;"></div>
        
        <div id="completionMessage" class="complete" style="display: none;">
          <h3>Congratulations!</h3>
          <p>You've completed today's word ladder with a score of <span id="finalScore">0</span>!</p>
          
          <div class="share-section">
            <button id="shareButton" class="share-button">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16 6 12 2 8 6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
              Share Results
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
    import { getDatabase, ref, get, set, push, onValue } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-auth.js";
    
    // Initialize help button
    document.addEventListener('DOMContentLoaded', initializeHelpButton);
    
    function initializeHelpButton() {
      const helpButton = document.getElementById('helpButton');
      const helpOverlay = document.getElementById('helpOverlay');
      const closeHelpButton = document.getElementById('closeHelpButton');
      
      if (helpButton && helpOverlay && closeHelpButton) {
        helpButton.addEventListener('click', () => {
          helpOverlay.style.display = 'flex';
        });
        
        closeHelpButton.addEventListener('click', () => {
          helpOverlay.style.display = 'none';
        });
        
        // Close help when clicking outside the popup
        helpOverlay.addEventListener('click', (e) => {
          if (e.target === helpOverlay) {
            helpOverlay.style.display = 'none';
          }
        });
      }
    }
    
    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
        authDomain: "eviltrivia-47664.firebaseapp.com",
        databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
        projectId: "eviltrivia-47664",
        storageBucket: "eviltrivia-47664.appspot.com",
        messagingSenderId: "401826818140",
        appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
        measurementId: "G-2W6RK96Y34"
    };
    
    // Initialize Firebase
    let app, db, auth;
    try {
      app = initializeApp(firebaseConfig);
      db = getDatabase(app);
      auth = getAuth(app);
      console.log("Firebase initialized successfully");
    } catch (error) {
      console.error("Firebase initialization error:", error);
      document.getElementById('loadingMessage').innerHTML = `
        <div class="emoji">üòû</div>
        <p>Error initializing Firebase: ${error.message}</p>
        <p>Please try refreshing the page.</p>
      `;
    }
    
    // DOM elements
    const loadingMessage = document.getElementById('loadingMessage');
    const noPuzzleMessage = document.getElementById('noPuzzleMessage');
    const puzzleContainer = document.getElementById('puzzleContainer');
    const wordLadder = document.getElementById('wordLadder');
    const dateDisplay = document.getElementById('dateDisplay');
    const answerForm = document.getElementById('answerForm');
    const answerInput = document.getElementById('answerInput');
    const statusMessage = document.getElementById('statusMessage');
    const scoreDisplay = document.getElementById('currentScore');
    const finalScore = document.getElementById('finalScore');
    const completionMessage = document.getElementById('completionMessage');
    const shareButton = document.getElementById('shareButton');
    const prevButton = document.getElementById('prevButton');
    const nextButton = document.getElementById('nextButton');
    
    // Game state
    let currentPuzzle = null;
    let currentUserId = null;
    let userProgress = [];
    let currentScore = 10; // Start with 10 points
    let solvedPositions = new Set();
    let hasCompleted = false;
    let startTime = null;
    let endTime = null;
    let mistakeCount = 0;
    let puzzleHistory = [];
    let currentPuzzleIndex = -1;
    
    // Check if user is logged in
    onAuthStateChanged(auth, (user) => {
      if (user) {
        currentUserId = user.uid;
        console.log("User logged in with UID:", user.uid);
        
        // Check admin status using the proper Firebase pattern
        const userRef = ref(db, `users/${user.uid}`);
        get(userRef).then((snapshot) => {
          const userData = snapshot.val() || {};
          const isAdmin = userData.role === 'admin';
          window.isAdmin = isAdmin;
          
          if (isAdmin) {
            console.log("User has admin privileges");
          }
          
          // Load the active word ladder
          loadActiveWordLadder();
        }).catch((error) => {
          console.error("Error checking admin status:", error);
          // Still load the game even if admin check fails
          window.isAdmin = false;
          loadActiveWordLadder();
        });
      } else {
        currentUserId = null;
        window.isAdmin = false;
        
        // Load the active word ladder
        loadActiveWordLadder();
      }
    });
    
    // Load the active word ladder
    async function loadActiveWordLadder() {
      try {
        if (!db) {
          throw new Error("Database connection not established");
        }
        
        console.log("Starting to load active word ladder");
        const activeWordLadderRef = ref(db, 'games/vine/activePuzzle');
        
        onValue(activeWordLadderRef, async (snapshot) => {
          try {
            console.log("Active puzzle data received");
            const activePuzzleId = snapshot.val();
            
            if (!activePuzzleId) {
              // No active puzzle
              console.log("No active puzzle found");
              loadingMessage.style.display = 'none';
              noPuzzleMessage.style.display = 'block';
              puzzleContainer.style.display = 'none';
              return;
            }
            
            console.log("Active puzzle ID:", activePuzzleId);
            
            // Get the puzzle details
            const puzzleRef = ref(db, `games/vine/puzzles/${activePuzzleId}`);
            const puzzleSnapshot = await get(puzzleRef);
            currentPuzzle = puzzleSnapshot.val();
            
            if (!currentPuzzle) {
              // Puzzle not found
              console.error("Puzzle not found with ID:", activePuzzleId);
              loadingMessage.style.display = 'none';
              noPuzzleMessage.style.display = 'block';
              noPuzzleMessage.innerHTML = `
                <div class="emoji">üòû</div>
                <p>Puzzle not found. The active puzzle may have been deleted.</p>
              `;
              puzzleContainer.style.display = 'none';
              return;
            }
            
            // Check if puzzle is available
            if (currentPuzzle.available === false) {
              // Puzzle is explicitly marked as unavailable
              console.log("Active puzzle is unavailable");
              loadingMessage.style.display = 'none';
              noPuzzleMessage.style.display = 'block';
              noPuzzleMessage.innerHTML = `
                <div class="emoji">üåø</div>
                <p>Today's word ladder is not available right now. Please check back later!</p>
              `;
              puzzleContainer.style.display = 'none';
              return;
            }
            
            // Ensure ID is set on the puzzle object
            currentPuzzle.id = activePuzzleId;
            
            // Load puzzle history for navigation
            await loadPuzzleHistory();
            
            // Initialize user progress
            initializeUserProgress();
            
            // Show puzzle and hide loading
            loadingMessage.style.display = 'none';
            noPuzzleMessage.style.display = 'none';
            puzzleContainer.style.display = 'block';
            
            // Display date if available
            if (currentPuzzle.date) {
              const date = new Date(currentPuzzle.date);
              const options = { year: 'numeric', month: 'long', day: 'numeric' };
              const formattedDate = date.toLocaleDateString(undefined, options);
              dateDisplay.textContent = formattedDate;
              dateDisplay.style.display = 'block';
            } else {
              dateDisplay.style.display = 'none';
            }
            
            // Display the word ladder
            displayWordLadder();
          } catch (innerError) {
            console.error("Error in onValue callback:", innerError);
            loadingMessage.style.display = 'none';
            noPuzzleMessage.style.display = 'block';
            noPuzzleMessage.innerHTML = `
              <div class="emoji">üòû</div>
              <p>Error loading puzzle: ${innerError.message}</p>
              <p>Please try refreshing the page.</p>
            `;
          }
        }, (error) => {
          console.error("onValue error:", error);
          loadingMessage.style.display = 'none';
          noPuzzleMessage.style.display = 'block';
          noPuzzleMessage.innerHTML = `
            <div class="emoji">üòû</div>
            <p>Error listening for puzzle updates: ${error.message}</p>
            <p>Please try refreshing the page.</p>
          `;
        });
      } catch (error) {
        console.error("Error in loadActiveWordLadder:", error);
        loadingMessage.style.display = 'none';
        noPuzzleMessage.style.display = 'block';
        noPuzzleMessage.innerHTML = `
          <div class="emoji">üòû</div>
          <p>Error loading puzzle: ${error.message}</p>
          <p>Please try refreshing the page or contact support if the issue persists.</p>
        `;
      }
    }
    
    // Load puzzle history
    async function loadPuzzleHistory() {
      try {
        // Get all puzzles
        const puzzlesRef = ref(db, 'games/vine/puzzles');
        const puzzlesSnapshot = await get(puzzlesRef);
        const puzzles = puzzlesSnapshot.val() || {};
        
        // Convert to array and add IDs
        puzzleHistory = Object.entries(puzzles).map(([id, puzzle]) => {
          return { ...puzzle, id };
        });
        
        // Filter to only include available puzzles or the active one
        puzzleHistory = puzzleHistory.filter(puzzle => 
          puzzle.id === currentPuzzle.id || puzzle.available !== false
        );
        
        // Sort by date (oldest first so previous means older)
        puzzleHistory.sort((a, b) => {
          const dateA = a.date ? new Date(a.date) : new Date(0);
          const dateB = b.date ? new Date(b.date) : new Date(0);
          return dateA - dateB; // Oldest first
        });
        
        // Find current puzzle index
        currentPuzzleIndex = puzzleHistory.findIndex(p => p.id === currentPuzzle.id);
        
        // Update navigation buttons
        updateNavigationButtons();
      } catch (error) {
        console.error("Error loading puzzle history:", error);
      }
    }
    
    // Update navigation buttons
    function updateNavigationButtons() {
      // Enable/disable previous button (older puzzles)
      prevButton.disabled = currentPuzzleIndex <= 0;
      
      // Enable/disable next button (newer puzzles)
      nextButton.disabled = currentPuzzleIndex >= puzzleHistory.length - 1;
      
      // Set up click handlers
      prevButton.onclick = () => {
        if (currentPuzzleIndex > 0) {
          navigateToPuzzle(currentPuzzleIndex - 1);
        }
      };
      
      nextButton.onclick = () => {
        if (currentPuzzleIndex < puzzleHistory.length - 1) {
          navigateToPuzzle(currentPuzzleIndex + 1);
        }
      };
    }
    
    // Navigate to a puzzle by index
    function navigateToPuzzle(index) {
      if (index < 0 || index >= puzzleHistory.length) {
        return;
      }
      
      // Save current index and puzzle
      currentPuzzleIndex = index;
      currentPuzzle = puzzleHistory[index];
      
      // Reset game state
      hasCompleted = false;
      completionMessage.style.display = 'none';
      answerForm.style.display = 'flex';
      
      // Initialize user progress for the new puzzle
      initializeUserProgress();
      
      // Update date display
      if (currentPuzzle.date) {
        const date = new Date(currentPuzzle.date);
        const options = { year: 'numeric', month: 'long', day: 'numeric' };
        const formattedDate = date.toLocaleDateString(undefined, options);
        dateDisplay.textContent = formattedDate;
        dateDisplay.style.display = 'block';
      } else {
        dateDisplay.style.display = 'none';
      }
      
      // Update the display
      displayWordLadder();
      
      // Update navigation buttons
      updateNavigationButtons();
    }
    
    // Initialize user progress from localStorage or Firebase
    async function initializeUserProgress() {
      // Reset game state
      userProgress = Array(currentPuzzle.ladder.length).fill(null);
      solvedPositions = new Set();
      hasCompleted = false;
      startTime = Date.now();
      mistakeCount = 0;
      
      // Start with first word already filled
      userProgress[0] = currentPuzzle.ladder[0].word;
      solvedPositions.add(0);
      
      // Check for saved progress in localStorage
      const storageKey = `vine_progress_${currentPuzzle.id}`;
      const savedProgress = localStorage.getItem(storageKey);
      const savedScore = localStorage.getItem(`vine_score_${currentPuzzle.id}`);
      const savedCompleted = localStorage.getItem(`vine_completed_${currentPuzzle.id}`);
      const savedMistakes = localStorage.getItem(`vine_mistakes_${currentPuzzle.id}`);
      
      if (savedProgress) {
        // Restore progress from localStorage
        userProgress = JSON.parse(savedProgress);
        
        // Rebuild solved positions set
        solvedPositions = new Set();
        userProgress.forEach((word, index) => {
          if (word) solvedPositions.add(index);
        });
        
        // Restore score
        if (savedScore) {
          currentScore = parseInt(savedScore, 10);
        }
        
        // Restore mistake count
        if (savedMistakes) {
          mistakeCount = parseInt(savedMistakes, 10);
        }
        
        // Check if already completed
        if (savedCompleted === 'true') {
          hasCompleted = true;
          endTime = Date.now(); // Just a placeholder since we don't have the actual end time
          showCompletionMessage();
        }
      }
      // TODO: Add Firebase sync for logged-in users
      
      // Update the score display
      scoreDisplay.textContent = currentScore;
    }
    
    // Display the word ladder
    function displayWordLadder() {
      // Clear previous content
      wordLadder.innerHTML = '';
      
      // Create ladder rungs
      currentPuzzle.ladder.forEach((rung, index) => {
        const ladderRung = document.createElement('div');
        ladderRung.className = 'ladder-rung';
        ladderRung.setAttribute('data-position', index);
        
        // Position number
        const positionElement = document.createElement('div');
        positionElement.className = 'ladder-position';
        positionElement.textContent = (index + 1);
        ladderRung.appendChild(positionElement);
        
        // Add vine between rungs (except for the first rung)
        if (index > 0) {
          // Create vine container
          const vineContainer = document.createElement('div');
          vineContainer.className = 'vine-container';
          vineContainer.id = `vine-${index-1}-${index}`;
          vineContainer.style.top = `-35px`; // Position to connect with previous rung
          
          // Add the SVG
          vineContainer.innerHTML = `
            <img src="/images/vine_animation.svg" class="vine-svg" alt="Vine connecting words" />
          `;
          
          // Check if this vine should be visible (if previous rung is solved)
          if (solvedPositions.has(index) || solvedPositions.has(index-1)) {
            setTimeout(() => {
              vineContainer.classList.add('visible');
              setTimeout(() => {
                vineContainer.classList.add('animate');
              }, 100);
            }, 10);
          }
          
          ladderRung.appendChild(vineContainer);
        }
        
        // Word (as letter boxes)
        const wordElement = document.createElement('div');
        wordElement.className = 'ladder-word';
        
        const word = userProgress[index] || rung.word;
        const wordLength = word.length;
        
        for (let i = 0; i < wordLength; i++) {
          const letterBox = document.createElement('div');
          letterBox.className = 'letter-box';
          if (userProgress[index]) {
            letterBox.classList.add('filled');
            letterBox.textContent = word[i];
          }
          wordElement.appendChild(letterBox);
        }
        
        ladderRung.appendChild(wordElement);
        
        // Hint
        const hintElement = document.createElement('div');
        hintElement.className = 'ladder-hint';
        hintElement.textContent = rung.hint || '';
        ladderRung.appendChild(hintElement);
        
        wordLadder.appendChild(ladderRung);
      });
      
      // If completed, show completion message
      if (hasCompleted) {
        showCompletionMessage();
      }
    }
    
    // Handle form submission
    answerForm.addEventListener('submit', (e) => {
      e.preventDefault();
      
      if (hasCompleted) {
        return; // Game already completed
      }
      
      const answer = answerInput.value.trim().toUpperCase();
      
      if (!answer) {
        showStatus('Please enter a word', 'incorrect');
        return;
      }
      
      // Check if the answer is valid in the ladder
      checkAnswer(answer);
      
      // Clear input
      answerInput.value = '';
    });
    
    // Check if answer is valid
    function checkAnswer(answer) {
      let isCorrect = false;
      let correctPosition = -1;
      
      // Check against each unsolved word in the ladder
      for (let i = 0; i < currentPuzzle.ladder.length; i++) {
        if (solvedPositions.has(i)) continue; // Skip already solved positions
        
        if (currentPuzzle.ladder[i].word.toUpperCase() === answer) {
          isCorrect = true;
          correctPosition = i;
          break;
        }
      }
      
      if (isCorrect) {
        // Mark as solved
        userProgress[correctPosition] = currentPuzzle.ladder[correctPosition].word;
        solvedPositions.add(correctPosition);
        
        // Save progress
        saveProgress();
        
        // Show success message
        showStatus('Correct! Well done!', 'correct');
        
        // Update display
        displayWordLadder();
        
        // Animate vines for the newly solved position
        animateVinesForPosition(correctPosition);
        
        // Check if all words are solved
        if (solvedPositions.size === currentPuzzle.ladder.length) {
          endTime = Date.now();
          hasCompleted = true;
          localStorage.setItem(`vine_completed_${currentPuzzle.id}`, 'true');
          showCompletionMessage();
          
          // Create confetti for celebration
          createConfetti();
        }
      } else {
        // Deduct point for incorrect answer
        currentScore = Math.max(0, currentScore - 1);
        mistakeCount++;
        scoreDisplay.textContent = currentScore;
        
        // Save score
        localStorage.setItem(`vine_score_${currentPuzzle.id}`, currentScore.toString());
        localStorage.setItem(`vine_mistakes_${currentPuzzle.id}`, mistakeCount.toString());
        
        // Show error message
        showStatus('Incorrect! Try again. (-1 point)', 'incorrect');
      }
    }
    
    // Show status message
    function showStatus(message, type) {
      statusMessage.textContent = message;
      statusMessage.className = 'status-message ' + type;
      statusMessage.style.display = 'block';
      
      // Hide after 3 seconds
      setTimeout(() => {
        statusMessage.style.display = 'none';
      }, 3000);
    }
    
    // Save progress to localStorage
    function saveProgress() {
      const storageKey = `vine_progress_${currentPuzzle.id}`;
      localStorage.setItem(storageKey, JSON.stringify(userProgress));
      localStorage.setItem(`vine_score_${currentPuzzle.id}`, currentScore.toString());
    }
    
    // Show completion message
    function showCompletionMessage() {
      completionMessage.style.display = 'block';
      answerForm.style.display = 'none';
      
      // Calculate time taken
      const timeTaken = endTime - startTime;
      const seconds = Math.floor(timeTaken / 1000);
      
      // Update the final score display
      finalScore.textContent = currentScore;
      
      // Update the completion message with a more modern format
      const statsElement = document.createElement('p');
      statsElement.innerHTML = `You solved this puzzle with <strong>${mistakeCount}</strong> mistake${mistakeCount !== 1 ? 's' : ''} in <strong>${seconds}s</strong>`;
      
      // Insert after the first paragraph in the completion message
      const firstParagraph = completionMessage.querySelector('p');
      if (firstParagraph && firstParagraph.nextSibling) {
        completionMessage.insertBefore(statsElement, firstParagraph.nextSibling);
      } else {
        completionMessage.appendChild(statsElement);
      }
      
      // Add mock percentile information (to be replaced with real data later)
      const mockPercentile = Math.floor(Math.random() * 90) + 10; // Random percentile between 10-99
      const mockPlayerCount = Math.floor(Math.random() * 50) + 5; // Random player count between 5-54
      
      const percentileElement = document.createElement('p');
      percentileElement.innerHTML = `That time places you in the <strong>${mockPercentile}th</strong> percentile of <strong>${mockPlayerCount}</strong> players so far`;
      percentileElement.style.fontSize = '0.9em';
      percentileElement.style.color = '#43A047';
      
      completionMessage.appendChild(percentileElement);
      
      // Apply wave animation to all vine containers
      applyVineWaveAnimation();
      
      // Set up share functionality
      setupShareButton();
      
      // Update localStorage with the completion data
      localStorage.setItem(`vine_time_${currentPuzzle.id}`, seconds.toString());
    }
    
    // Apply wave animation to all visible vines
    function applyVineWaveAnimation() {
      // Get all vine containers
      const vineContainers = document.querySelectorAll('.vine-container.visible');
      
      // Apply the animation with staggered delays
      vineContainers.forEach((container, index) => {
        setTimeout(() => {
          // Add classes to the container for wave animation
          container.classList.add('vine-wave');
          
          // For SVG leaf wiggling, we need to add the class to the SVG element
          const img = container.querySelector('.vine-svg');
          if (img) {
            // Create a div wrapper with the animation class
            const animationWrapper = document.createElement('div');
            animationWrapper.className = 'leaf-wiggle';
            
            // Replace the img with a direct SVG inclusion for better animation control
            fetch('/images/vine_animation.svg')
              .then(response => response.text())
              .then(svgContent => {
                animationWrapper.innerHTML = svgContent;
                // Replace the image with the actual SVG content
                img.parentNode.replaceChild(animationWrapper, img);
              })
              .catch(error => {
                console.error('Error fetching SVG:', error);
              });
          }
        }, index * 200); // Stagger the animation starts
      });
    }
    
    // Format time in minutes and seconds
    function formatTime(totalSeconds) {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}m ${seconds}s`;
    }
    
    // Set up share button
    function setupShareButton() {
      // Create share text
      const shareText = createShareText();
      
      // Create a stylized copyable element
      const { container, shareBtn, textElement } = createCopyableResult(shareText);
      
      // Replace the existing share button
      shareButton.innerHTML = '';
      shareButton.appendChild(container);
      
      // Set up click handler on the new share button
      shareBtn.addEventListener('click', () => {
        // On mobile, use the native share functionality if available
        if (navigator.share && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
          navigator.share({
            text: shareText,
          })
          .then(() => {
            console.log('Successfully shared');
          })
          .catch((error) => {
            console.error('Error sharing:', error);
            // Fallback to copy
            copyToClipboard(shareText, shareBtn);
          });
        } else {
          // On desktop, just copy to clipboard
          copyToClipboard(shareText, shareBtn);
        }
      });
    }
    
    // Create share text
    function createShareText() {
      // Get date for share text
      let dateStr = '';
      if (currentPuzzle.date) {
        const date = new Date(currentPuzzle.date);
        dateStr = date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' });
      }
      
      // Get time taken
      const savedTimeStr = localStorage.getItem(`vine_time_${currentPuzzle.id}`);
      const timeTaken = savedTimeStr ? parseInt(savedTimeStr, 10) : 0;
      
      // Get puzzle title
      const puzzleTitle = currentPuzzle.name || 'Daily Puzzle';
      
      // Create emoji representation of the word ladder
      const totalRungs = currentPuzzle.ladder.length;
      const solvedRungs = solvedPositions.size;
      
      // Build the emoji ladder - green squares for solved, white for unsolved
      const ladderEmoji = Array(totalRungs).fill('‚¨úÔ∏è')
        .map((square, index) => solvedPositions.has(index) ? 'üü©' : '‚¨úÔ∏è')
        .join('');
      
      // Mock percentile data (in real implementation, this would be fetched from the database)
      // This is a placeholder until actual leaderboard functionality is implemented
      // You'll need to implement actual player stats tracking to replace this
      const mockPercentile = Math.floor(Math.random() * 90) + 10; // Random percentile between 10-99
      const mockPlayerCount = Math.floor(Math.random() * 50) + 5; // Random player count between 5-54
      
      // Build the share text
      let shareText = `üåø Word Vine üåø\n`;
      shareText += `[${puzzleTitle}]\n\n`;
      shareText += `Solved with ${mistakeCount} mistake${mistakeCount !== 1 ? 's' : ''} in ${timeTaken}s!\n\n`;
      
      // Add percentile info
      shareText += `That time places me in the ${mockPercentile}th percentile of ${mockPlayerCount} players so far\n\n`;
      
      // Add emoji boxes
      shareText += `${ladderEmoji}\n\n`;
      
      // Add URL
      shareText += `eviltrivia.com/games/vine`;
      
      return shareText;
    }
    
    // Create a stylized copyable element
    function createCopyableResult(shareText) {
      const resultContainer = document.createElement('div');
      resultContainer.className = 'copyable-result';
      resultContainer.style.cssText = `
        margin: 20px auto;
        max-width: 400px;
        padding: 20px;
        background-color: #f8f8f8;
        border: 1px solid #ddd;
        border-radius: 8px;
        text-align: left;
        position: relative;
        font-family: monospace;
        white-space: pre-wrap;
        font-size: 14px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        color: #333; /* Ensuring text is dark for contrast */
      `;
      
      // Add the share button
      const shareBtn = document.createElement('button');
      shareBtn.className = 'share-button';
      shareBtn.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: #2E7D32;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
        font-size: 12px;
        opacity: 0.9;
        transition: all 0.2s;
      `;
      shareBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
          <polyline points="16 6 12 2 8 6"></polyline>
          <line x1="12" y1="2" x2="12" y2="15"></line>
        </svg>
        <span>Share</span>
      `;
      
      // Add the text content
      const textElement = document.createElement('div');
      textElement.innerText = shareText;
      textElement.style.color = '#333'; /* Ensuring text is dark */
      
      // Assemble
      resultContainer.appendChild(shareBtn);
      resultContainer.appendChild(textElement);
      
      return { container: resultContainer, shareBtn, textElement };
    }
    
    // Copy text to clipboard and show feedback
    function copyToClipboard(text, button) {
      navigator.clipboard.writeText(text)
        .then(() => {
          button.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20 6L9 17l-5-5"/>
            </svg>
            <span>Copied!</span>
          `;
          setTimeout(() => {
            button.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16 6 12 2 8 6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
              <span>Share</span>
            `;
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy text: ', err);
          button.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="8" x2="12" y2="12"></line>
              <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <span>Error</span>
          `;
          setTimeout(() => {
            button.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16 6 12 2 8 6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
              <span>Share</span>
            `;
          }, 2000);
        });
    }
    
    // Animate vines for a newly solved position
    function animateVinesForPosition(position) {
      // Check if vine should grow upward (to previous position)
      if (position > 0) {
        const vineId = `vine-${position-1}-${position}`;
        const vineContainer = document.getElementById(vineId);
        
        if (vineContainer) {
          setTimeout(() => {
            vineContainer.classList.add('visible');
            setTimeout(() => {
              vineContainer.classList.add('animate');
            }, 100);
          }, 300); // Slight delay for visual effect
        }
      }
      
      // Check if vine should grow downward (to next position)
      if (position < currentPuzzle.ladder.length - 1) {
        const vineId = `vine-${position}-${position+1}`;
        const vineContainer = document.getElementById(vineId);
        
        if (vineContainer) {
          setTimeout(() => {
            vineContainer.classList.add('visible');
            setTimeout(() => {
              vineContainer.classList.add('animate');
            }, 100);
          }, 300); // Slight delay for visual effect
        }
      }
    }
    
    // Create confetti effect for completion
    function createConfetti() {
      const colors = ['#A5D6A7', '#81C784', '#66BB6A', '#4CAF50', '#43A047', '#388E3C', '#2E7D32'];
      const confettiCount = 100;
      
      for (let i = 0; i < confettiCount; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = `${Math.random() * 100}vw`;
          confetti.style.top = `-20px`;
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          confetti.style.width = `${5 + Math.random() * 10}px`;
          confetti.style.height = `${5 + Math.random() * 10}px`;
          confetti.style.animationDuration = `${3 + Math.random() * 4}s`;
          
          document.body.appendChild(confetti);
          
          // Remove after animation completes
          setTimeout(() => {
            confetti.remove();
          }, 7000);
        }, Math.random() * 1500); // Stagger the confetti appearance
      }
    }
  </script>
</body>
</html> 