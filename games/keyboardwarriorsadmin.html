<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Evil Trivia - Keyboard Warriors Admin</title>
    <script src="/js/components/autoload-banner.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 30px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            margin-top: 60px;
            min-height: 100vh;
            color: #fff;
        }
        .hidden {
            display: none;
        }
        .section {
            border: 4px solid #0ff;
            padding: 20px;
            margin-top: 15px;
            background-color: #0f3460;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            max-width: 1200px;
        }
        h1, h2 {
            margin-top: 0;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 24px;
            line-height: 1.5;
        }
        h2 {
            font-size: 16px;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-size: 10px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }
        button {
            padding: 12px 20px;
            font-size: 10px;
            font-family: 'Press Start 2P', cursive;
            background-color: #e94560;
            color: white;
            border: 3px solid #0ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            transition: all 0.1s;
        }
        button:hover {
            background-color: #ff0066;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.8);
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
        }
        input[type="text"], 
        input[type="date"],
        select,
        textarea {
            padding: 10px;
            border: 3px solid #0ff;
            font-size: 10px;
            font-family: 'Press Start 2P', cursive;
            background: #1a1a2e;
            color: #fff;
        }
        input:focus, select:focus, textarea:focus {
            outline: 3px solid #f0f;
            box-shadow: 0 0 15px #f0f;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #16213e;
            padding: 15px;
            border: 3px solid #0ff;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        .stat-value {
            font-size: 20px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }
        .stat-label {
            font-size: 8px;
            color: #0ff;
            margin-top: 8px;
            line-height: 1.5;
        }
        .table-container {
            margin-top: 20px;
            overflow-x: auto;
            background: #1a1a2e;
            border: 3px solid #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: #1a1a2e;
        }
        th, td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 2px solid #0ff;
            font-size: 8px;
            line-height: 1.5;
            color: #fff;
        }
        th {
            background-color: #0f3460;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            position: sticky;
            top: 0;
            z-index: 10;
            border-bottom: 3px solid #0ff;
        }
        tr:nth-child(even) {
            background-color: rgba(15, 52, 96, 0.3);
        }
        tr:hover {
            background-color: rgba(0, 255, 255, 0.1);
        }
        .score-cell {
            font-weight: bold;
            text-align: center;
            font-size: 10px;
        }
        .score-top {
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        .score-good {
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        .score-medium {
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
        }
        .score-low {
            color: #f00;
            text-shadow: 0 0 5px #f00;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 12px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            line-height: 1.8;
        }
        .error {
            background: #e94560;
            color: #fff;
            padding: 15px;
            margin-bottom: 20px;
            border: 3px solid #f00;
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
            font-size: 10px;
            line-height: 1.8;
        }
        .no-data {
            text-align: center;
            padding: 40px;
            color: #0ff;
            font-size: 12px;
            text-shadow: 0 0 10px #0ff;
            line-height: 1.8;
        }
        .refresh-info {
            font-size: 8px;
            color: #0ff;
            text-align: center;
            margin-top: 10px;
            text-shadow: 0 0 5px #0ff;
            line-height: 1.8;
        }
        .btn-delete {
            background-color: #e94560;
            color: white;
            padding: 8px 12px;
            font-size: 8px;
            border: 2px solid #f00;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.3);
        }
        .btn-delete:hover {
            background-color: #ff0066;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.8);
        }
        a {
            color: #0ff;
            text-decoration: none;
            text-shadow: 0 0 5px #0ff;
        }
        a:hover {
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            h1 {
                font-size: 16px;
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .stats {
                grid-template-columns: 1fr 1fr;
            }
            th, td {
                padding: 8px 4px;
                font-size: 7px;
            }
        }
    </style>
</head>
<body>
    <h1>⌨️ KEYBOARD WARRIORS ADMIN ⌨️</h1>

    <div id="authContainer" class="section">
        <h2>AUTHENTICATION REQUIRED</h2>
        <p style="color: #fff; font-size: 10px; line-height: 1.8;">Please log in with your admin account to access this page.</p>
        <p style="margin-top: 15px;"><a href="/pages/account.html">Go to Account Page</a></p>
    </div>

    <div id="adminContainer" class="hidden">
        <!-- Session Management -->
        <div class="section">
            <h2>SESSION MANAGEMENT</h2>
            <p style="color: #fff; font-size: 9px; line-height: 1.6; margin-bottom: 15px;">
                Load sessions from the grading page. You can activate one session per location.
            </p>
            <div class="controls">
                <div class="control-group">
                    <label for="sessionLocationFilter">LOCATION:</label>
                    <select id="sessionLocationFilter" onchange="filterSessionsByLocation()">
                        <option value="">All Locations</option>
                        <option value="St. Dymphna's">St. Dymphna's</option>
                        <option value="Radegast Hall">Radegast Hall</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="existingSessionSelect">SELECT SESSION:</label>
                    <select id="existingSessionSelect">
                        <option value="">Select a session...</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button onclick="activateSession()">ACTIVATE SESSION</button>
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button onclick="loadExistingSessions()">REFRESH SESSIONS</button>
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button onclick="clearAllSessions()" style="background-color: #e94560; border-color: #f00;">CLEAR ALL</button>
                </div>
            </div>
            <div id="activeSessionsInfo" style="margin-top: 15px; padding: 15px; background: rgba(0, 255, 255, 0.1); border: 2px solid #0ff;">
                <strong style="color: #0ff; text-shadow: 0 0 5px #0ff;">ACTIVE SESSIONS:</strong>
                <div id="activeSessionsList" style="color: #fff; margin-top: 10px; font-size: 9px; line-height: 1.8;">
                    None
                </div>
            </div>
        </div>

        <!-- Paragraph Management -->
        <div class="section">
            <h2>TYPING PARAGRAPH SETTINGS</h2>
            <p style="color: #fff; font-size: 9px; line-height: 1.6; margin-bottom: 15px;">
                Set the paragraph that players will type. Leave blank to use random words.
            </p>
            <div style="margin-bottom: 15px;">
                <label for="typingParagraph" style="display: block; margin-bottom: 10px; font-size: 10px; color: #0ff;">PARAGRAPH TEXT:</label>
                <textarea 
                    id="typingParagraph" 
                    rows="6" 
                    placeholder="Enter the paragraph here..."
                    style="width: 100%; padding: 15px; font-size: 12px; font-family: 'Press Start 2P', cursive; background: #1a1a2e; border: 3px solid #0ff; color: #fff; line-height: 1.8; resize: vertical;"
                ></textarea>
                <div style="margin-top: 10px; font-size: 8px; color: #0ff;">
                    Character count: <span id="charCount">0</span> | Word count: <span id="wordCount">0</span>
                </div>
            </div>
            <div class="controls">
                <button onclick="saveParagraph()">SAVE PARAGRAPH</button>
                <button onclick="loadParagraph()" style="background-color: #533483;">LOAD CURRENT</button>
                <button onclick="clearParagraph()" style="background-color: #e94560; border-color: #f00;">CLEAR</button>
            </div>
            <div id="paragraphMessage" style="margin-top: 15px; padding: 10px; background: rgba(0, 255, 0, 0.2); border: 2px solid #0f0; display: none; font-size: 9px;">
                Paragraph saved successfully!
            </div>
        </div>

        <!-- Scores Section -->
        <div class="section">
        <div class="controls">
            <div class="control-group">
                <label for="barFilter">FILTER BY BAR:</label>
                <select id="barFilter">
                    <option value="">All Locations</option>
                    <option value="St. Dymphna's">St. Dymphna's</option>
                    <option value="Radegast Hall">Radegast Hall</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="dateFilter">FILTER BY DATE:</label>
                <input type="date" id="dateFilter">
            </div>
            
            <div class="control-group">
                <label for="teamFilter">SEARCH TEAM:</label>
                <input type="text" id="teamFilter" placeholder="Team name...">
            </div>
            
            <div class="control-group">
                <label for="sortBy">SORT BY:</label>
                <select id="sortBy">
                    <option value="time-asc">Time (Fastest First)</option>
                    <option value="time-desc">Time (Slowest First)</option>
                    <option value="timestamp-desc">Most Recent</option>
                    <option value="timestamp-asc">Oldest</option>
                    <option value="teamName-asc">Team Name A-Z</option>
                    <option value="teamName-desc">Team Name Z-A</option>
                    <option value="location-asc">Location A-Z</option>
                    <option value="location-desc">Location Z-A</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>&nbsp;</label>
                <button onclick="loadScores()">REFRESH DATA</button>
            </div>
        </div>

        <div id="statsSection" class="stats hidden">
            <div class="stat-card">
                <div class="stat-value" id="totalScores">0</div>
                <div class="stat-label">TOTAL GAMES</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="averageTime">0s</div>
                <div class="stat-label">AVERAGE TIME</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="fastestTime">0s</div>
                <div class="stat-label">FASTEST TIME</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="todayScores">0</div>
                <div class="stat-label">TODAY'S GAMES</div>
            </div>
        </div>

        <div id="errorMessage" class="error hidden"></div>
        
        <div id="loadingMessage" class="loading">
            Click "REFRESH DATA" to load scores...
        </div>

        <div id="noDataMessage" class="no-data hidden">
            No scores found matching the current filters.
        </div>

        <div class="table-container">
            <table id="scoresTable" class="hidden">
                <thead>
                    <tr>
                        <th>TEAM NAME</th>
                        <th>LOCATION</th>
                        <th>TIME (s)</th>
                        <th>DATE</th>
                        <th>ACTION</th>
                    </tr>
                </thead>
                <tbody id="scoresTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="refresh-info">
            LAST UPDATED: <span id="lastUpdate">Never</span>
        </div>
    </div>
    </div> <!-- End adminContainer -->

    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
        import { getDatabase, ref, get, remove, set } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
            authDomain: "eviltrivia-47664.firebaseapp.com",
            databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
            projectId: "eviltrivia-47664",
            storageBucket: "eviltrivia-47664.firebaseapp.com",
            messagingSenderId: "401826818140",
            appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
            measurementId: "G-2W6RK96Y34"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
        window.db = db;
        window.dbRef = ref;
        window.dbGet = get;
        window.dbRemove = remove;
        window.dbSet = set;

        // Authentication check
        onAuthStateChanged(auth, async (user) => {
            const authContainer = document.getElementById('authContainer');
            const adminContainer = document.getElementById('adminContainer');
            
            if (user) {
                console.log("User is signed in:", user.uid);
                try {
                    const userRoleRef = ref(db, `users/${user.uid}/role`);
                    const roleSnapshot = await get(userRoleRef);
                    
                    console.log("Role check - exists:", roleSnapshot.exists(), "value:", roleSnapshot.val());
                    
                    if (roleSnapshot.exists() && roleSnapshot.val() === 'admin') {
                        console.log("Admin access granted");
                        authContainer.style.display = 'none';
                        adminContainer.classList.remove('hidden');
                        window.loadScores();
                    } else {
                        console.log("User is not admin");
                        authContainer.style.display = 'block';
                        adminContainer.classList.add('hidden');
                    }
                } catch (error) {
                    console.error("Error checking user role:", error);
                    authContainer.style.display = 'block';
                    adminContainer.classList.add('hidden');
                }
            } else {
                console.log("No user signed in");
                authContainer.style.display = 'block';
                adminContainer.classList.add('hidden');
            }
        });
    </script>

    <script>
        let allScores = [];
        let filteredScores = [];

        // DOM elements
        const barFilter = document.getElementById('barFilter');
        const dateFilter = document.getElementById('dateFilter');
        const teamFilter = document.getElementById('teamFilter');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessage = document.getElementById('errorMessage');
        const noDataMessage = document.getElementById('noDataMessage');
        const scoresTable = document.getElementById('scoresTable');
        const scoresTableBody = document.getElementById('scoresTableBody');
        const statsSection = document.getElementById('statsSection');
        const lastUpdate = document.getElementById('lastUpdate');

        // Stats elements
        const totalScoresEl = document.getElementById('totalScores');
        const averageTimeEl = document.getElementById('averageTime');
        const fastestTimeEl = document.getElementById('fastestTime');
        const todayScoresEl = document.getElementById('todayScores');

        // Event listeners
        barFilter.addEventListener('change', applyFilters);
        dateFilter.addEventListener('change', applyFilters);
        teamFilter.addEventListener('input', applyFilters);
        document.getElementById('sortBy').addEventListener('change', applySorting);

        // Make loadScores available globally for the module script
        window.loadScores = loadScores;

        async function loadScores() {
            showLoading();
            hideError();

            try {
                allScores = [];

                // Load from main path
                const mainRef = window.dbRef(window.db, 'games/keyboardwarriors/answers');
                const mainSnap = await window.dbGet(mainRef);
                if (mainSnap.exists()) {
                    const data = mainSnap.val();
                    Object.keys(data).forEach(key => {
                        const score = data[key];
                        score.id = key;
                        score.source = 'main';
                        allScores.push(score);
                    });
                }

                // Load from public path
                const publicRef = window.dbRef(window.db, 'publicAnswers/keyboardwarriors');
                const publicSnap = await window.dbGet(publicRef);
                if (publicSnap.exists()) {
                    const data = publicSnap.val();
                    Object.keys(data).forEach(key => {
                        const score = data[key];
                        score.id = key;
                        score.source = 'public';
                        allScores.push(score);
                    });
                }

                hideLoading();
                applyFilters();
                updateLastRefresh();

            } catch (error) {
                console.error('Error loading scores:', error);
                showError('Failed to load scores: ' + error.message);
                hideLoading();
            }
        }

        async function applyFilters() {
            const barValue = barFilter.value;
            const dateValue = dateFilter.value;
            const teamValue = teamFilter.value.toLowerCase().trim();

            // Get active session team names
            let activeTeamNames = new Set();
            try {
                const activeSessionsSnap = await window.dbGet(window.dbRef(window.db, 'games/keyboardwarriors/activeSessions'));
                if (activeSessionsSnap.exists()) {
                    const activeSessions = activeSessionsSnap.val();
                    for (const locationKey in activeSessions) {
                        const sessionData = activeSessions[locationKey];
                        if (sessionData.teams && Array.isArray(sessionData.teams)) {
                            sessionData.teams.forEach(team => activeTeamNames.add(team));
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading active teams:', error);
            }

            filteredScores = allScores.filter(score => {
                // Only show scores from teams in active sessions
                if (activeTeamNames.size > 0 && !activeTeamNames.has(score.teamName)) {
                    return false;
                }

                // Bar filter
                if (barValue && score.barLocation !== barValue) {
                    return false;
                }

                // Date filter
                if (dateValue && score.date !== dateValue) {
                    return false;
                }

                // Team filter
                if (teamValue && !score.teamName.toLowerCase().includes(teamValue)) {
                    return false;
                }

                return true;
            });

            applySorting();
        }

        function applySorting() {
            const sortBy = document.getElementById('sortBy').value;
            const [field, direction] = sortBy.split('-');

            filteredScores.sort((a, b) => {
                let aVal, bVal;

                switch(field) {
                    case 'time':
                        aVal = a.timeSeconds || 999999;
                        bVal = b.timeSeconds || 999999;
                        break;
                    case 'timestamp':
                        aVal = a.timestamp || 0;
                        bVal = b.timestamp || 0;
                        break;
                    case 'teamName':
                        aVal = (a.teamName || '').toLowerCase();
                        bVal = (b.teamName || '').toLowerCase();
                        break;
                    case 'location':
                        aVal = (a.barLocation || '').toLowerCase();
                        bVal = (b.barLocation || '').toLowerCase();
                        break;
                    default:
                        return 0;
                }

                if (direction === 'asc') {
                    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                } else {
                    return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                }
            });

            updateDisplay();
        }

        function updateDisplay() {
            if (filteredScores.length === 0) {
                showNoData();
                hideTable();
                hideStats();
            } else {
                hideNoData();
                showTable();
                showStats();
                populateTable();
                updateStats();
            }
        }

        function populateTable() {
            scoresTableBody.innerHTML = '';

            filteredScores.forEach((score, index) => {
                const row = document.createElement('tr');
                
                const timeSeconds = score.timeSeconds || 0;
                const date = score.date || 'Unknown';
                
                const timeClass = getScoreClass(timeSeconds, index);
                
                row.innerHTML = `
                    <td><strong>${escapeHtml(score.teamName || 'Unknown')}</strong></td>
                    <td>${escapeHtml(score.barLocation || 'Unknown')}</td>
                    <td class="score-cell ${timeClass}">${timeSeconds}s</td>
                    <td>${date}</td>
                    <td style="text-align: center;">
                        <button class="btn-delete" onclick="deleteScore('${score.id}', '${score.source}')">DELETE</button>
                    </td>
                `;
                
                scoresTableBody.appendChild(row);
            });
        }

        function updateStats() {
            const total = filteredScores.length;
            const times = filteredScores.map(s => s.timeSeconds || 0).filter(t => t > 0);
            
            const avgTime = times.length > 0 ? Math.round(times.reduce((a, b) => a + b, 0) / times.length) : 0;
            const fastestTime = times.length > 0 ? Math.min(...times) : 0;
            
            const today = new Date().toISOString().split('T')[0];
            const todayCount = filteredScores.filter(s => s.date === today).length;

            totalScoresEl.textContent = total;
            averageTimeEl.textContent = avgTime + 's';
            fastestTimeEl.textContent = fastestTime + 's';
            todayScoresEl.textContent = todayCount;
        }

        function getScoreClass(time, rank) {
            if (rank < 3) return 'score-top';
            if (time <= 30) return 'score-good';
            if (time <= 60) return 'score-medium';
            return 'score-low';
        }

        async function deleteScore(scoreId, source) {
            if (!confirm('Are you sure you want to delete this score? This action cannot be undone.')) {
                return;
            }
            
            try {
                let path;
                if (source === 'main') {
                    path = `games/keyboardwarriors/answers/${scoreId}`;
                } else {
                    path = `publicAnswers/keyboardwarriors/${scoreId}`;
                }
                
                const scoreRef = window.dbRef(window.db, path);
                await window.dbRemove(scoreRef);
                
                // Remove from local arrays
                allScores = allScores.filter(s => s.id !== scoreId);
                filteredScores = filteredScores.filter(s => s.id !== scoreId);
                
                // Update display
                updateDisplay();
                
                alert('Score deleted successfully');
            } catch (error) {
                console.error('Error deleting score:', error);
                alert('Error deleting score: ' + error.message);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoading() {
            loadingMessage.classList.remove('hidden');
        }

        function hideLoading() {
            loadingMessage.classList.add('hidden');
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function hideError() {
            errorMessage.classList.add('hidden');
        }

        function showNoData() {
            noDataMessage.classList.remove('hidden');
        }

        function hideNoData() {
            noDataMessage.classList.add('hidden');
        }

        function showTable() {
            scoresTable.classList.remove('hidden');
        }

        function hideTable() {
            scoresTable.classList.add('hidden');
        }

        function showStats() {
            statsSection.classList.remove('hidden');
        }

        function hideStats() {
            statsSection.classList.add('hidden');
        }

        function updateLastRefresh() {
            lastUpdate.textContent = new Date().toLocaleString();
        }

        // Session management functions
        let allSessions = [];
        let filteredSessions = [];

        async function loadExistingSessions() {
            try {
                const sessionsSnap = await window.dbGet(window.dbRef(window.db, 'grading'));
                allSessions = [];
                
                if (sessionsSnap.exists()) {
                    const sessions = sessionsSnap.val();
                    allSessions = Object.entries(sessions)
                        .map(([id, data]) => ({
                            id: id,
                            location: data.location || 'Unknown',
                            date: data.date || '',
                            triviaNumber: data.triviaNumber || '',
                            triviaName: data.triviaName || ''
                        }))
                        .sort((a, b) => new Date(b.date) - new Date(a.date));
                }
                
                filterSessionsByLocation();
                await displayActiveSessions();
            } catch (error) {
                console.error("Error loading sessions:", error);
                alert("Error loading sessions: " + error.message);
            }
        }

        function filterSessionsByLocation() {
            const locationFilter = document.getElementById('sessionLocationFilter').value;
            const sessionSelect = document.getElementById('existingSessionSelect');
            sessionSelect.innerHTML = '<option value="">Select a session...</option>';
            
            filteredSessions = locationFilter 
                ? allSessions.filter(s => s.location === locationFilter)
                : allSessions;

            filteredSessions.forEach(session => {
                const option = document.createElement('option');
                option.value = session.id;
                option.dataset.location = session.location;
                option.textContent = `${session.date} - ${session.location}${session.triviaName ? ' - ' + session.triviaName : ''}`;
                sessionSelect.appendChild(option);
            });
        }

        function encodeLocationKey(location) {
            return location.replace(/[.#$\[\]']/g, '_');
        }

        async function activateSession() {
            const sessionSelect = document.getElementById('existingSessionSelect');
            const sessionId = sessionSelect.value;
            
            if (!sessionId) {
                alert('Please select a session');
                return;
            }

            try {
                const sessionSnap = await window.dbGet(window.dbRef(window.db, `grading/${sessionId}`));
                if (!sessionSnap.exists()) {
                    alert('Session not found');
                    return;
                }

                const sessionData = sessionSnap.val();
                const location = sessionData.location;
                const locationKey = encodeLocationKey(location);
                
                // Get teams from this session
                const teamsSnap = await window.dbGet(window.dbRef(window.db, `grading/${sessionId}/teams`));
                const teamNames = [];
                if (teamsSnap.exists()) {
                    const teams = teamsSnap.val();
                    Object.values(teams).forEach(team => {
                        if (team.name) {
                            teamNames.push(team.name);
                        }
                    });
                }
                
                // Get current active sessions
                const activeSessionsSnap = await window.dbGet(window.dbRef(window.db, 'games/keyboardwarriors/activeSessions'));
                const activeSessions = activeSessionsSnap.exists() ? activeSessionsSnap.val() : {};
                
                // Set this session for this location with team names
                activeSessions[locationKey] = {
                    sessionId: sessionId,
                    date: sessionData.date,
                    location: location,
                    teams: teamNames
                };
                await window.dbSet(window.dbRef(window.db, 'games/keyboardwarriors/activeSessions'), activeSessions);

                alert(`Session activated for ${location} with ${teamNames.length} teams!`);
                await displayActiveSessions();
            } catch (error) {
                console.error("Error activating session:", error);
                alert("Error activating session: " + error.message);
            }
        }

        async function displayActiveSessions() {
            try {
                const activeSessionsSnap = await window.dbGet(window.dbRef(window.db, 'games/keyboardwarriors/activeSessions'));
                const activeSessionsList = document.getElementById('activeSessionsList');
                
                if (!activeSessionsSnap.exists() || Object.keys(activeSessionsSnap.val()).length === 0) {
                    activeSessionsList.innerHTML = 'None';
                    return;
                }

                const activeSessions = activeSessionsSnap.val();
                let html = '';
                
                for (const [locationKey, sessionData] of Object.entries(activeSessions)) {
                    const displayLocation = sessionData.location || locationKey;
                    const teamCount = sessionData.teams ? sessionData.teams.length : 0;
                    html += `<div style="margin-bottom: 8px;">
                        <strong>${displayLocation}:</strong> ${sessionData.date} (${teamCount} teams)
                        <button onclick="removeSessionForLocation('${locationKey}')" style="margin-left: 10px; padding: 4px 8px; font-size: 7px; background: #e94560; border-color: #f00;">REMOVE</button>
                    </div>`;
                }
                
                activeSessionsList.innerHTML = html || 'None';
            } catch (error) {
                console.error("Error displaying active sessions:", error);
            }
        }

        async function removeSessionForLocation(locationKey) {
            try {
                const activeSessionsSnap = await window.dbGet(window.dbRef(window.db, 'games/keyboardwarriors/activeSessions'));
                if (!activeSessionsSnap.exists()) return;
                
                const activeSessions = activeSessionsSnap.val();
                const displayLocation = activeSessions[locationKey]?.location || locationKey;
                delete activeSessions[locationKey];
                
                if (Object.keys(activeSessions).length === 0) {
                    await window.dbRemove(window.dbRef(window.db, 'games/keyboardwarriors/activeSessions'));
                } else {
                    await window.dbSet(window.dbRef(window.db, 'games/keyboardwarriors/activeSessions'), activeSessions);
                }
                
                alert(`Session removed for ${displayLocation}`);
                await displayActiveSessions();
            } catch (error) {
                console.error("Error removing session:", error);
                alert("Error removing session: " + error.message);
            }
        }

        async function clearAllSessions() {
            if (!confirm('Clear all active sessions?')) return;
            
            try {
                await window.dbRemove(window.dbRef(window.db, 'games/keyboardwarriors/activeSessions'));
                alert('All sessions cleared');
                await displayActiveSessions();
            } catch (error) {
                console.error("Error clearing sessions:", error);
                alert("Error clearing sessions: " + error.message);
            }
        }

        // Paragraph management functions
        const typingParagraph = document.getElementById('typingParagraph');
        const charCount = document.getElementById('charCount');
        const wordCount = document.getElementById('wordCount');
        const paragraphMessage = document.getElementById('paragraphMessage');

        // Update character and word count
        if (typingParagraph) {
            typingParagraph.addEventListener('input', () => {
                const text = typingParagraph.value;
                charCount.textContent = text.length;
                wordCount.textContent = text.trim() ? text.trim().split(/\s+/).length : 0;
            });
        }

        async function saveParagraph() {
            const paragraph = typingParagraph.value.trim();
            
            try {
                const paragraphRef = window.dbRef(window.db, 'games/keyboardwarriors/settings/paragraph');
                await window.dbSet(paragraphRef, {
                    text: paragraph,
                    updatedAt: Date.now(),
                    updatedBy: 'admin'
                });
                
                paragraphMessage.style.display = 'block';
                paragraphMessage.style.background = 'rgba(0, 255, 0, 0.2)';
                paragraphMessage.style.borderColor = '#0f0';
                paragraphMessage.textContent = 'Paragraph saved successfully!';
                
                setTimeout(() => {
                    paragraphMessage.style.display = 'none';
                }, 3000);
            } catch (error) {
                console.error('Error saving paragraph:', error);
                paragraphMessage.style.display = 'block';
                paragraphMessage.style.background = 'rgba(255, 0, 0, 0.2)';
                paragraphMessage.style.borderColor = '#f00';
                paragraphMessage.textContent = 'Error saving paragraph: ' + error.message;
            }
        }

        async function loadParagraph() {
            try {
                const paragraphRef = window.dbRef(window.db, 'games/keyboardwarriors/settings/paragraph');
                const snapshot = await window.dbGet(paragraphRef);
                
                if (snapshot.exists()) {
                    const data = snapshot.val();
                    typingParagraph.value = data.text || '';
                    
                    // Update counts
                    const text = typingParagraph.value;
                    charCount.textContent = text.length;
                    wordCount.textContent = text.trim() ? text.trim().split(/\s+/).length : 0;
                    
                    paragraphMessage.style.display = 'block';
                    paragraphMessage.style.background = 'rgba(0, 255, 255, 0.2)';
                    paragraphMessage.style.borderColor = '#0ff';
                    paragraphMessage.textContent = 'Paragraph loaded successfully!';
                    
                    setTimeout(() => {
                        paragraphMessage.style.display = 'none';
                    }, 3000);
                } else {
                    paragraphMessage.style.display = 'block';
                    paragraphMessage.style.background = 'rgba(255, 255, 0, 0.2)';
                    paragraphMessage.style.borderColor = '#ff0';
                    paragraphMessage.textContent = 'No paragraph found. Using random words mode.';
                    
                    setTimeout(() => {
                        paragraphMessage.style.display = 'none';
                    }, 3000);
                }
            } catch (error) {
                console.error('Error loading paragraph:', error);
                alert('Error loading paragraph: ' + error.message);
            }
        }

        async function clearParagraph() {
            if (!confirm('Clear the typing paragraph? This will switch to random words mode.')) {
                return;
            }
            
            try {
                const paragraphRef = window.dbRef(window.db, 'games/keyboardwarriors/settings/paragraph');
                await window.dbRemove(paragraphRef);
                
                typingParagraph.value = '';
                charCount.textContent = '0';
                wordCount.textContent = '0';
                
                paragraphMessage.style.display = 'block';
                paragraphMessage.style.background = 'rgba(0, 255, 255, 0.2)';
                paragraphMessage.style.borderColor = '#0ff';
                paragraphMessage.textContent = 'Paragraph cleared. Now using random words mode.';
                
                setTimeout(() => {
                    paragraphMessage.style.display = 'none';
                }, 3000);
            } catch (error) {
                console.error('Error clearing paragraph:', error);
                alert('Error clearing paragraph: ' + error.message);
            }
        }

        // Make functions global
        window.deleteScore = deleteScore;
        window.loadExistingSessions = loadExistingSessions;
        window.activateSession = activateSession;
        window.filterSessionsByLocation = filterSessionsByLocation;
        window.removeSessionForLocation = removeSessionForLocation;
        window.clearAllSessions = clearAllSessions;
        window.saveParagraph = saveParagraph;
        window.loadParagraph = loadParagraph;
        window.clearParagraph = clearParagraph;

        // Load sessions and paragraph on page load
        setTimeout(() => {
            if (!document.getElementById('adminContainer').classList.contains('hidden')) {
                loadExistingSessions();
                loadParagraph();
            }
        }, 1000);
    </script>
</body>
</html>

