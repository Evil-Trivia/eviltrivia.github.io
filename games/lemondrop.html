<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Evil Trivia - Lemon Drop</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    body {
      font-family: 'Press Start 2P', cursive;
      background: linear-gradient(180deg, #87CEEB 0%, #4A90A4 100%);
      touch-action: manipulation;
      user-select: none;
      display: flex;
      flex-direction: column;
    }
    
    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
      padding: 15px;
      position: relative;
      overflow-y: auto;
    }
    
    h1 {
      text-align: center;
      color: #fff;
      margin-bottom: 10px;
      font-size: 24px;
      line-height: 1.5;
    }
    
    .subtitle {
      text-align: center;
      color: #FFD700;
      margin-bottom: 15px;
      font-size: 10px;
      line-height: 1.8;
    }

    .game-card {
      background: #8B4513;
      border: 4px solid #654321;
      padding: 20px;
      box-shadow: 8px 8px 0px rgba(0,0,0,0.5);
      margin-top: 15px;
      position: relative;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }
    
    .setup-form {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .form-group {
      width: 100%;
      max-width: 400px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 10px;
      color: #FFD700;
      text-shadow: 2px 2px 0px #000;
    }
    
    .form-group input,
    .form-group select {
      width: 100%;
      padding: 12px;
      font-size: 12px;
      font-family: 'Press Start 2P', cursive;
      border: 3px solid #000;
      background: #F5DEB3;
      box-sizing: border-box;
      image-rendering: pixelated;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: 3px solid #FFD700;
    }
    
    .button-group {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .btn {
      padding: 15px 25px;
      background-color: #228B22;
      color: white;
      border: 3px solid #000;
      cursor: pointer;
      font-size: 12px;
      font-family: 'Press Start 2P', cursive;
      box-shadow: 4px 4px 0px #000;
      transition: all 0.1s;
    }
    
    .btn:hover {
      background-color: #32CD32;
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0px #000;
    }
    
    .btn:active {
      transform: translate(4px, 4px);
      box-shadow: 0px 0px 0px #000;
    }
    
    .btn:disabled {
      background-color: #666;
      cursor: not-allowed;
    }
    
    .btn-secondary {
      background-color: #4169E1;
    }
    
    .btn-secondary:hover {
      background-color: #6495ED;
    }
    
    #gameCanvas {
      border: 4px solid #000;
      display: block;
      margin: 0 auto;
      background: linear-gradient(180deg, #87CEEB 0%, #90EE90 97%, #8B7355 97%, #654321 100%);
      box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      width: 100%;
      max-width: 100%;
      flex-shrink: 0;
    }
    
    .game-area {
      display: none;
    }

    .game-hud {
      text-align: center;
      margin-bottom: 15px;
      padding: 15px;
      background: rgba(0,0,0,0.7);
      border: 3px solid #000;
      border-radius: 0;
    }

    .score-display {
      font-size: 16px;
      color: #FFD700;
      text-shadow: 2px 2px 0px #000;
      margin-bottom: 10px;
    }

    .instructions {
      font-size: 8px;
      color: #fff;
      line-height: 1.8;
      text-shadow: 1px 1px 0px #000;
    }
    
    .results {
      display: none;
      text-align: center;
      background: rgba(0,0,0,0.8);
      padding: 30px;
      border: 4px solid #FFD700;
      margin-top: 20px;
    }
    
    .game-over-title {
      font-size: 24px;
      color: #FF4444;
      text-shadow: 3px 3px 0px #000;
      margin-bottom: 20px;
    }

    .final-score {
      font-size: 20px;
      color: #FFD700;
      text-shadow: 2px 2px 0px #000;
      margin: 20px 0;
      line-height: 1.8;
    }
    
    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 15px 25px;
      border: 3px solid #FFD700;
      color: #fff;
      font-size: 8px;
      text-shadow: 1px 1px 0px #000;
      z-index: 1000;
      line-height: 1.8;
    }

    .touch-controls {
      display: none;
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      pointer-events: none;
      z-index: 999;
      transition: opacity 0.5s;
    }
    
    .touch-controls.fading {
      opacity: 0.2;
    }

    .touch-controls.active {
      display: block;
    }

    .touch-left, .touch-right {
      position: absolute;
      width: 50%;
      height: 100%;
      pointer-events: all;
      opacity: 0.3;
      transition: opacity 0.1s;
    }

    .touch-left {
      left: 0;
      background: linear-gradient(to right, rgba(255,0,0,0.5), transparent);
      border-right: 2px dashed #fff;
    }

    .touch-right {
      right: 0;
      background: linear-gradient(to left, rgba(0,0,255,0.5), transparent);
      border-left: 2px dashed #fff;
    }

    .touch-left:active, .touch-right:active {
      opacity: 0.6;
    }

    .touch-intro {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      justify-content: center;
      align-items: stretch;
      z-index: 2000;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .touch-intro.hidden {
      display: none;
    }

    .touch-intro .touch-half {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 14px;
      gap: 10px;
    }

    .touch-intro .touch-half-left {
      background: rgba(0, 0, 0, 0.3);
      border-right: 2px solid rgba(255,255,255,0.2);
    }

    .touch-intro .touch-half-right {
      background: rgba(0, 0, 0, 0.3);
      border-left: 2px solid rgba(255,255,255,0.2);
    }

    .touch-intro .touch-label {
      font-size: 16px;
      color: #FFD700;
    }

    .touch-intro .touch-hint {
      font-size: 12px;
      color: #fff;
    }

    .touch-intro-cta {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: #FFD700;
      color: #000;
      padding: 12px 24px;
      border: 3px solid #000;
      box-shadow: 4px 4px 0 #000;
      font-size: 12px;
    }

    .hidden {
      display: none;
    }

    .rotate-prompt {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 9999;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      text-align: center;
      padding: 20px;
    }
    .rotate-prompt.show {
      display: flex;
    }
    .rotate-icon {
      font-size: 80px;
      margin-bottom: 20px;
      animation: rotate 2s ease-in-out infinite;
    }
    @keyframes rotate {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }
    .rotate-text {
      font-size: 16px;
      line-height: 1.8;
    }
    .rotate-icon-portrait {
      font-size: 80px;
      margin-bottom: 20px;
      animation: rotateBack 2s ease-in-out infinite;
    }
    @keyframes rotateBack {
      0%, 100% { transform: rotate(90deg); }
      50% { transform: rotate(0deg); }
    }
    @media (max-width: 700px) and (orientation: landscape) {
      .rotate-prompt {
        display: flex;
      }
    }
    @media (max-width: 900px) and (orientation: landscape), (max-height: 600px) and (orientation: landscape) {
      body {
        padding: 0;
      }
      .container {
        padding: 5px;
      }
      h1 {
        font-size: 14px;
        margin-bottom: 3px;
      }
      .subtitle {
        font-size: 7px;
        margin-bottom: 5px;
      }
      .game-card {
        padding: 8px;
        margin-top: 5px;
      }
      .game-hud {
        padding: 8px;
        margin-bottom: 5px;
      }
      .score-display {
        font-size: 12px;
        margin-bottom: 5px;
      }
      .instructions {
        font-size: 6px;
      }
      #gameCanvas {
        height: calc(100vh - 100px) !important;
        border-width: 2px;
      }
      .touch-controls.active {
        display: block;
        height: 80px;
      }
      .touch-left, .touch-right {
        height: 80px;
      }
      .controls-hint {
        display: none;
      }
    }
    @media (max-width: 600px) and (orientation: portrait) {
      h1 {
        font-size: 16px;
      }
      
      .subtitle {
        font-size: 8px;
      }

      .game-card {
        padding: 10px;
      }

      .btn {
        font-size: 10px;
        padding: 12px 20px;
      }

      .touch-controls.active {
        display: block;
      }

      .controls-hint {
        display: none;
      }
    }

    @media (max-width: 400px) {
      h1 {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üçã LEMON DROP üçã</h1>
    <div class="subtitle">
      Dodge the falling pens!<br>Move with arrow keys or tap screen sides
    </div>

    <div class="game-card">
      <!-- Setup Form -->
      <div id="setupForm" class="setup-form">
        <div class="form-group">
          <label for="barLocation">BAR LOCATION:</label>
          <select id="barLocation" onchange="onLocationChange()">
            <option value="">Select location...</option>
            <option value="St. Dymphna's">St. Dymphna's</option>
            <option value="Radegast Hall">Radegast Hall</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="teamSelect">SELECT TEAM:</label>
          <select id="teamSelect">
            <option value="">Loading teams...</option>
          </select>
        </div>
        
        <div class="button-group">
          <button class="btn" onclick="startGame(false)">PLAY GAME</button>
        </div>
      </div>

      <!-- Game Area -->
      <div id="gameArea" class="game-area">
        <div class="game-hud">
          <div class="score-display">TIME SURVIVED: <span id="scoreValue">0</span>s</div>
          <div class="instructions">Dodge the pens! Don't let them hit the lemon!</div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
      </div>

      <!-- Results -->
      <div id="results" class="results">
        <div class="game-over-title">GAME OVER!</div>
        <div class="final-score">YOU SURVIVED: <span id="finalScore">0</span> SECONDS</div>
        <div id="submissionMessage1" style="margin: 15px 0; font-size: 12px; color: #32CD32; display: none;">
          ‚úì Score saved successfully!
        </div>
        <div id="scoreStats" style="margin: 20px 0; font-size: 10px; line-height: 2; color: #FFD700;">
          <div>YOUR TEAM'S BEST: <span id="bestScoreDisplay">Loading...</span></div>
        </div>
        <div class="button-group">
          <button class="btn" onclick="resetGame()">PLAY AGAIN</button>
          <button class="btn btn-secondary" onclick="backToMenu()">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <div class="controls-hint" id="controlsHint">
    ‚¨ÖÔ∏è LEFT ARROW  |  RIGHT ARROW ‚û°Ô∏è
  </div>

  <div class="touch-controls" id="touchControls">
    <div class="touch-left" id="touchLeft"></div>
    <div class="touch-right" id="touchRight"></div>
  </div>

  <div id="touchIntro" class="touch-intro hidden">
    <div class="touch-half touch-half-left">
      <div class="touch-label">Tap Left</div>
      <div class="touch-hint">Move Left</div>
    </div>
    <div class="touch-half touch-half-right">
      <div class="touch-label">Tap Right</div>
      <div class="touch-hint">Move Right</div>
    </div>
    <div class="touch-intro-cta">Tap anywhere to begin</div>
  </div>

  <div class="rotate-prompt" id="rotatePrompt">
    <div class="rotate-icon-portrait">üì±‚û°Ô∏è</div>
    <div class="rotate-text">
      Please rotate your device<br>to portrait mode<br>for the best experience
    </div>
  </div>

  <!-- Firebase -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
    import { getDatabase, ref, push, set, get } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyBruAY3SH0eO000LrYqwcOGXNaUuznoMkc",
        authDomain: "eviltrivia-47664.firebaseapp.com",
        databaseURL: "https://eviltrivia-47664-default-rtdb.firebaseio.com",
        projectId: "eviltrivia-47664",
        storageBucket: "eviltrivia-47664.firebaseapp.com",
        messagingSenderId: "401826818140",
        appId: "1:401826818140:web:c1df0bf4c602cc48231e99",
        measurementId: "G-2W6RK96Y34"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    window.db = db;
    window.dbRef = ref;
    window.dbPush = push;
    window.dbSet = set;
    window.dbGet = get;
  </script>

  <script>
    // Game variables
    let engine, render, world;
    let lemon, ground, leftWall, rightWall;
    let pens = [];
    let score = 0;
    let gameActive = false;
    let isPracticeMode = false;
    let penSpawnInterval;
    let gameSpeed = 1;
    let lemonImage;
    let gameStartTime = 0;
    let scoreUpdateInterval;
    const LEMON_SIZE_MULTIPLIER = 1.5;
    const LEMON_CONTROL_FORCE = 0.00022;
    const LEMON_MAX_SPEED = 4.2;
    const LEMON_MAX_SPIN = 0.32;
    const LEMON_FRICTION = 0.8;
    const LEMON_AIR_DRAG = 0.005;
    const LEMON_CONTROL_TORQUE = 0.0018;
    const LEMON_ROLL_DAMPING = 0.07;
    const LEMON_RESTITUTION = 0.2;
    const LEMON_DENSITY = 0.0018;
    const LEMON_SKIP_MIN_SPEED = 1.5;
    const LEMON_SKIP_FORCE_BASE = 0.6;
    const LEMON_SKIP_FORCE_SCALE = 0.25;
    const PEN_FALL_SPEED_SCALE = 0.8;
    const PEN_GRAVITY_SCALE = 0.8;
    const PEN_RESTITUTION = 0.25;
    const GROUND_RESTITUTION = 0.25;
    const IDLE_PEN_TIMEOUT = 1000;
    const IDLE_EDGE_BUFFER = 40;
    
    const { Engine, Render, World, Bodies, Body, Events } = Matter;
    
    // DOM elements
    const setupForm = document.getElementById('setupForm');
    const gameArea = document.getElementById('gameArea');
    const results = document.getElementById('results');
    const canvas = document.getElementById('gameCanvas');
    const scoreValue = document.getElementById('scoreValue');
    const finalScoreEl = document.getElementById('finalScore');
    const controlsHint = document.getElementById('controlsHint');
    const touchControls = document.getElementById('touchControls');
    const touchLeft = document.getElementById('touchLeft');
    const touchRight = document.getElementById('touchRight');
    const touchIntro = document.getElementById('touchIntro');
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // Controls
    let keys = {};
    let touchingLeft = false;
    let touchingRight = false;
    let lastInputTime = 0;
    let lastIdleDropTime = 0;
    let touchIntroShown = false;
    let pendingStartConfig = null;
    let penCleanupIntervals = new Set();
    let lemonGroundContacts = 0;
    let lastGroundPoint = null;
    
    function recordInputActivity() {
      lastInputTime = Date.now();
    }
    
    function resetIdleTimers() {
      const now = Date.now();
      lastInputTime = now;
      lastIdleDropTime = now;
    }

    function getCanvasDimensions() {
      const isPortrait = window.innerHeight > window.innerWidth;
      const minWidth = 320;
      const maxWidth = 800;
      
      if (isPortrait) {
        // Portrait mode - maximize vertical space
        const width = Math.max(minWidth, Math.min(maxWidth, window.innerWidth - 30));
        const availableHeight = window.innerHeight - 280;
        const height = Math.max(500, Math.min(900, availableHeight));
        return { width, height };
      } else {
        // Landscape mode - fit to screen
        const width = Math.max(minWidth, Math.min(maxWidth, window.innerWidth - 40));
        const availableHeight = window.innerHeight - 180;
        const height = Math.max(400, Math.min(700, availableHeight));
        return { width, height };
      }
    }

    function applyCanvasDimensions() {
      const { width, height } = getCanvasDimensions();
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      return { width, height };
    }

    applyCanvasDimensions();

    window.addEventListener('resize', () => {
      if (!gameActive) {
        applyCanvasDimensions();
      }
    });

    if (touchIntro) {
      touchIntro.addEventListener('click', () => {
        if (touchIntro.classList.contains('hidden')) return;
        touchIntro.classList.add('hidden');
        touchIntroShown = true;
        if (pendingStartConfig) {
          beginGameplay(pendingStartConfig.practiceMode);
        }
      });
    }
    
    async function onLocationChange() {
      const location = document.getElementById('barLocation').value;
      const teamSelect = document.getElementById('teamSelect');
      
      if (!location) {
        teamSelect.innerHTML = '<option value="">Select location first</option>';
        return;
      }
      
      await loadTeamsForLocation(location);
    }

    async function loadTeamsForLocation(location) {
      try {
        const teamSelect = document.getElementById('teamSelect');
        teamSelect.innerHTML = '<option value="">Loading...</option>';
        
        // Load teams for this specific location from active sessions
        const activeSessionsSnap = await window.dbGet(window.dbRef(window.db, 'games/lemondrop/activeSessions'));
        
        if (!activeSessionsSnap.exists()) {
          teamSelect.innerHTML = '<option value="">No active sessions - contact admin</option>';
          return;
        }
        
        const activeSessions = activeSessionsSnap.val();
        
        // Find session by matching the location field (not the key)
        let sessionData = null;
        for (const key in activeSessions) {
          if (activeSessions[key].location === location) {
            sessionData = activeSessions[key];
            break;
          }
        }
        
        if (!sessionData || !sessionData.teams || sessionData.teams.length === 0) {
          teamSelect.innerHTML = '<option value="">No active session for this location</option>';
          return;
        }
        
        // Populate with teams from this location only
        teamSelect.innerHTML = '<option value="">Select your team...</option>';
        sessionData.teams.sort().forEach(teamName => {
          const option = document.createElement('option');
          option.value = teamName;
          option.textContent = teamName;
          teamSelect.appendChild(option);
        });
        
      } catch (error) {
        console.error('Error loading teams:', error);
        document.getElementById('teamSelect').innerHTML = '<option value="">Error loading teams</option>';
      }
    }

    function startGame(practiceMode) {
      const teamName = document.getElementById('teamSelect').value;
      const barLocation = document.getElementById('barLocation').value;
      
      if (!teamName || !barLocation) {
        alert('Please select team name and bar location.');
        return;
      }
      
      pendingStartConfig = { practiceMode };
      
      if (isTouchDevice && !touchIntroShown && touchIntro) {
        touchIntro.classList.remove('hidden');
        return;
      }
      
      beginGameplay(practiceMode);
    }

    function beginGameplay(practiceMode) {
      pendingStartConfig = null;
      isPracticeMode = practiceMode;
      score = 0;
      gameStartTime = Date.now();
      scoreValue.textContent = '0';
      resetIdleTimers();
      if (touchControls) {
        touchControls.classList.toggle('active', !!isTouchDevice);
      }
      
      setupForm.style.display = 'none';
      gameArea.style.display = 'block';
      results.style.display = 'none';
      
      initGame();
    }
    
    function initGame() {
      // Create engine
      engine = Engine.create();
      world = engine.world;
      world.gravity.y = 1;
      lemonGroundContacts = 0;
      lastGroundPoint = null;
      resetIdleTimers();
      
      // Canvas setup
      const { width: canvasWidth, height: canvasHeight } = applyCanvasDimensions();
      
      render = Render.create({
        canvas: canvas,
        engine: engine,
        options: {
          width: canvasWidth,
          height: canvasHeight,
          wireframes: false,
          background: 'transparent',
          showCollisions: false,
          showVertexNumbers: false,
          showConvexHulls: false
        }
      });
      
      // Create ground (dirt) - thin line at bottom
      // Only lemon collides with ground, pens pass through
      ground = Bodies.rectangle(canvasWidth / 2, canvasHeight - 3, canvasWidth, 6, { 
        isStatic: true,
        friction: 0.95,
        restitution: 0.1,
        collisionFilter: {
          category: 0x0001,
          mask: 0x0002  // Only collides with lemon category
        },
        render: {
          fillStyle: '#5a4a3a',
          strokeStyle: '#3a2a1a',
          lineWidth: 2
        }
      });
      
      // Create walls
      leftWall = Bodies.rectangle(0, canvasHeight / 2, 20, canvasHeight, { 
        isStatic: true,
        render: {
          fillStyle: '#654321'
        }
      });
      
      rightWall = Bodies.rectangle(canvasWidth, canvasHeight / 2, 20, canvasHeight, { 
        isStatic: true,
        render: {
          fillStyle: '#654321'
        }
      });
      
      // Load lemon image and create lemon body
      lemonImage = new Image();
      lemonImage.src = '../images/lemon.png';
      
      lemonImage.onload = () => {
        // Get actual image dimensions
        const imgWidth = lemonImage.width;
        const imgHeight = lemonImage.height;
        
        // Target size for the lemon in the game (MUCH SMALLER)
        const baseLemonSize = 35; // pixels
        const targetSize = baseLemonSize * LEMON_SIZE_MULTIPLIER;
        const spriteScale = targetSize / imgWidth;
        
        // Trace the lemon PNG outline based on actual image (1000x1000px)
        // Vertices trace the BLACK OUTLINE of the lemon, centered at (0, 0)
        // Using more vertices for smoother rolling
        const lemonVertices = [
          { x: 0, y: -490 },      // very top
          { x: 50, y: -485 },     // top right
          { x: 100, y: -475 },    
          { x: 150, y: -460 },    
          { x: 200, y: -440 },    
          { x: 250, y: -415 },    
          { x: 300, y: -380 },    
          { x: 345, y: -340 },    
          { x: 385, y: -295 },    
          { x: 420, y: -245 },    
          { x: 445, y: -190 },    
          { x: 465, y: -130 },    
          { x: 478, y: -65 },     
          { x: 485, y: 0 },       // right widest
          { x: 485, y: 65 },      
          { x: 478, y: 130 },     
          { x: 465, y: 190 },     
          { x: 445, y: 245 },     
          { x: 420, y: 295 },     
          { x: 385, y: 340 },     
          { x: 345, y: 380 },     
          { x: 300, y: 415 },     
          { x: 250, y: 440 },     
          { x: 200, y: 460 },     
          { x: 150, y: 475 },     
          { x: 100, y: 485 },     
          { x: 50, y: 490 },      
          { x: 0, y: 492 },       // bottom tip
          { x: -50, y: 490 },     
          { x: -100, y: 485 },    
          { x: -150, y: 475 },    
          { x: -200, y: 460 },    
          { x: -250, y: 440 },    
          { x: -300, y: 415 },    
          { x: -345, y: 380 },    
          { x: -385, y: 340 },    
          { x: -420, y: 295 },    
          { x: -445, y: 245 },    
          { x: -465, y: 190 },    
          { x: -478, y: 130 },    
          { x: -485, y: 65 },     
          { x: -490, y: 0 },      // left widest
          { x: -485, y: -65 },    
          { x: -478, y: -130 },   
          { x: -465, y: -190 },   
          { x: -445, y: -245 },   
          { x: -420, y: -295 },   
          { x: -385, y: -340 },   
          { x: -345, y: -380 },   
          { x: -300, y: -415 },   
          { x: -250, y: -440 },   
          { x: -200, y: -460 },   
          { x: -150, y: -475 },   
          { x: -100, y: -485 },   
          { x: -50, y: -490 }     // back to top
        ];
        
        // Scale vertices to match sprite size
        const scaledVertices = lemonVertices.map(v => ({
          x: v.x * spriteScale,
          y: v.y * spriteScale
        }));
        
        lemon = Bodies.fromVertices(
          canvasWidth / 2, 
          canvasHeight - 35, 
          [scaledVertices], 
          {
            density: 0.002,
            friction: 0.8,
            frictionStatic: 0.9,
            frictionAir: LEMON_AIR_DRAG,
            restitution: 0.15,
            collisionFilter: {
              category: 0x0002,
              mask: 0x0001 | 0x0004
            },
            render: {
              sprite: {
                texture: '../images/lemon.png',
                xScale: spriteScale,
                yScale: spriteScale,
                yOffset: 0
              }
            }
          },
          true // flagInternal = true for better vertex processing
        );
        
        World.add(world, [ground, leftWall, rightWall, lemon]);
        
        // Start game loop
        Render.run(render);
        Engine.run(engine);
        
        gameActive = true;
        gameStartTime = Date.now();
        startSpawningPens();
        startScoreTimer();
        
        // Fade touch controls after 3 seconds
        setTimeout(() => {
          if (touchControls) {
            touchControls.classList.add('fading');
          }
        }, 3000);
      };
      
      // Collision detection
      Events.on(engine, 'collisionStart', (event) => {
        const pairs = event.pairs;
        
        pairs.forEach(pair => {
          const { bodyA, bodyB } = pair;
          
          // Check if pen hit lemon
          if ((bodyA === lemon || bodyB === lemon) && gameActive) {
            const other = bodyA === lemon ? bodyB : bodyA;
            if (other.label === 'pen') {
              gameOver();
              return;
            }
            
            if (other === ground) {
              lemonGroundContacts += 1;
              lastGroundPoint = pair.collision && pair.collision.supports
                ? pair.collision.supports[0]
                : lemon.position;
              handleLemonGroundImpact(pair);
            }
          }
        });
      });

      Events.on(engine, 'collisionEnd', (event) => {
        event.pairs.forEach(pair => {
          if ((pair.bodyA === lemon || pair.bodyB === lemon) && (pair.bodyA === ground || pair.bodyB === ground)) {
            lemonGroundContacts = Math.max(0, lemonGroundContacts - 1);
            if (lemonGroundContacts === 0) {
              lastGroundPoint = null;
            }
          }
        });
      });
      
      function handleLemonGroundImpact(pair) {
        if (!lemon || !ground) return;
        
        const horizontalSpeed = Math.abs(lemon.velocity.x);
        if (horizontalSpeed < LEMON_SKIP_MIN_SPEED || lemon.velocity.y < 0.5) return;
        
        const gravityScale = world.gravity.scale ?? 0.001;
        const contactPoint = (pair.collision && pair.collision.supports && pair.collision.supports[0]) || lemon.position;
        const tangentialFactor = Math.max(0, horizontalSpeed - LEMON_SKIP_MIN_SPEED) * LEMON_SKIP_FORCE_SCALE;
        const spinFactor = Math.min(0.4, Math.abs(lemon.angularVelocity) * 0.2);
        const skipIntensity = Math.min(1.4, LEMON_SKIP_FORCE_BASE + tangentialFactor + spinFactor);
        
        if (skipIntensity <= 0) return;
        
        const upwardForce = lemon.mass * world.gravity.y * gravityScale * skipIntensity;
        Body.applyForce(lemon, contactPoint, { x: 0, y: -upwardForce });
      }
      
      // Update loop for controls
      Events.on(engine, 'beforeUpdate', () => {
        if (!gameActive || !lemon) return;
        
        let inputDirection = 0;
        if (keys.ArrowLeft || touchingLeft) inputDirection -= 1;
        if (keys.ArrowRight || touchingRight) inputDirection += 1;
        
        if (inputDirection !== 0) {
          Body.applyForce(lemon, lemon.position, {
            x: inputDirection * LEMON_CONTROL_FORCE,
            y: 0
          });
          Body.setAngularVelocity(lemon, lemon.angularVelocity + inputDirection * 0.02);
          recordInputActivity();
        } else if (Math.abs(lemon.velocity.x) > 0.01) {
          const dampingFactor = 1 - LEMON_ROLL_DAMPING;
          Body.setVelocity(lemon, {
            x: lemon.velocity.x * dampingFactor,
            y: lemon.velocity.y
          });
        }
        
        // Limit max velocity to prevent flying off screen
        if (Math.abs(lemon.velocity.x) > LEMON_MAX_SPEED) {
          Body.setVelocity(lemon, { 
            x: Math.sign(lemon.velocity.x) * LEMON_MAX_SPEED, 
            y: lemon.velocity.y 
          });
        }
        
        if (Math.abs(lemon.angularVelocity) > LEMON_MAX_SPIN) {
          Body.setAngularVelocity(lemon, Math.sign(lemon.angularVelocity) * LEMON_MAX_SPIN);
        }
        
        const gravityScale = world.gravity.scale ?? 0.001;
        pens.forEach(pen => {
          if (!pen || pen.isSleeping) return;
          const counterForce = pen.mass * world.gravity.y * gravityScale * (1 - PEN_GRAVITY_SCALE);
          if (!counterForce) return;
          Body.applyForce(pen, pen.position, { x: 0, y: -counterForce });
        });

        const now = Date.now();
        if (
          now - lastInputTime >= IDLE_PEN_TIMEOUT &&
          now - lastIdleDropTime >= IDLE_PEN_TIMEOUT
        ) {
          dropPenAboveLemon();
          lastIdleDropTime = now;
        }
      });
    }
    
    function startScoreTimer() {
      scoreUpdateInterval = setInterval(() => {
        if (!gameActive) {
          clearInterval(scoreUpdateInterval);
          return;
        }
        score = Math.floor((Date.now() - gameStartTime) / 1000);
        scoreValue.textContent = score;
      }, 100);
    }
    
    function startSpawningPens() {
      let baseSpawnRate = 800; // Start spawning every 800ms
      
      function schedulePenSpawn() {
        if (!gameActive) return;
        
        // Increase spawn rate based on time survived (score)
        const spawnDelay = Math.max(200, baseSpawnRate - (score * 15));
        
        penSpawnInterval = setTimeout(() => {
          spawnPen();
          schedulePenSpawn(); // Schedule next spawn
        }, spawnDelay);
      }
      
      schedulePenSpawn();
    }
    
    function spawnPen(targetX) {
      const canvasWidth = canvas.width;
      const hasTarget = typeof targetX === 'number' && !Number.isNaN(targetX);
      const x = hasTarget
        ? Math.max(IDLE_EDGE_BUFFER, Math.min(canvasWidth - IDLE_EDGE_BUFFER, targetX))
        : Math.random() * (canvasWidth - 100) + 50;
      
      // Create pen body (looks like a real pen)
      const penColors = ['#000000', '#0000FF', '#FF0000', '#000080', '#008000'];
      const color = penColors[Math.floor(Math.random() * penColors.length)];
      
      // Create compound body for pen shape
      const penTip = Bodies.trapezoid(x, -20, 5, 8, 0.2, {
        label: 'pen',
        render: {
          fillStyle: '#FFD700'
        }
      });
      
      const penBody = Bodies.rectangle(x, -35, 6, 50, {
        label: 'pen',
        render: {
          fillStyle: color
        }
      });
      
      const penTop = Bodies.circle(x, -62, 4, {
        label: 'pen',
        render: {
          fillStyle: color
        }
      });
      
      // Combine into one pen
      const pen = Body.create({
        parts: [penBody, penTip, penTop],
        label: 'pen',
        density: 0.001,
        friction: 0.1,
        frictionAir: 0.01,
        restitution: PEN_RESTITUTION,
        angle: Math.random() * Math.PI * 0.5 - Math.PI * 0.25, // Slight random angle
        collisionFilter: {
          category: 0x0004,  // Pen category
          mask: 0x0002  // Only collides with lemon (not ground)
        }
      });
      
      pen.removed = false;
      
      // Add some random horizontal velocity
      Body.setVelocity(pen, { 
        x: hasTarget ? 0 : (Math.random() - 0.5) * 2, 
        y: (2 + gameSpeed) * PEN_FALL_SPEED_SCALE
      });
      
      // Add slight rotation
      Body.setAngularVelocity(pen, (Math.random() - 0.5) * 0.1);
      
      World.add(world, pen);
      pens.push(pen);
      
      // Check pen position periodically and remove if off screen
      const checkPenInterval = setInterval(() => {
        if (!gameActive || !pens.includes(pen)) {
          clearInterval(checkPenInterval);
          penCleanupIntervals.delete(checkPenInterval);
          return;
        }
        
        // Remove pen if it's fallen below the screen
        if (pen.position.y > canvas.height + 100) {
          World.remove(world, pen);
          pens = pens.filter(p => p !== pen);
          clearInterval(checkPenInterval);
          penCleanupIntervals.delete(checkPenInterval);
        }
      }, 500);
      penCleanupIntervals.add(checkPenInterval);
    }
    
    function dropPenAboveLemon() {
      if (!gameActive || !lemon) return;
      spawnPen(lemon.position.x);
    }

    function applyRollTorque(direction) {
      if (!lemon) return;
      const halfHeight = (lemon.bounds.max.y - lemon.bounds.min.y) / 2;
      const topPoint = {
        x: lemon.position.x,
        y: lemon.position.y - halfHeight * 0.9
      };
      const bottomPoint = {
        x: lemon.position.x,
        y: lemon.position.y + halfHeight * 0.9
      };
      const torqueForce = direction * LEMON_CONTROL_TORQUE;
      Body.applyForce(lemon, topPoint, { x: torqueForce, y: 0 });
      Body.applyForce(lemon, bottomPoint, { x: -torqueForce, y: 0 });
    }

    function stopSpawningPens() {
      if (penSpawnInterval) {
        clearTimeout(penSpawnInterval);
        penSpawnInterval = null;
      }
    }

    function cleanupPens() {
      penCleanupIntervals.forEach(intervalId => clearInterval(intervalId));
      penCleanupIntervals.clear();
      if (world) {
        pens.forEach(pen => {
          if (pen && !pen.isStatic) {
            World.remove(world, pen);
          }
        });
      }
      pens = [];
    }
    
    function gameOver() {
      if (!gameActive) return;
      gameActive = false;
      
      // Calculate final score
      score = Math.floor((Date.now() - gameStartTime) / 1000);
      
      // Stop spawning and scoring
      stopSpawningPens();
      clearInterval(scoreUpdateInterval);
      
      // Create lemon juice splatter effect
      createJuiceSplatter();
      
      // Show game over after brief delay
      setTimeout(() => {
        cleanupPens();
        // Clean up
        if (render) {
          Render.stop(render);
          Engine.clear(engine);
          World.clear(world);
        }
        
        // Show results
        gameArea.style.display = 'none';
        results.style.display = 'block';
        finalScoreEl.textContent = score;
        
        // Submit score first, then load stats to show updated best
        submitScore().then(() => {
          setTimeout(() => {
            loadScoreStats();
          }, 500);
        });
      }, 1500);
    }
    
    async function loadScoreStats() {
      try {
        const currentTeam = document.getElementById('teamSelect').value;
        document.getElementById('bestScoreDisplay').textContent = 'Loading...';
        
        const scores = [];
        
        // Load from both paths
        const mainSnap = await window.dbGet(window.dbRef(window.db, 'games/lemondrop/answers'));
        if (mainSnap.exists()) {
          Object.values(mainSnap.val()).forEach(s => scores.push(s));
        }
        
        const publicSnap = await window.dbGet(window.dbRef(window.db, 'publicAnswers/lemondrop'));
        if (publicSnap.exists()) {
          Object.values(publicSnap.val()).forEach(s => scores.push(s));
        }
        
        if (scores.length === 0) {
          document.getElementById('bestScoreDisplay').textContent = 'No scores yet';
          return;
        }
        
        // Filter scores for current team
        const teamScores = scores.filter(s => s.teamName === currentTeam);
        
        if (teamScores.length === 0) {
          document.getElementById('bestScoreDisplay').textContent = 'First score for your team!';
        } else {
          const bestScore = Math.max(...teamScores.map(s => s.score || 0));
          document.getElementById('bestScoreDisplay').textContent = `${bestScore}s`;
        }
        
      } catch (error) {
        console.error('Error loading score stats:', error);
        document.getElementById('bestScoreDisplay').textContent = 'Error';
      }
    }
    
    function createJuiceSplatter() {
      if (!lemon) return;
      
      const juiceCount = 20;
      for (let i = 0; i < juiceCount; i++) {
        const angle = (Math.PI * 2 * i) / juiceCount;
        const speed = 5 + Math.random() * 5;
        
        const juice = Bodies.circle(
          lemon.position.x,
          lemon.position.y,
          3 + Math.random() * 3,
          {
            friction: 0.001,
            restitution: 0.8,
            render: {
              fillStyle: '#FFD700'
            }
          }
        );
        
        Body.setVelocity(juice, {
          x: Math.cos(angle) * speed,
          y: Math.sin(angle) * speed
        });
        
        World.add(world, juice);
        
        // Remove juice after a bit
        setTimeout(() => {
          World.remove(world, juice);
        }, 2000);
      }
    }
    
    async function submitScore() {
      const teamName = document.getElementById('teamSelect').value;
      const barLocation = document.getElementById('barLocation').value;
      
      if (!teamName || !barLocation) return;
      
      const scoreData = {
        teamName: teamName,
        barLocation: barLocation,
        score: score,
        timestamp: Date.now(),
        date: new Date().toISOString().split('T')[0]
      };
      
      try {
        const answersRef = window.dbRef(window.db, 'games/lemondrop/answers');
        const newAnswerRef = window.dbPush(answersRef);
        await window.dbSet(newAnswerRef, scoreData);
        console.log('Score submitted successfully');
        document.getElementById('submissionMessage1').style.display = 'block';
      } catch (error) {
        console.error('Error submitting to main path:', error);
        
        try {
          const publicAnswersRef = window.dbRef(window.db, 'publicAnswers/lemondrop');
          const newAnswerRef = window.dbPush(publicAnswersRef);
          await window.dbSet(newAnswerRef, scoreData);
          console.log('Score submitted to fallback path');
          document.getElementById('submissionMessage1').style.display = 'block';
        } catch (fallbackError) {
          console.error('Error submitting to fallback path:', fallbackError);
        }
      }
    }
    
    function resetGame() {
      // Don't return to menu, just restart with same team
      results.style.display = 'none';
      gameArea.style.display = 'block';
      
      score = 0;
      gameStartTime = Date.now();
      scoreValue.textContent = '0';
      gameSpeed = 1;
      pens = [];
      resetIdleTimers();
      
      // Clean up old game
      if (render) {
        Render.stop(render);
        Engine.clear(engine);
        World.clear(world);
      }
      stopSpawningPens();
      clearInterval(scoreUpdateInterval);
      cleanupPens();
      
      // Start fresh game
      initGame();
    }
    
    function backToMenu() {
      results.style.display = 'none';
      gameArea.style.display = 'none';
      setupForm.style.display = 'flex';
      if (touchControls) {
        touchControls.classList.remove('active');
      }
      
      // Clean up game
      if (render) {
        Render.stop(render);
        Engine.clear(engine);
        World.clear(world);
      }
      
      stopSpawningPens();
      clearInterval(scoreUpdateInterval);
      cleanupPens();
      
      score = 0;
      gameSpeed = 1;
      pens = [];
      resetIdleTimers();
    }
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      
      if (gameActive && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
        recordInputActivity();
        e.preventDefault();
      }
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });
    
    // Touch controls
    touchLeft.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchingLeft = true;
      recordInputActivity();
    });
    
    touchLeft.addEventListener('touchend', (e) => {
      e.preventDefault();
      touchingLeft = false;
    });
    
    touchRight.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchingRight = true;
      recordInputActivity();
    });
    
    touchRight.addEventListener('touchend', (e) => {
      e.preventDefault();
      touchingRight = false;
    });
    
    // Make functions global
    window.startGame = startGame;
    window.resetGame = resetGame;
    window.backToMenu = backToMenu;
    window.onLocationChange = onLocationChange;
    
    // Hide controls hint after a few seconds
    setTimeout(() => {
      if (controlsHint) {
        controlsHint.style.display = 'none';
      }
    }, 5000);
  </script>
</body>
</html>

